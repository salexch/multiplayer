/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "../dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by alex on 2/19/2016.
	 */
	;(function() {
	
	    var AggPlayer = __webpack_require__(45);
	    //var AggPlayer = require('./../test/player.js');
	    AggPlayer = window.MultiPlayer;
	    console.log('player', AggPlayer);
	
	
	    AggPlayer.debug(true);
	
	    var player = new AggPlayer.Player('player', {
	        playerVars: {
	            autohide: 2,
	            autoplay: 1,
	            //controls: 0,
	            fs: 1,
	            //loop: 1,
	            modestbranding: 0,
	            rel: 0,
	            showinfo: 0
	        },
	/*        events: {
	            onReady: onPlayerReady2,
	            onStateChange: onPlayerStateChange2
	        }*/
	    }, {
	        preloadSeconds: 1,
	        useTransition: [
	            'circle',
	            'curtain',
	            'frame-it',
	            'jammed-blind',
	            'lateral-swipe',
	            'lazy-stretch',
	            'origami',
	            'parallelogram',
	            'spill',
	            'tilted',
	            'tunnel-vision',
	            'wave',
	            'widescreen-wiper'
	        ]
	    });
	
	    function onPlayerReady() {
	
	    }
	
	
	    function onPlayerStateChange() {
	
	    }
	
	    player.setLoop(true);
	
	    player.loadPlaylist({
	        list: [{
	                id: "5mKFLuqcjrY",
	                api: 'youtube'
	            },{
	                id: "aC07SVaSFnc",
	                api: 'youtube'
	            }]
	    });
	
	    window.videoplayer = player;
	})();

/***/ },

/***/ 45:
/***/ function(module, exports) {

	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "../dist/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Created by alex on 2/18/2016.
		 */
		;(function(window) {
		    window.MultiPlayer = __webpack_require__(1);
		})(window);
		
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Created by alex on 2/15/2016.
		 */
		
		var Q = __webpack_require__(2);
		var _ = __webpack_require__(5);
		
		module.exports = (function() {
		
		    var debug = false;
		
		    function debugLog() {
		        if (debug)
		            console.debug.apply(console, arguments);
		    }
		
		
		    function removeEmptyPlayerContainers() {
		        var divs = this.wrapper.querySelectorAll('div');
		        for(var i =0; i< divs.length; i++)
		            this._wrapper.removeChild(divs[i]);
		    }
		
		
		    var player = function(element, player_params, options) {
		        if ('string' == typeof element)
		            element = document.getElementById(element);
		
		        this._players = [];
		
		        this._anim = {
		            current: null,
		            transitions: [],
		            show: function() {},
		            hide: function() {},
		            hideAll: function() {}
		        };
		
		        this._options = options || {};
		        this._wrapper = element;
		        this._player_params = player_params;
		        this._playlist_index = 0;
		        this._playlist = [];
		        this._mute = 0;
		        this._loop = 0;
		        this._shuffle = 0;
		        this._events = [];
		
		        this._player_params.width = '100%';
		        this._player_params.height = '100%';
		
		
		        if (options && options.useTransition) {
		            this._anim.transitions = options.useTransition.map(function(transition_name) {
		                return __webpack_require__(7)("./" + transition_name + '.js')(this._wrapper);
		            }.bind(this));
		
		            this._anim.show = function(animation_name, bgcolor, fgcolor) {
		                if (!animation_name)
		                    this.current = _.shuffle(this.transitions)[0];
		                else
		                    this.current = this.transitions[options.useTransition.indexOf(animation_name)];
		
		                this.current.setBackgroundColor(bgcolor || '#000');
		
		                this.current.setForegroundColor(fgcolor || '#000');
		
		                return this.current.animation.show();
		            };
		
		            this._anim.hide = function() {
		                return this.current.animation.hide();
		            };
		
		            this._anim.hideAll = function() {
		                this.transitions.forEach(function(transition) {
		                    transition.animation.hide(true);
		                });
		            }
		        }
		    };
		
		    var PlayerState = {
		        ENDED: 0,
		        PLAYING: 1,
		        PAUSED: 2,
		        BUFFERING: 3,
		        CUED: 5
		    };
		
		
		    function _createPlayerElem() {
		        var player_elem = document.createElement('div');
		        //player_elem.style.visibility = 'hidden';
		        player_elem.style.display = 'none';
		        player_elem.style.height = '100%';
		        return player_elem;
		    }
		
		    function _playVideoAt(index) {
		        var video = this._playlist[index];
		
		        if (!video && this._loop) {
		            //this._playlist_index = 0;
		            video = this._playlist[0];
		        }
		
		        if (video) {
		            var player_elem = _createPlayerElem();
		            this._wrapper.appendChild(player_elem);
		            __webpack_require__(41)("./" + video.api + '.js').createPlayer(player_elem, this._player_params).then(function(player) {
		                this._players.push(player);
		                player.bufferVideoById(video.id, this._options.preloadSeconds);
		                _playList.call(this);
		            }.bind(this));
		        }
		    }
		
		    function _attachEvents() {
		        if (this._events.length && this._players.length && this._players[0])
		            this._events.forEach(function(event) {
		                this._players[0].addEventListener(event.event, event.listener);
		            }.bind(this));
		    }
		
		    function _playList() {
		        this._players[0].whenVideoEnd().then(function() {
		            this._players[0].mute();
		            this._anim.hideAll();
		            this._anim.show();
		            this._playlist_index += 1;
		            if (this._loop && this._playlist_index >= this._playlist.length)
		                this._playlist_index = 0;
		            this._players[1].whenStartPlaying().then(function() {
		                //console.debug('Playing video at ', this._playlist_index);
		                this._anim.hide();
		            }.bind(this));
		            if (!this._mute)
		                this._players[1].unMute();
		            this._players[1].continuePlay();
		            this._players[0].destroy();
		            this._players.shift();
		
		            _attachEvents.call(this);
		
		            //TODO: find why it's not working!
		            //removeEmptyPlayerPlaceholders().call(that);
		
		            _playVideoAt.call(this, this._playlist_index + 1);
		        }.bind(this));
		    }
		
		    player.prototype.loadPlaylist = function(params) {
		        if (params.list.length < 1)
		            return false;
		
		        var is_active = this._players.length && (this._players[0].isPlaying() || this._players[0].isPaused());
		/*        if (is_active)
		            this.destroy(true);*/
		
		        this._playlist = params.list || [];
		        this.setShuffle(this._shuffle);
		
		        this._playlist_index = ~~(params.index || 0);
		        if (this._playlist_index >= this._playlist.length)
		            this._playlist_index = 0;
		
		        if (is_active) {
		            this._players[1].destroy();
		            var player_elem = _createPlayerElem();
		
		            this._wrapper.appendChild(player_elem);
		
		            __webpack_require__(41)("./" + this._playlist[0].api + '.js').createPlayer(player_elem, this._player_params).then(function(player) {
		                if (this._mute)
		                    player.mute();
		                this._players[1] = player;
		
		                this._players[1].bufferVideoById(this._playlist[0].id, this._options.preloadSeconds).then(function() {
		                    this._playlist_index = -1;
		                    this._players[0].emulateEvent(0);
		                }.bind(this));
		            }.bind(this));
		
		            return false;
		        }
		
		        var init_playlist = this._playlist.slice(this._playlist_index, this._playlist_index + 2);
		
		        var players_dfd = init_playlist.map(function(video) {
		            var player_elem = _createPlayerElem();
		
		            this._wrapper.appendChild(player_elem);
		
		            return __webpack_require__(41)("./" + video.api + '.js').createPlayer(player_elem, this._player_params);
		        }.bind(this));
		
		        Q.all(players_dfd).then(function(res) {
		            res.forEach(function(player) {
		                if (this._mute)
		                    player.mute();
		                this._players.push(player);
		            }.bind(this));
		
		            _attachEvents.call(this);
		            this._players[0].playVideoById(init_playlist[0].id);
		            if (this._players[1])
		                this._players[1].bufferVideoById(init_playlist[1].id, this._options.preloadSeconds);
		
		            _playList.call(this);
		        }.bind(this));
		    };
		
		    player.prototype.playVideo = function() {
		        this._players[0].playVideo();
		    };
		
		    player.prototype.pauseVideo = function() {
		        this._players[0].pauseVideo();
		    };
		
		    player.prototype.stopVideo = function() {
		        this._players[0].stopVideo();
		    };
		
		    player.prototype.seekTo = function(seconds, allowSeekAhead) {
		        this._players[0].seekTo(seconds, allowSeekAhead);
		    };
		
		    player.prototype.nextVideo = function() {
		        this.playVideoAt(this._playlist_index + 1);
		    };
		
		    player.prototype.previousVideo = function() {
		        this.playVideoAt(this._playlist_index - 1);
		    };
		
		    player.prototype.playVideoAt = function(index) {
		        if (!this._playlist || !this._playlist.length || !this._playlist[index])
		            return false;
		
		        this._players[1].bufferVideoById(this._playlist[index].id, this._options.preloadSeconds).then(function() {
		            this._playlist_index = index - 1;
		            this._players[0].emulateEvent(0); //ended
		        }.bind(this));
		    };
		
		    player.prototype.loadVideoById = function(params) {
		        var data = {
		            id: params.id,
		            api: params.api
		        };
		
		        //TODO: cleanup
		        this._playlist = [];
		        this._playlist_index = 0;
		
		
		        if (this._players.length && (this._players[0].isPlaying() || this._players[0].isPaused())) {
		            this._playlist = [data];
		            this.stopVideo();
		
		            return false;
		        }
		
		        this._wrapper.innerHTML = '';
		
		        var playlist = [data];
		
		        if (this._loop)
		            playlist.push(data);
		
		        this.loadPlaylist(playlist);
		    };
		
		    player.prototype.mute = function() {
		        this._mute = 1;
		    };
		
		    player.prototype.unMute = function() {
		        this._mute = 0;
		    };
		
		    player.prototype.setLoop = function(is_loop) {
		        this._loop = !!is_loop;
		    };
		
		    player.prototype.setShuffle = function(is_shuffle) {
		        this._shuffle = !!is_shuffle;
		        if (this._shuffle)
		            this._playlist = _.shuffle(this._playlist);
		    };
		
		    player.prototype.getCurrentTime = function() {
		        try {
		            return this._players[0].getCurrentTime();
		        } catch (e) {
		            return 0;
		        }
		    };
		
		    player.prototype.getDuration = function() {
		        return this._players[0].getDuration();
		    };
		
		    player.prototype.getVideoLoadedFraction = function() {
		        return this._players[0].getVideoLoadedFraction();
		    };
		
		    player.prototype.getPlaylistIndex = function() {
		        return this._playlist_index;
		    };
		
		    player.prototype.getPlayerState = function() {
		        return this._players[0].getPlayerState();
		    };
		
		    player.prototype.addEventListener = function(event, listener) {
		        this._events.push({
		            event: event,
		            listener: listener
		        });
		
		        //this._players[0].addEventListener(event, listener);
		        _attachEvents.call(this);
		    };
		
		    player.prototype.removeEventListener = function(event, listener) {
		        for (var i = 0; i < this._events.length; i++)
		            if (this._events[i].event == event && ('' + this._events[i].listener) == ('' + listener))
		                break;
		
		        var remove = this._events.splice(i, 1);
		
		        this._players[0].removeEventListener(remove.event, remove.listener);
		    };
		
		    player.prototype.destroy = function(soft) {
		        this._playlist = [];
		        this._playlist_index = 0;
		        if (!soft) {
		            this._loop = false;
		            this._shuffle = false;
		            this._events = [];
		        }
		        this._players.forEach(function(player) {
		            player.destroy();
		        });
		        this._players = [];
		        this._wrapper.innerHTML = '';
		    };
		
		    player.prototype.onStartPlaying = function() {
		
		    };
		
		    player.prototype.setVolume = function(volume) {
		        volume = ~~volume;
		        volume = volume < 0 ? 0 : volume;
		        volume = volume > 100 ? 100 : volume;
		        try {
		            this._players[0].setVolume(~~volume);
		        } catch (e) {
		            console.debug('setVolume failed: player not found', e);
		        }
		    };
		
		
		    player.prototype.onPlayTimeChange = function() {
		
		    };
		
		    player.prototype.showTransition = function(effect_name, background_color, foreground_color) {
		        this._anim.show(effect_name, background_color, foreground_color);
		    };
		    player.prototype.hideTransition = function() {
		        this._anim.hide();
		    };
		
		    return {
		        debug: function(is_debug) {
		            debug = is_debug;
		        },
		        Player: player,
		        PlayerState: PlayerState
		    }
		})();
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:
		/*!
		 *
		 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
		 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
		 *
		 * With parts by Tyler Close
		 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
		 * at http://www.opensource.org/licenses/mit-license.html
		 * Forked at ref_send.js version: 2009-05-11
		 *
		 * With parts by Mark Miller
		 * Copyright (C) 2011 Google Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 * http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		
		(function (definition) {
		    "use strict";
		
		    // This file will function properly as a <script> tag, or a module
		    // using CommonJS and NodeJS or RequireJS module formats.  In
		    // Common/Node/RequireJS, the module exports the Q API and when
		    // executed as a simple <script>, it creates a Q global instead.
		
		    // Montage Require
		    if (typeof bootstrap === "function") {
		        bootstrap("promise", definition);
		
		    // CommonJS
		    } else if (true) {
		        module.exports = definition();
		
		    // RequireJS
		    } else if (typeof define === "function" && define.amd) {
		        define(definition);
		
		    // SES (Secure EcmaScript)
		    } else if (typeof ses !== "undefined") {
		        if (!ses.ok()) {
		            return;
		        } else {
		            ses.makeQ = definition;
		        }
		
		    // <script>
		    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
		        // Prefer window over self for add-on scripts. Use self for
		        // non-windowed contexts.
		        var global = typeof window !== "undefined" ? window : self;
		
		        // Get the `window` object, save the previous Q global
		        // and initialize Q as a global.
		        var previousQ = global.Q;
		        global.Q = definition();
		
		        // Add a noConflict function so Q can be removed from the
		        // global namespace.
		        global.Q.noConflict = function () {
		            global.Q = previousQ;
		            return this;
		        };
		
		    } else {
		        throw new Error("This environment was not anticipated by Q. Please file a bug.");
		    }
		
		})(function () {
		"use strict";
		
		var hasStacks = false;
		try {
		    throw new Error();
		} catch (e) {
		    hasStacks = !!e.stack;
		}
		
		// All code after this point will be filtered from stack traces reported
		// by Q.
		var qStartingLine = captureLine();
		var qFileName;
		
		// shims
		
		// used for fallback in "allResolved"
		var noop = function () {};
		
		// Use the fastest possible means to execute a task in a future turn
		// of the event loop.
		var nextTick =(function () {
		    // linked list of tasks (single, with head node)
		    var head = {task: void 0, next: null};
		    var tail = head;
		    var flushing = false;
		    var requestTick = void 0;
		    var isNodeJS = false;
		    // queue for late tasks, used by unhandled rejection tracking
		    var laterQueue = [];
		
		    function flush() {
		        /* jshint loopfunc: true */
		        var task, domain;
		
		        while (head.next) {
		            head = head.next;
		            task = head.task;
		            head.task = void 0;
		            domain = head.domain;
		
		            if (domain) {
		                head.domain = void 0;
		                domain.enter();
		            }
		            runSingle(task, domain);
		
		        }
		        while (laterQueue.length) {
		            task = laterQueue.pop();
		            runSingle(task);
		        }
		        flushing = false;
		    }
		    // runs a single function in the async queue
		    function runSingle(task, domain) {
		        try {
		            task();
		
		        } catch (e) {
		            if (isNodeJS) {
		                // In node, uncaught exceptions are considered fatal errors.
		                // Re-throw them synchronously to interrupt flushing!
		
		                // Ensure continuation if the uncaught exception is suppressed
		                // listening "uncaughtException" events (as domains does).
		                // Continue in next event to avoid tick recursion.
		                if (domain) {
		                    domain.exit();
		                }
		                setTimeout(flush, 0);
		                if (domain) {
		                    domain.enter();
		                }
		
		                throw e;
		
		            } else {
		                // In browsers, uncaught exceptions are not fatal.
		                // Re-throw them asynchronously to avoid slow-downs.
		                setTimeout(function () {
		                    throw e;
		                }, 0);
		            }
		        }
		
		        if (domain) {
		            domain.exit();
		        }
		    }
		
		    nextTick = function (task) {
		        tail = tail.next = {
		            task: task,
		            domain: isNodeJS && process.domain,
		            next: null
		        };
		
		        if (!flushing) {
		            flushing = true;
		            requestTick();
		        }
		    };
		
		    if (typeof process === "object" &&
		        process.toString() === "[object process]" && process.nextTick) {
		        // Ensure Q is in a real Node environment, with a `process.nextTick`.
		        // To see through fake Node environments:
		        // * Mocha test runner - exposes a `process` global without a `nextTick`
		        // * Browserify - exposes a `process.nexTick` function that uses
		        //   `setTimeout`. In this case `setImmediate` is preferred because
		        //    it is faster. Browserify's `process.toString()` yields
		        //   "[object Object]", while in a real Node environment
		        //   `process.nextTick()` yields "[object process]".
		        isNodeJS = true;
		
		        requestTick = function () {
		            process.nextTick(flush);
		        };
		
		    } else if (typeof setImmediate === "function") {
		        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
		        if (typeof window !== "undefined") {
		            requestTick = setImmediate.bind(window, flush);
		        } else {
		            requestTick = function () {
		                setImmediate(flush);
		            };
		        }
		
		    } else if (typeof MessageChannel !== "undefined") {
		        // modern browsers
		        // http://www.nonblocking.io/2011/06/windownexttick.html
		        var channel = new MessageChannel();
		        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
		        // working message ports the first time a page loads.
		        channel.port1.onmessage = function () {
		            requestTick = requestPortTick;
		            channel.port1.onmessage = flush;
		            flush();
		        };
		        var requestPortTick = function () {
		            // Opera requires us to provide a message payload, regardless of
		            // whether we use it.
		            channel.port2.postMessage(0);
		        };
		        requestTick = function () {
		            setTimeout(flush, 0);
		            requestPortTick();
		        };
		
		    } else {
		        // old browsers
		        requestTick = function () {
		            setTimeout(flush, 0);
		        };
		    }
		    // runs a task after all other tasks have been run
		    // this is useful for unhandled rejection tracking that needs to happen
		    // after all `then`d tasks have been run.
		    nextTick.runAfter = function (task) {
		        laterQueue.push(task);
		        if (!flushing) {
		            flushing = true;
		            requestTick();
		        }
		    };
		    return nextTick;
		})();
		
		// Attempt to make generics safe in the face of downstream
		// modifications.
		// There is no situation where this is necessary.
		// If you need a security guarantee, these primordials need to be
		// deeply frozen anyway, and if you don’t need a security guarantee,
		// this is just plain paranoid.
		// However, this **might** have the nice side-effect of reducing the size of
		// the minified code by reducing x.call() to merely x()
		// See Mark Miller’s explanation of what this does.
		// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
		var call = Function.call;
		function uncurryThis(f) {
		    return function () {
		        return call.apply(f, arguments);
		    };
		}
		// This is equivalent, but slower:
		// uncurryThis = Function_bind.bind(Function_bind.call);
		// http://jsperf.com/uncurrythis
		
		var array_slice = uncurryThis(Array.prototype.slice);
		
		var array_reduce = uncurryThis(
		    Array.prototype.reduce || function (callback, basis) {
		        var index = 0,
		            length = this.length;
		        // concerning the initial value, if one is not provided
		        if (arguments.length === 1) {
		            // seek to the first value in the array, accounting
		            // for the possibility that is is a sparse array
		            do {
		                if (index in this) {
		                    basis = this[index++];
		                    break;
		                }
		                if (++index >= length) {
		                    throw new TypeError();
		                }
		            } while (1);
		        }
		        // reduce
		        for (; index < length; index++) {
		            // account for the possibility that the array is sparse
		            if (index in this) {
		                basis = callback(basis, this[index], index);
		            }
		        }
		        return basis;
		    }
		);
		
		var array_indexOf = uncurryThis(
		    Array.prototype.indexOf || function (value) {
		        // not a very good shim, but good enough for our one use of it
		        for (var i = 0; i < this.length; i++) {
		            if (this[i] === value) {
		                return i;
		            }
		        }
		        return -1;
		    }
		);
		
		var array_map = uncurryThis(
		    Array.prototype.map || function (callback, thisp) {
		        var self = this;
		        var collect = [];
		        array_reduce(self, function (undefined, value, index) {
		            collect.push(callback.call(thisp, value, index, self));
		        }, void 0);
		        return collect;
		    }
		);
		
		var object_create = Object.create || function (prototype) {
		    function Type() { }
		    Type.prototype = prototype;
		    return new Type();
		};
		
		var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
		
		var object_keys = Object.keys || function (object) {
		    var keys = [];
		    for (var key in object) {
		        if (object_hasOwnProperty(object, key)) {
		            keys.push(key);
		        }
		    }
		    return keys;
		};
		
		var object_toString = uncurryThis(Object.prototype.toString);
		
		function isObject(value) {
		    return value === Object(value);
		}
		
		// generator related shims
		
		// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
		function isStopIteration(exception) {
		    return (
		        object_toString(exception) === "[object StopIteration]" ||
		        exception instanceof QReturnValue
		    );
		}
		
		// FIXME: Remove this helper and Q.return once ES6 generators are in
		// SpiderMonkey.
		var QReturnValue;
		if (typeof ReturnValue !== "undefined") {
		    QReturnValue = ReturnValue;
		} else {
		    QReturnValue = function (value) {
		        this.value = value;
		    };
		}
		
		// long stack traces
		
		var STACK_JUMP_SEPARATOR = "From previous event:";
		
		function makeStackTraceLong(error, promise) {
		    // If possible, transform the error stack trace by removing Node and Q
		    // cruft, then concatenating with the stack trace of `promise`. See #57.
		    if (hasStacks &&
		        promise.stack &&
		        typeof error === "object" &&
		        error !== null &&
		        error.stack &&
		        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
		    ) {
		        var stacks = [];
		        for (var p = promise; !!p; p = p.source) {
		            if (p.stack) {
		                stacks.unshift(p.stack);
		            }
		        }
		        stacks.unshift(error.stack);
		
		        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
		        error.stack = filterStackString(concatedStacks);
		    }
		}
		
		function filterStackString(stackString) {
		    var lines = stackString.split("\n");
		    var desiredLines = [];
		    for (var i = 0; i < lines.length; ++i) {
		        var line = lines[i];
		
		        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
		            desiredLines.push(line);
		        }
		    }
		    return desiredLines.join("\n");
		}
		
		function isNodeFrame(stackLine) {
		    return stackLine.indexOf("(module.js:") !== -1 ||
		           stackLine.indexOf("(node.js:") !== -1;
		}
		
		function getFileNameAndLineNumber(stackLine) {
		    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
		    // In IE10 function name can have spaces ("Anonymous function") O_o
		    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
		    if (attempt1) {
		        return [attempt1[1], Number(attempt1[2])];
		    }
		
		    // Anonymous functions: "at filename:lineNumber:columnNumber"
		    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
		    if (attempt2) {
		        return [attempt2[1], Number(attempt2[2])];
		    }
		
		    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
		    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
		    if (attempt3) {
		        return [attempt3[1], Number(attempt3[2])];
		    }
		}
		
		function isInternalFrame(stackLine) {
		    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
		
		    if (!fileNameAndLineNumber) {
		        return false;
		    }
		
		    var fileName = fileNameAndLineNumber[0];
		    var lineNumber = fileNameAndLineNumber[1];
		
		    return fileName === qFileName &&
		        lineNumber >= qStartingLine &&
		        lineNumber <= qEndingLine;
		}
		
		// discover own file name and line number range for filtering stack
		// traces
		function captureLine() {
		    if (!hasStacks) {
		        return;
		    }
		
		    try {
		        throw new Error();
		    } catch (e) {
		        var lines = e.stack.split("\n");
		        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
		        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
		        if (!fileNameAndLineNumber) {
		            return;
		        }
		
		        qFileName = fileNameAndLineNumber[0];
		        return fileNameAndLineNumber[1];
		    }
		}
		
		function deprecate(callback, name, alternative) {
		    return function () {
		        if (typeof console !== "undefined" &&
		            typeof console.warn === "function") {
		            console.warn(name + " is deprecated, use " + alternative +
		                         " instead.", new Error("").stack);
		        }
		        return callback.apply(callback, arguments);
		    };
		}
		
		// end of shims
		// beginning of real work
		
		/**
		 * Constructs a promise for an immediate reference, passes promises through, or
		 * coerces promises from different systems.
		 * @param value immediate reference or promise
		 */
		function Q(value) {
		    // If the object is already a Promise, return it directly.  This enables
		    // the resolve function to both be used to created references from objects,
		    // but to tolerably coerce non-promises to promises.
		    if (value instanceof Promise) {
		        return value;
		    }
		
		    // assimilate thenables
		    if (isPromiseAlike(value)) {
		        return coerce(value);
		    } else {
		        return fulfill(value);
		    }
		}
		Q.resolve = Q;
		
		/**
		 * Performs a task in a future turn of the event loop.
		 * @param {Function} task
		 */
		Q.nextTick = nextTick;
		
		/**
		 * Controls whether or not long stack traces will be on
		 */
		Q.longStackSupport = false;
		
		// enable long stacks if Q_DEBUG is set
		if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
		    Q.longStackSupport = true;
		}
		
		/**
		 * Constructs a {promise, resolve, reject} object.
		 *
		 * `resolve` is a callback to invoke with a more resolved value for the
		 * promise. To fulfill the promise, invoke `resolve` with any value that is
		 * not a thenable. To reject the promise, invoke `resolve` with a rejected
		 * thenable, or invoke `reject` with the reason directly. To resolve the
		 * promise to another thenable, thus putting it in the same state, invoke
		 * `resolve` with that other thenable.
		 */
		Q.defer = defer;
		function defer() {
		    // if "messages" is an "Array", that indicates that the promise has not yet
		    // been resolved.  If it is "undefined", it has been resolved.  Each
		    // element of the messages array is itself an array of complete arguments to
		    // forward to the resolved promise.  We coerce the resolution value to a
		    // promise using the `resolve` function because it handles both fully
		    // non-thenable values and other thenables gracefully.
		    var messages = [], progressListeners = [], resolvedPromise;
		
		    var deferred = object_create(defer.prototype);
		    var promise = object_create(Promise.prototype);
		
		    promise.promiseDispatch = function (resolve, op, operands) {
		        var args = array_slice(arguments);
		        if (messages) {
		            messages.push(args);
		            if (op === "when" && operands[1]) { // progress operand
		                progressListeners.push(operands[1]);
		            }
		        } else {
		            Q.nextTick(function () {
		                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
		            });
		        }
		    };
		
		    // XXX deprecated
		    promise.valueOf = function () {
		        if (messages) {
		            return promise;
		        }
		        var nearerValue = nearer(resolvedPromise);
		        if (isPromise(nearerValue)) {
		            resolvedPromise = nearerValue; // shorten chain
		        }
		        return nearerValue;
		    };
		
		    promise.inspect = function () {
		        if (!resolvedPromise) {
		            return { state: "pending" };
		        }
		        return resolvedPromise.inspect();
		    };
		
		    if (Q.longStackSupport && hasStacks) {
		        try {
		            throw new Error();
		        } catch (e) {
		            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
		            // accessor around; that causes memory leaks as per GH-111. Just
		            // reify the stack trace as a string ASAP.
		            //
		            // At the same time, cut off the first line; it's always just
		            // "[object Promise]\n", as per the `toString`.
		            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
		        }
		    }
		
		    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
		    // consolidating them into `become`, since otherwise we'd create new
		    // promises with the lines `become(whatever(value))`. See e.g. GH-252.
		
		    function become(newPromise) {
		        resolvedPromise = newPromise;
		        promise.source = newPromise;
		
		        array_reduce(messages, function (undefined, message) {
		            Q.nextTick(function () {
		                newPromise.promiseDispatch.apply(newPromise, message);
		            });
		        }, void 0);
		
		        messages = void 0;
		        progressListeners = void 0;
		    }
		
		    deferred.promise = promise;
		    deferred.resolve = function (value) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        become(Q(value));
		    };
		
		    deferred.fulfill = function (value) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        become(fulfill(value));
		    };
		    deferred.reject = function (reason) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        become(reject(reason));
		    };
		    deferred.notify = function (progress) {
		        if (resolvedPromise) {
		            return;
		        }
		
		        array_reduce(progressListeners, function (undefined, progressListener) {
		            Q.nextTick(function () {
		                progressListener(progress);
		            });
		        }, void 0);
		    };
		
		    return deferred;
		}
		
		/**
		 * Creates a Node-style callback that will resolve or reject the deferred
		 * promise.
		 * @returns a nodeback
		 */
		defer.prototype.makeNodeResolver = function () {
		    var self = this;
		    return function (error, value) {
		        if (error) {
		            self.reject(error);
		        } else if (arguments.length > 2) {
		            self.resolve(array_slice(arguments, 1));
		        } else {
		            self.resolve(value);
		        }
		    };
		};
		
		/**
		 * @param resolver {Function} a function that returns nothing and accepts
		 * the resolve, reject, and notify functions for a deferred.
		 * @returns a promise that may be resolved with the given resolve and reject
		 * functions, or rejected by a thrown exception in resolver
		 */
		Q.Promise = promise; // ES6
		Q.promise = promise;
		function promise(resolver) {
		    if (typeof resolver !== "function") {
		        throw new TypeError("resolver must be a function.");
		    }
		    var deferred = defer();
		    try {
		        resolver(deferred.resolve, deferred.reject, deferred.notify);
		    } catch (reason) {
		        deferred.reject(reason);
		    }
		    return deferred.promise;
		}
		
		promise.race = race; // ES6
		promise.all = all; // ES6
		promise.reject = reject; // ES6
		promise.resolve = Q; // ES6
		
		// XXX experimental.  This method is a way to denote that a local value is
		// serializable and should be immediately dispatched to a remote upon request,
		// instead of passing a reference.
		Q.passByCopy = function (object) {
		    //freeze(object);
		    //passByCopies.set(object, true);
		    return object;
		};
		
		Promise.prototype.passByCopy = function () {
		    //freeze(object);
		    //passByCopies.set(object, true);
		    return this;
		};
		
		/**
		 * If two promises eventually fulfill to the same value, promises that value,
		 * but otherwise rejects.
		 * @param x {Any*}
		 * @param y {Any*}
		 * @returns {Any*} a promise for x and y if they are the same, but a rejection
		 * otherwise.
		 *
		 */
		Q.join = function (x, y) {
		    return Q(x).join(y);
		};
		
		Promise.prototype.join = function (that) {
		    return Q([this, that]).spread(function (x, y) {
		        if (x === y) {
		            // TODO: "===" should be Object.is or equiv
		            return x;
		        } else {
		            throw new Error("Can't join: not the same: " + x + " " + y);
		        }
		    });
		};
		
		/**
		 * Returns a promise for the first of an array of promises to become settled.
		 * @param answers {Array[Any*]} promises to race
		 * @returns {Any*} the first promise to be settled
		 */
		Q.race = race;
		function race(answerPs) {
		    return promise(function (resolve, reject) {
		        // Switch to this once we can assume at least ES5
		        // answerPs.forEach(function (answerP) {
		        //     Q(answerP).then(resolve, reject);
		        // });
		        // Use this in the meantime
		        for (var i = 0, len = answerPs.length; i < len; i++) {
		            Q(answerPs[i]).then(resolve, reject);
		        }
		    });
		}
		
		Promise.prototype.race = function () {
		    return this.then(Q.race);
		};
		
		/**
		 * Constructs a Promise with a promise descriptor object and optional fallback
		 * function.  The descriptor contains methods like when(rejected), get(name),
		 * set(name, value), post(name, args), and delete(name), which all
		 * return either a value, a promise for a value, or a rejection.  The fallback
		 * accepts the operation name, a resolver, and any further arguments that would
		 * have been forwarded to the appropriate method above had a method been
		 * provided with the proper name.  The API makes no guarantees about the nature
		 * of the returned object, apart from that it is usable whereever promises are
		 * bought and sold.
		 */
		Q.makePromise = Promise;
		function Promise(descriptor, fallback, inspect) {
		    if (fallback === void 0) {
		        fallback = function (op) {
		            return reject(new Error(
		                "Promise does not support operation: " + op
		            ));
		        };
		    }
		    if (inspect === void 0) {
		        inspect = function () {
		            return {state: "unknown"};
		        };
		    }
		
		    var promise = object_create(Promise.prototype);
		
		    promise.promiseDispatch = function (resolve, op, args) {
		        var result;
		        try {
		            if (descriptor[op]) {
		                result = descriptor[op].apply(promise, args);
		            } else {
		                result = fallback.call(promise, op, args);
		            }
		        } catch (exception) {
		            result = reject(exception);
		        }
		        if (resolve) {
		            resolve(result);
		        }
		    };
		
		    promise.inspect = inspect;
		
		    // XXX deprecated `valueOf` and `exception` support
		    if (inspect) {
		        var inspected = inspect();
		        if (inspected.state === "rejected") {
		            promise.exception = inspected.reason;
		        }
		
		        promise.valueOf = function () {
		            var inspected = inspect();
		            if (inspected.state === "pending" ||
		                inspected.state === "rejected") {
		                return promise;
		            }
		            return inspected.value;
		        };
		    }
		
		    return promise;
		}
		
		Promise.prototype.toString = function () {
		    return "[object Promise]";
		};
		
		Promise.prototype.then = function (fulfilled, rejected, progressed) {
		    var self = this;
		    var deferred = defer();
		    var done = false;   // ensure the untrusted promise makes at most a
		                        // single call to one of the callbacks
		
		    function _fulfilled(value) {
		        try {
		            return typeof fulfilled === "function" ? fulfilled(value) : value;
		        } catch (exception) {
		            return reject(exception);
		        }
		    }
		
		    function _rejected(exception) {
		        if (typeof rejected === "function") {
		            makeStackTraceLong(exception, self);
		            try {
		                return rejected(exception);
		            } catch (newException) {
		                return reject(newException);
		            }
		        }
		        return reject(exception);
		    }
		
		    function _progressed(value) {
		        return typeof progressed === "function" ? progressed(value) : value;
		    }
		
		    Q.nextTick(function () {
		        self.promiseDispatch(function (value) {
		            if (done) {
		                return;
		            }
		            done = true;
		
		            deferred.resolve(_fulfilled(value));
		        }, "when", [function (exception) {
		            if (done) {
		                return;
		            }
		            done = true;
		
		            deferred.resolve(_rejected(exception));
		        }]);
		    });
		
		    // Progress propagator need to be attached in the current tick.
		    self.promiseDispatch(void 0, "when", [void 0, function (value) {
		        var newValue;
		        var threw = false;
		        try {
		            newValue = _progressed(value);
		        } catch (e) {
		            threw = true;
		            if (Q.onerror) {
		                Q.onerror(e);
		            } else {
		                throw e;
		            }
		        }
		
		        if (!threw) {
		            deferred.notify(newValue);
		        }
		    }]);
		
		    return deferred.promise;
		};
		
		Q.tap = function (promise, callback) {
		    return Q(promise).tap(callback);
		};
		
		/**
		 * Works almost like "finally", but not called for rejections.
		 * Original resolution value is passed through callback unaffected.
		 * Callback may return a promise that will be awaited for.
		 * @param {Function} callback
		 * @returns {Q.Promise}
		 * @example
		 * doSomething()
		 *   .then(...)
		 *   .tap(console.log)
		 *   .then(...);
		 */
		Promise.prototype.tap = function (callback) {
		    callback = Q(callback);
		
		    return this.then(function (value) {
		        return callback.fcall(value).thenResolve(value);
		    });
		};
		
		/**
		 * Registers an observer on a promise.
		 *
		 * Guarantees:
		 *
		 * 1. that fulfilled and rejected will be called only once.
		 * 2. that either the fulfilled callback or the rejected callback will be
		 *    called, but not both.
		 * 3. that fulfilled and rejected will not be called in this turn.
		 *
		 * @param value      promise or immediate reference to observe
		 * @param fulfilled  function to be called with the fulfilled value
		 * @param rejected   function to be called with the rejection exception
		 * @param progressed function to be called on any progress notifications
		 * @return promise for the return value from the invoked callback
		 */
		Q.when = when;
		function when(value, fulfilled, rejected, progressed) {
		    return Q(value).then(fulfilled, rejected, progressed);
		}
		
		Promise.prototype.thenResolve = function (value) {
		    return this.then(function () { return value; });
		};
		
		Q.thenResolve = function (promise, value) {
		    return Q(promise).thenResolve(value);
		};
		
		Promise.prototype.thenReject = function (reason) {
		    return this.then(function () { throw reason; });
		};
		
		Q.thenReject = function (promise, reason) {
		    return Q(promise).thenReject(reason);
		};
		
		/**
		 * If an object is not a promise, it is as "near" as possible.
		 * If a promise is rejected, it is as "near" as possible too.
		 * If it’s a fulfilled promise, the fulfillment value is nearer.
		 * If it’s a deferred promise and the deferred has been resolved, the
		 * resolution is "nearer".
		 * @param object
		 * @returns most resolved (nearest) form of the object
		 */
		
		// XXX should we re-do this?
		Q.nearer = nearer;
		function nearer(value) {
		    if (isPromise(value)) {
		        var inspected = value.inspect();
		        if (inspected.state === "fulfilled") {
		            return inspected.value;
		        }
		    }
		    return value;
		}
		
		/**
		 * @returns whether the given object is a promise.
		 * Otherwise it is a fulfilled value.
		 */
		Q.isPromise = isPromise;
		function isPromise(object) {
		    return object instanceof Promise;
		}
		
		Q.isPromiseAlike = isPromiseAlike;
		function isPromiseAlike(object) {
		    return isObject(object) && typeof object.then === "function";
		}
		
		/**
		 * @returns whether the given object is a pending promise, meaning not
		 * fulfilled or rejected.
		 */
		Q.isPending = isPending;
		function isPending(object) {
		    return isPromise(object) && object.inspect().state === "pending";
		}
		
		Promise.prototype.isPending = function () {
		    return this.inspect().state === "pending";
		};
		
		/**
		 * @returns whether the given object is a value or fulfilled
		 * promise.
		 */
		Q.isFulfilled = isFulfilled;
		function isFulfilled(object) {
		    return !isPromise(object) || object.inspect().state === "fulfilled";
		}
		
		Promise.prototype.isFulfilled = function () {
		    return this.inspect().state === "fulfilled";
		};
		
		/**
		 * @returns whether the given object is a rejected promise.
		 */
		Q.isRejected = isRejected;
		function isRejected(object) {
		    return isPromise(object) && object.inspect().state === "rejected";
		}
		
		Promise.prototype.isRejected = function () {
		    return this.inspect().state === "rejected";
		};
		
		//// BEGIN UNHANDLED REJECTION TRACKING
		
		// This promise library consumes exceptions thrown in handlers so they can be
		// handled by a subsequent promise.  The exceptions get added to this array when
		// they are created, and removed when they are handled.  Note that in ES6 or
		// shimmed environments, this would naturally be a `Set`.
		var unhandledReasons = [];
		var unhandledRejections = [];
		var reportedUnhandledRejections = [];
		var trackUnhandledRejections = true;
		
		function resetUnhandledRejections() {
		    unhandledReasons.length = 0;
		    unhandledRejections.length = 0;
		
		    if (!trackUnhandledRejections) {
		        trackUnhandledRejections = true;
		    }
		}
		
		function trackRejection(promise, reason) {
		    if (!trackUnhandledRejections) {
		        return;
		    }
		    if (typeof process === "object" && typeof process.emit === "function") {
		        Q.nextTick.runAfter(function () {
		            if (array_indexOf(unhandledRejections, promise) !== -1) {
		                process.emit("unhandledRejection", reason, promise);
		                reportedUnhandledRejections.push(promise);
		            }
		        });
		    }
		
		    unhandledRejections.push(promise);
		    if (reason && typeof reason.stack !== "undefined") {
		        unhandledReasons.push(reason.stack);
		    } else {
		        unhandledReasons.push("(no stack) " + reason);
		    }
		}
		
		function untrackRejection(promise) {
		    if (!trackUnhandledRejections) {
		        return;
		    }
		
		    var at = array_indexOf(unhandledRejections, promise);
		    if (at !== -1) {
		        if (typeof process === "object" && typeof process.emit === "function") {
		            Q.nextTick.runAfter(function () {
		                var atReport = array_indexOf(reportedUnhandledRejections, promise);
		                if (atReport !== -1) {
		                    process.emit("rejectionHandled", unhandledReasons[at], promise);
		                    reportedUnhandledRejections.splice(atReport, 1);
		                }
		            });
		        }
		        unhandledRejections.splice(at, 1);
		        unhandledReasons.splice(at, 1);
		    }
		}
		
		Q.resetUnhandledRejections = resetUnhandledRejections;
		
		Q.getUnhandledReasons = function () {
		    // Make a copy so that consumers can't interfere with our internal state.
		    return unhandledReasons.slice();
		};
		
		Q.stopUnhandledRejectionTracking = function () {
		    resetUnhandledRejections();
		    trackUnhandledRejections = false;
		};
		
		resetUnhandledRejections();
		
		//// END UNHANDLED REJECTION TRACKING
		
		/**
		 * Constructs a rejected promise.
		 * @param reason value describing the failure
		 */
		Q.reject = reject;
		function reject(reason) {
		    var rejection = Promise({
		        "when": function (rejected) {
		            // note that the error has been handled
		            if (rejected) {
		                untrackRejection(this);
		            }
		            return rejected ? rejected(reason) : this;
		        }
		    }, function fallback() {
		        return this;
		    }, function inspect() {
		        return { state: "rejected", reason: reason };
		    });
		
		    // Note that the reason has not been handled.
		    trackRejection(rejection, reason);
		
		    return rejection;
		}
		
		/**
		 * Constructs a fulfilled promise for an immediate reference.
		 * @param value immediate reference
		 */
		Q.fulfill = fulfill;
		function fulfill(value) {
		    return Promise({
		        "when": function () {
		            return value;
		        },
		        "get": function (name) {
		            return value[name];
		        },
		        "set": function (name, rhs) {
		            value[name] = rhs;
		        },
		        "delete": function (name) {
		            delete value[name];
		        },
		        "post": function (name, args) {
		            // Mark Miller proposes that post with no name should apply a
		            // promised function.
		            if (name === null || name === void 0) {
		                return value.apply(void 0, args);
		            } else {
		                return value[name].apply(value, args);
		            }
		        },
		        "apply": function (thisp, args) {
		            return value.apply(thisp, args);
		        },
		        "keys": function () {
		            return object_keys(value);
		        }
		    }, void 0, function inspect() {
		        return { state: "fulfilled", value: value };
		    });
		}
		
		/**
		 * Converts thenables to Q promises.
		 * @param promise thenable promise
		 * @returns a Q promise
		 */
		function coerce(promise) {
		    var deferred = defer();
		    Q.nextTick(function () {
		        try {
		            promise.then(deferred.resolve, deferred.reject, deferred.notify);
		        } catch (exception) {
		            deferred.reject(exception);
		        }
		    });
		    return deferred.promise;
		}
		
		/**
		 * Annotates an object such that it will never be
		 * transferred away from this process over any promise
		 * communication channel.
		 * @param object
		 * @returns promise a wrapping of that object that
		 * additionally responds to the "isDef" message
		 * without a rejection.
		 */
		Q.master = master;
		function master(object) {
		    return Promise({
		        "isDef": function () {}
		    }, function fallback(op, args) {
		        return dispatch(object, op, args);
		    }, function () {
		        return Q(object).inspect();
		    });
		}
		
		/**
		 * Spreads the values of a promised array of arguments into the
		 * fulfillment callback.
		 * @param fulfilled callback that receives variadic arguments from the
		 * promised array
		 * @param rejected callback that receives the exception if the promise
		 * is rejected.
		 * @returns a promise for the return value or thrown exception of
		 * either callback.
		 */
		Q.spread = spread;
		function spread(value, fulfilled, rejected) {
		    return Q(value).spread(fulfilled, rejected);
		}
		
		Promise.prototype.spread = function (fulfilled, rejected) {
		    return this.all().then(function (array) {
		        return fulfilled.apply(void 0, array);
		    }, rejected);
		};
		
		/**
		 * The async function is a decorator for generator functions, turning
		 * them into asynchronous generators.  Although generators are only part
		 * of the newest ECMAScript 6 drafts, this code does not cause syntax
		 * errors in older engines.  This code should continue to work and will
		 * in fact improve over time as the language improves.
		 *
		 * ES6 generators are currently part of V8 version 3.19 with the
		 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
		 * for longer, but under an older Python-inspired form.  This function
		 * works on both kinds of generators.
		 *
		 * Decorates a generator function such that:
		 *  - it may yield promises
		 *  - execution will continue when that promise is fulfilled
		 *  - the value of the yield expression will be the fulfilled value
		 *  - it returns a promise for the return value (when the generator
		 *    stops iterating)
		 *  - the decorated function returns a promise for the return value
		 *    of the generator or the first rejected promise among those
		 *    yielded.
		 *  - if an error is thrown in the generator, it propagates through
		 *    every following yield until it is caught, or until it escapes
		 *    the generator function altogether, and is translated into a
		 *    rejection for the promise returned by the decorated generator.
		 */
		Q.async = async;
		function async(makeGenerator) {
		    return function () {
		        // when verb is "send", arg is a value
		        // when verb is "throw", arg is an exception
		        function continuer(verb, arg) {
		            var result;
		
		            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
		            // engine that has a deployed base of browsers that support generators.
		            // However, SM's generators use the Python-inspired semantics of
		            // outdated ES6 drafts.  We would like to support ES6, but we'd also
		            // like to make it possible to use generators in deployed browsers, so
		            // we also support Python-style generators.  At some point we can remove
		            // this block.
		
		            if (typeof StopIteration === "undefined") {
		                // ES6 Generators
		                try {
		                    result = generator[verb](arg);
		                } catch (exception) {
		                    return reject(exception);
		                }
		                if (result.done) {
		                    return Q(result.value);
		                } else {
		                    return when(result.value, callback, errback);
		                }
		            } else {
		                // SpiderMonkey Generators
		                // FIXME: Remove this case when SM does ES6 generators.
		                try {
		                    result = generator[verb](arg);
		                } catch (exception) {
		                    if (isStopIteration(exception)) {
		                        return Q(exception.value);
		                    } else {
		                        return reject(exception);
		                    }
		                }
		                return when(result, callback, errback);
		            }
		        }
		        var generator = makeGenerator.apply(this, arguments);
		        var callback = continuer.bind(continuer, "next");
		        var errback = continuer.bind(continuer, "throw");
		        return callback();
		    };
		}
		
		/**
		 * The spawn function is a small wrapper around async that immediately
		 * calls the generator and also ends the promise chain, so that any
		 * unhandled errors are thrown instead of forwarded to the error
		 * handler. This is useful because it's extremely common to run
		 * generators at the top-level to work with libraries.
		 */
		Q.spawn = spawn;
		function spawn(makeGenerator) {
		    Q.done(Q.async(makeGenerator)());
		}
		
		// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
		/**
		 * Throws a ReturnValue exception to stop an asynchronous generator.
		 *
		 * This interface is a stop-gap measure to support generator return
		 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
		 * generators like Chromium 29, just use "return" in your generator
		 * functions.
		 *
		 * @param value the return value for the surrounding generator
		 * @throws ReturnValue exception with the value.
		 * @example
		 * // ES6 style
		 * Q.async(function* () {
		 *      var foo = yield getFooPromise();
		 *      var bar = yield getBarPromise();
		 *      return foo + bar;
		 * })
		 * // Older SpiderMonkey style
		 * Q.async(function () {
		 *      var foo = yield getFooPromise();
		 *      var bar = yield getBarPromise();
		 *      Q.return(foo + bar);
		 * })
		 */
		Q["return"] = _return;
		function _return(value) {
		    throw new QReturnValue(value);
		}
		
		/**
		 * The promised function decorator ensures that any promise arguments
		 * are settled and passed as values (`this` is also settled and passed
		 * as a value).  It will also ensure that the result of a function is
		 * always a promise.
		 *
		 * @example
		 * var add = Q.promised(function (a, b) {
		 *     return a + b;
		 * });
		 * add(Q(a), Q(B));
		 *
		 * @param {function} callback The function to decorate
		 * @returns {function} a function that has been decorated.
		 */
		Q.promised = promised;
		function promised(callback) {
		    return function () {
		        return spread([this, all(arguments)], function (self, args) {
		            return callback.apply(self, args);
		        });
		    };
		}
		
		/**
		 * sends a message to a value in a future turn
		 * @param object* the recipient
		 * @param op the name of the message operation, e.g., "when",
		 * @param args further arguments to be forwarded to the operation
		 * @returns result {Promise} a promise for the result of the operation
		 */
		Q.dispatch = dispatch;
		function dispatch(object, op, args) {
		    return Q(object).dispatch(op, args);
		}
		
		Promise.prototype.dispatch = function (op, args) {
		    var self = this;
		    var deferred = defer();
		    Q.nextTick(function () {
		        self.promiseDispatch(deferred.resolve, op, args);
		    });
		    return deferred.promise;
		};
		
		/**
		 * Gets the value of a property in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of property to get
		 * @return promise for the property value
		 */
		Q.get = function (object, key) {
		    return Q(object).dispatch("get", [key]);
		};
		
		Promise.prototype.get = function (key) {
		    return this.dispatch("get", [key]);
		};
		
		/**
		 * Sets the value of a property in a future turn.
		 * @param object    promise or immediate reference for object object
		 * @param name      name of property to set
		 * @param value     new value of property
		 * @return promise for the return value
		 */
		Q.set = function (object, key, value) {
		    return Q(object).dispatch("set", [key, value]);
		};
		
		Promise.prototype.set = function (key, value) {
		    return this.dispatch("set", [key, value]);
		};
		
		/**
		 * Deletes a property in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of property to delete
		 * @return promise for the return value
		 */
		Q.del = // XXX legacy
		Q["delete"] = function (object, key) {
		    return Q(object).dispatch("delete", [key]);
		};
		
		Promise.prototype.del = // XXX legacy
		Promise.prototype["delete"] = function (key) {
		    return this.dispatch("delete", [key]);
		};
		
		/**
		 * Invokes a method in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of method to invoke
		 * @param value     a value to post, typically an array of
		 *                  invocation arguments for promises that
		 *                  are ultimately backed with `resolve` values,
		 *                  as opposed to those backed with URLs
		 *                  wherein the posted value can be any
		 *                  JSON serializable object.
		 * @return promise for the return value
		 */
		// bound locally because it is used by other methods
		Q.mapply = // XXX As proposed by "Redsandro"
		Q.post = function (object, name, args) {
		    return Q(object).dispatch("post", [name, args]);
		};
		
		Promise.prototype.mapply = // XXX As proposed by "Redsandro"
		Promise.prototype.post = function (name, args) {
		    return this.dispatch("post", [name, args]);
		};
		
		/**
		 * Invokes a method in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @param name      name of method to invoke
		 * @param ...args   array of invocation arguments
		 * @return promise for the return value
		 */
		Q.send = // XXX Mark Miller's proposed parlance
		Q.mcall = // XXX As proposed by "Redsandro"
		Q.invoke = function (object, name /*...args*/) {
		    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
		};
		
		Promise.prototype.send = // XXX Mark Miller's proposed parlance
		Promise.prototype.mcall = // XXX As proposed by "Redsandro"
		Promise.prototype.invoke = function (name /*...args*/) {
		    return this.dispatch("post", [name, array_slice(arguments, 1)]);
		};
		
		/**
		 * Applies the promised function in a future turn.
		 * @param object    promise or immediate reference for target function
		 * @param args      array of application arguments
		 */
		Q.fapply = function (object, args) {
		    return Q(object).dispatch("apply", [void 0, args]);
		};
		
		Promise.prototype.fapply = function (args) {
		    return this.dispatch("apply", [void 0, args]);
		};
		
		/**
		 * Calls the promised function in a future turn.
		 * @param object    promise or immediate reference for target function
		 * @param ...args   array of application arguments
		 */
		Q["try"] =
		Q.fcall = function (object /* ...args*/) {
		    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
		};
		
		Promise.prototype.fcall = function (/*...args*/) {
		    return this.dispatch("apply", [void 0, array_slice(arguments)]);
		};
		
		/**
		 * Binds the promised function, transforming return values into a fulfilled
		 * promise and thrown errors into a rejected one.
		 * @param object    promise or immediate reference for target function
		 * @param ...args   array of application arguments
		 */
		Q.fbind = function (object /*...args*/) {
		    var promise = Q(object);
		    var args = array_slice(arguments, 1);
		    return function fbound() {
		        return promise.dispatch("apply", [
		            this,
		            args.concat(array_slice(arguments))
		        ]);
		    };
		};
		Promise.prototype.fbind = function (/*...args*/) {
		    var promise = this;
		    var args = array_slice(arguments);
		    return function fbound() {
		        return promise.dispatch("apply", [
		            this,
		            args.concat(array_slice(arguments))
		        ]);
		    };
		};
		
		/**
		 * Requests the names of the owned properties of a promised
		 * object in a future turn.
		 * @param object    promise or immediate reference for target object
		 * @return promise for the keys of the eventually settled object
		 */
		Q.keys = function (object) {
		    return Q(object).dispatch("keys", []);
		};
		
		Promise.prototype.keys = function () {
		    return this.dispatch("keys", []);
		};
		
		/**
		 * Turns an array of promises into a promise for an array.  If any of
		 * the promises gets rejected, the whole array is rejected immediately.
		 * @param {Array*} an array (or promise for an array) of values (or
		 * promises for values)
		 * @returns a promise for an array of the corresponding values
		 */
		// By Mark Miller
		// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
		Q.all = all;
		function all(promises) {
		    return when(promises, function (promises) {
		        var pendingCount = 0;
		        var deferred = defer();
		        array_reduce(promises, function (undefined, promise, index) {
		            var snapshot;
		            if (
		                isPromise(promise) &&
		                (snapshot = promise.inspect()).state === "fulfilled"
		            ) {
		                promises[index] = snapshot.value;
		            } else {
		                ++pendingCount;
		                when(
		                    promise,
		                    function (value) {
		                        promises[index] = value;
		                        if (--pendingCount === 0) {
		                            deferred.resolve(promises);
		                        }
		                    },
		                    deferred.reject,
		                    function (progress) {
		                        deferred.notify({ index: index, value: progress });
		                    }
		                );
		            }
		        }, void 0);
		        if (pendingCount === 0) {
		            deferred.resolve(promises);
		        }
		        return deferred.promise;
		    });
		}
		
		Promise.prototype.all = function () {
		    return all(this);
		};
		
		/**
		 * Returns the first resolved promise of an array. Prior rejected promises are
		 * ignored.  Rejects only if all promises are rejected.
		 * @param {Array*} an array containing values or promises for values
		 * @returns a promise fulfilled with the value of the first resolved promise,
		 * or a rejected promise if all promises are rejected.
		 */
		Q.any = any;
		
		function any(promises) {
		    if (promises.length === 0) {
		        return Q.resolve();
		    }
		
		    var deferred = Q.defer();
		    var pendingCount = 0;
		    array_reduce(promises, function (prev, current, index) {
		        var promise = promises[index];
		
		        pendingCount++;
		
		        when(promise, onFulfilled, onRejected, onProgress);
		        function onFulfilled(result) {
		            deferred.resolve(result);
		        }
		        function onRejected() {
		            pendingCount--;
		            if (pendingCount === 0) {
		                deferred.reject(new Error(
		                    "Can't get fulfillment value from any promise, all " +
		                    "promises were rejected."
		                ));
		            }
		        }
		        function onProgress(progress) {
		            deferred.notify({
		                index: index,
		                value: progress
		            });
		        }
		    }, undefined);
		
		    return deferred.promise;
		}
		
		Promise.prototype.any = function () {
		    return any(this);
		};
		
		/**
		 * Waits for all promises to be settled, either fulfilled or
		 * rejected.  This is distinct from `all` since that would stop
		 * waiting at the first rejection.  The promise returned by
		 * `allResolved` will never be rejected.
		 * @param promises a promise for an array (or an array) of promises
		 * (or values)
		 * @return a promise for an array of promises
		 */
		Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
		function allResolved(promises) {
		    return when(promises, function (promises) {
		        promises = array_map(promises, Q);
		        return when(all(array_map(promises, function (promise) {
		            return when(promise, noop, noop);
		        })), function () {
		            return promises;
		        });
		    });
		}
		
		Promise.prototype.allResolved = function () {
		    return allResolved(this);
		};
		
		/**
		 * @see Promise#allSettled
		 */
		Q.allSettled = allSettled;
		function allSettled(promises) {
		    return Q(promises).allSettled();
		}
		
		/**
		 * Turns an array of promises into a promise for an array of their states (as
		 * returned by `inspect`) when they have all settled.
		 * @param {Array[Any*]} values an array (or promise for an array) of values (or
		 * promises for values)
		 * @returns {Array[State]} an array of states for the respective values.
		 */
		Promise.prototype.allSettled = function () {
		    return this.then(function (promises) {
		        return all(array_map(promises, function (promise) {
		            promise = Q(promise);
		            function regardless() {
		                return promise.inspect();
		            }
		            return promise.then(regardless, regardless);
		        }));
		    });
		};
		
		/**
		 * Captures the failure of a promise, giving an oportunity to recover
		 * with a callback.  If the given promise is fulfilled, the returned
		 * promise is fulfilled.
		 * @param {Any*} promise for something
		 * @param {Function} callback to fulfill the returned promise if the
		 * given promise is rejected
		 * @returns a promise for the return value of the callback
		 */
		Q.fail = // XXX legacy
		Q["catch"] = function (object, rejected) {
		    return Q(object).then(void 0, rejected);
		};
		
		Promise.prototype.fail = // XXX legacy
		Promise.prototype["catch"] = function (rejected) {
		    return this.then(void 0, rejected);
		};
		
		/**
		 * Attaches a listener that can respond to progress notifications from a
		 * promise's originating deferred. This listener receives the exact arguments
		 * passed to ``deferred.notify``.
		 * @param {Any*} promise for something
		 * @param {Function} callback to receive any progress notifications
		 * @returns the given promise, unchanged
		 */
		Q.progress = progress;
		function progress(object, progressed) {
		    return Q(object).then(void 0, void 0, progressed);
		}
		
		Promise.prototype.progress = function (progressed) {
		    return this.then(void 0, void 0, progressed);
		};
		
		/**
		 * Provides an opportunity to observe the settling of a promise,
		 * regardless of whether the promise is fulfilled or rejected.  Forwards
		 * the resolution to the returned promise when the callback is done.
		 * The callback can return a promise to defer completion.
		 * @param {Any*} promise
		 * @param {Function} callback to observe the resolution of the given
		 * promise, takes no arguments.
		 * @returns a promise for the resolution of the given promise when
		 * ``fin`` is done.
		 */
		Q.fin = // XXX legacy
		Q["finally"] = function (object, callback) {
		    return Q(object)["finally"](callback);
		};
		
		Promise.prototype.fin = // XXX legacy
		Promise.prototype["finally"] = function (callback) {
		    callback = Q(callback);
		    return this.then(function (value) {
		        return callback.fcall().then(function () {
		            return value;
		        });
		    }, function (reason) {
		        // TODO attempt to recycle the rejection with "this".
		        return callback.fcall().then(function () {
		            throw reason;
		        });
		    });
		};
		
		/**
		 * Terminates a chain of promises, forcing rejections to be
		 * thrown as exceptions.
		 * @param {Any*} promise at the end of a chain of promises
		 * @returns nothing
		 */
		Q.done = function (object, fulfilled, rejected, progress) {
		    return Q(object).done(fulfilled, rejected, progress);
		};
		
		Promise.prototype.done = function (fulfilled, rejected, progress) {
		    var onUnhandledError = function (error) {
		        // forward to a future turn so that ``when``
		        // does not catch it and turn it into a rejection.
		        Q.nextTick(function () {
		            makeStackTraceLong(error, promise);
		            if (Q.onerror) {
		                Q.onerror(error);
		            } else {
		                throw error;
		            }
		        });
		    };
		
		    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
		    var promise = fulfilled || rejected || progress ?
		        this.then(fulfilled, rejected, progress) :
		        this;
		
		    if (typeof process === "object" && process && process.domain) {
		        onUnhandledError = process.domain.bind(onUnhandledError);
		    }
		
		    promise.then(void 0, onUnhandledError);
		};
		
		/**
		 * Causes a promise to be rejected if it does not get fulfilled before
		 * some milliseconds time out.
		 * @param {Any*} promise
		 * @param {Number} milliseconds timeout
		 * @param {Any*} custom error message or Error object (optional)
		 * @returns a promise for the resolution of the given promise if it is
		 * fulfilled before the timeout, otherwise rejected.
		 */
		Q.timeout = function (object, ms, error) {
		    return Q(object).timeout(ms, error);
		};
		
		Promise.prototype.timeout = function (ms, error) {
		    var deferred = defer();
		    var timeoutId = setTimeout(function () {
		        if (!error || "string" === typeof error) {
		            error = new Error(error || "Timed out after " + ms + " ms");
		            error.code = "ETIMEDOUT";
		        }
		        deferred.reject(error);
		    }, ms);
		
		    this.then(function (value) {
		        clearTimeout(timeoutId);
		        deferred.resolve(value);
		    }, function (exception) {
		        clearTimeout(timeoutId);
		        deferred.reject(exception);
		    }, deferred.notify);
		
		    return deferred.promise;
		};
		
		/**
		 * Returns a promise for the given value (or promised value), some
		 * milliseconds after it resolved. Passes rejections immediately.
		 * @param {Any*} promise
		 * @param {Number} milliseconds
		 * @returns a promise for the resolution of the given promise after milliseconds
		 * time has elapsed since the resolution of the given promise.
		 * If the given promise rejects, that is passed immediately.
		 */
		Q.delay = function (object, timeout) {
		    if (timeout === void 0) {
		        timeout = object;
		        object = void 0;
		    }
		    return Q(object).delay(timeout);
		};
		
		Promise.prototype.delay = function (timeout) {
		    return this.then(function (value) {
		        var deferred = defer();
		        setTimeout(function () {
		            deferred.resolve(value);
		        }, timeout);
		        return deferred.promise;
		    });
		};
		
		/**
		 * Passes a continuation to a Node function, which is called with the given
		 * arguments provided as an array, and returns a promise.
		 *
		 *      Q.nfapply(FS.readFile, [__filename])
		 *      .then(function (content) {
		 *      })
		 *
		 */
		Q.nfapply = function (callback, args) {
		    return Q(callback).nfapply(args);
		};
		
		Promise.prototype.nfapply = function (args) {
		    var deferred = defer();
		    var nodeArgs = array_slice(args);
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.fapply(nodeArgs).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * Passes a continuation to a Node function, which is called with the given
		 * arguments provided individually, and returns a promise.
		 * @example
		 * Q.nfcall(FS.readFile, __filename)
		 * .then(function (content) {
		 * })
		 *
		 */
		Q.nfcall = function (callback /*...args*/) {
		    var args = array_slice(arguments, 1);
		    return Q(callback).nfapply(args);
		};
		
		Promise.prototype.nfcall = function (/*...args*/) {
		    var nodeArgs = array_slice(arguments);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.fapply(nodeArgs).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * Wraps a NodeJS continuation passing function and returns an equivalent
		 * version that returns a promise.
		 * @example
		 * Q.nfbind(FS.readFile, __filename)("utf-8")
		 * .then(console.log)
		 * .done()
		 */
		Q.nfbind =
		Q.denodeify = function (callback /*...args*/) {
		    var baseArgs = array_slice(arguments, 1);
		    return function () {
		        var nodeArgs = baseArgs.concat(array_slice(arguments));
		        var deferred = defer();
		        nodeArgs.push(deferred.makeNodeResolver());
		        Q(callback).fapply(nodeArgs).fail(deferred.reject);
		        return deferred.promise;
		    };
		};
		
		Promise.prototype.nfbind =
		Promise.prototype.denodeify = function (/*...args*/) {
		    var args = array_slice(arguments);
		    args.unshift(this);
		    return Q.denodeify.apply(void 0, args);
		};
		
		Q.nbind = function (callback, thisp /*...args*/) {
		    var baseArgs = array_slice(arguments, 2);
		    return function () {
		        var nodeArgs = baseArgs.concat(array_slice(arguments));
		        var deferred = defer();
		        nodeArgs.push(deferred.makeNodeResolver());
		        function bound() {
		            return callback.apply(thisp, arguments);
		        }
		        Q(bound).fapply(nodeArgs).fail(deferred.reject);
		        return deferred.promise;
		    };
		};
		
		Promise.prototype.nbind = function (/*thisp, ...args*/) {
		    var args = array_slice(arguments, 0);
		    args.unshift(this);
		    return Q.nbind.apply(void 0, args);
		};
		
		/**
		 * Calls a method of a Node-style object that accepts a Node-style
		 * callback with a given array of arguments, plus a provided callback.
		 * @param object an object that has the named method
		 * @param {String} name name of the method of object
		 * @param {Array} args arguments to pass to the method; the callback
		 * will be provided by Q and appended to these arguments.
		 * @returns a promise for the value or error
		 */
		Q.nmapply = // XXX As proposed by "Redsandro"
		Q.npost = function (object, name, args) {
		    return Q(object).npost(name, args);
		};
		
		Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
		Promise.prototype.npost = function (name, args) {
		    var nodeArgs = array_slice(args || []);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * Calls a method of a Node-style object that accepts a Node-style
		 * callback, forwarding the given variadic arguments, plus a provided
		 * callback argument.
		 * @param object an object that has the named method
		 * @param {String} name name of the method of object
		 * @param ...args arguments to pass to the method; the callback will
		 * be provided by Q and appended to these arguments.
		 * @returns a promise for the value or error
		 */
		Q.nsend = // XXX Based on Mark Miller's proposed "send"
		Q.nmcall = // XXX Based on "Redsandro's" proposal
		Q.ninvoke = function (object, name /*...args*/) {
		    var nodeArgs = array_slice(arguments, 2);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
		    return deferred.promise;
		};
		
		Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
		Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
		Promise.prototype.ninvoke = function (name /*...args*/) {
		    var nodeArgs = array_slice(arguments, 1);
		    var deferred = defer();
		    nodeArgs.push(deferred.makeNodeResolver());
		    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
		    return deferred.promise;
		};
		
		/**
		 * If a function would like to support both Node continuation-passing-style and
		 * promise-returning-style, it can end its internal promise chain with
		 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
		 * elects to use a nodeback, the result will be sent there.  If they do not
		 * pass a nodeback, they will receive the result promise.
		 * @param object a result (or a promise for a result)
		 * @param {Function} nodeback a Node.js-style callback
		 * @returns either the promise or nothing
		 */
		Q.nodeify = nodeify;
		function nodeify(object, nodeback) {
		    return Q(object).nodeify(nodeback);
		}
		
		Promise.prototype.nodeify = function (nodeback) {
		    if (nodeback) {
		        this.then(function (value) {
		            Q.nextTick(function () {
		                nodeback(null, value);
		            });
		        }, function (error) {
		            Q.nextTick(function () {
		                nodeback(error);
		            });
		        });
		    } else {
		        return this;
		    }
		};
		
		Q.noConflict = function() {
		    throw new Error("Q.noConflict only works when Q is used as a global");
		};
		
		// All code before this point will be filtered from stack traces.
		var qEndingLine = captureLine();
		
		return Q;
		
		});
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(4).setImmediate))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		// shim for using process in browser
		
		var process = module.exports = {};
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		
		function cleanUpNextTick() {
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}
		
		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = setTimeout(cleanUpNextTick);
		    draining = true;
		
		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    clearTimeout(timeout);
		}
		
		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        setTimeout(drainQueue, 0);
		    }
		};
		
		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		
		function noop() {}
		
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		
		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};
		
		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(3).nextTick;
		var apply = Function.prototype.apply;
		var slice = Array.prototype.slice;
		var immediateIds = {};
		var nextImmediateId = 0;
		
		// DOM APIs, for completeness
		
		exports.setTimeout = function() {
		  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
		};
		exports.setInterval = function() {
		  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
		};
		exports.clearTimeout =
		exports.clearInterval = function(timeout) { timeout.close(); };
		
		function Timeout(id, clearFn) {
		  this._id = id;
		  this._clearFn = clearFn;
		}
		Timeout.prototype.unref = Timeout.prototype.ref = function() {};
		Timeout.prototype.close = function() {
		  this._clearFn.call(window, this._id);
		};
		
		// Does not start the time, just sets up the members needed.
		exports.enroll = function(item, msecs) {
		  clearTimeout(item._idleTimeoutId);
		  item._idleTimeout = msecs;
		};
		
		exports.unenroll = function(item) {
		  clearTimeout(item._idleTimeoutId);
		  item._idleTimeout = -1;
		};
		
		exports._unrefActive = exports.active = function(item) {
		  clearTimeout(item._idleTimeoutId);
		
		  var msecs = item._idleTimeout;
		  if (msecs >= 0) {
		    item._idleTimeoutId = setTimeout(function onTimeout() {
		      if (item._onTimeout)
		        item._onTimeout();
		    }, msecs);
		  }
		};
		
		// That's not how node.js implements it but the exposed api is the same.
		exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
		  var id = nextImmediateId++;
		  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
		
		  immediateIds[id] = true;
		
		  nextTick(function onNextTick() {
		    if (immediateIds[id]) {
		      // fn.call() is faster so we optimize for the common use-case
		      // @see http://jsperf.com/call-apply-segu
		      if (args) {
		        fn.apply(null, args);
		      } else {
		        fn.call(null);
		      }
		      // Prevent ids from leaking
		      exports.clearImmediate(id);
		    }
		  });
		
		  return id;
		};
		
		exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
		  delete immediateIds[id];
		};
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).setImmediate, __webpack_require__(4).clearImmediate))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
		 * @license
		 * lodash 4.11.1 (Custom Build) <https://lodash.com/>
		 * Build: `lodash -d -o ./foo/lodash.js`
		 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
		 * Released under MIT license <https://lodash.com/license>
		 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
		 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		 */
		;(function() {
		
		  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
		  var undefined;
		
		  /** Used as the semantic version number. */
		  var VERSION = '4.11.1';
		
		  /** Used as the size to enable large array optimizations. */
		  var LARGE_ARRAY_SIZE = 200;
		
		  /** Used as the `TypeError` message for "Functions" methods. */
		  var FUNC_ERROR_TEXT = 'Expected a function';
		
		  /** Used to stand-in for `undefined` hash values. */
		  var HASH_UNDEFINED = '__lodash_hash_undefined__';
		
		  /** Used as the internal argument placeholder. */
		  var PLACEHOLDER = '__lodash_placeholder__';
		
		  /** Used to compose bitmasks for wrapper metadata. */
		  var BIND_FLAG = 1,
		      BIND_KEY_FLAG = 2,
		      CURRY_BOUND_FLAG = 4,
		      CURRY_FLAG = 8,
		      CURRY_RIGHT_FLAG = 16,
		      PARTIAL_FLAG = 32,
		      PARTIAL_RIGHT_FLAG = 64,
		      ARY_FLAG = 128,
		      REARG_FLAG = 256,
		      FLIP_FLAG = 512;
		
		  /** Used to compose bitmasks for comparison styles. */
		  var UNORDERED_COMPARE_FLAG = 1,
		      PARTIAL_COMPARE_FLAG = 2;
		
		  /** Used as default options for `_.truncate`. */
		  var DEFAULT_TRUNC_LENGTH = 30,
		      DEFAULT_TRUNC_OMISSION = '...';
		
		  /** Used to detect hot functions by number of calls within a span of milliseconds. */
		  var HOT_COUNT = 150,
		      HOT_SPAN = 16;
		
		  /** Used to indicate the type of lazy iteratees. */
		  var LAZY_FILTER_FLAG = 1,
		      LAZY_MAP_FLAG = 2,
		      LAZY_WHILE_FLAG = 3;
		
		  /** Used as references for various `Number` constants. */
		  var INFINITY = 1 / 0,
		      MAX_SAFE_INTEGER = 9007199254740991,
		      MAX_INTEGER = 1.7976931348623157e+308,
		      NAN = 0 / 0;
		
		  /** Used as references for the maximum length and index of an array. */
		  var MAX_ARRAY_LENGTH = 4294967295,
		      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
		      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
		
		  /** `Object#toString` result references. */
		  var argsTag = '[object Arguments]',
		      arrayTag = '[object Array]',
		      boolTag = '[object Boolean]',
		      dateTag = '[object Date]',
		      errorTag = '[object Error]',
		      funcTag = '[object Function]',
		      genTag = '[object GeneratorFunction]',
		      mapTag = '[object Map]',
		      numberTag = '[object Number]',
		      objectTag = '[object Object]',
		      promiseTag = '[object Promise]',
		      regexpTag = '[object RegExp]',
		      setTag = '[object Set]',
		      stringTag = '[object String]',
		      symbolTag = '[object Symbol]',
		      weakMapTag = '[object WeakMap]',
		      weakSetTag = '[object WeakSet]';
		
		  var arrayBufferTag = '[object ArrayBuffer]',
		      dataViewTag = '[object DataView]',
		      float32Tag = '[object Float32Array]',
		      float64Tag = '[object Float64Array]',
		      int8Tag = '[object Int8Array]',
		      int16Tag = '[object Int16Array]',
		      int32Tag = '[object Int32Array]',
		      uint8Tag = '[object Uint8Array]',
		      uint8ClampedTag = '[object Uint8ClampedArray]',
		      uint16Tag = '[object Uint16Array]',
		      uint32Tag = '[object Uint32Array]';
		
		  /** Used to match empty string literals in compiled template source. */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
		
		  /** Used to match HTML entities and HTML characters. */
		  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
		      reUnescapedHtml = /[&<>"'`]/g,
		      reHasEscapedHtml = RegExp(reEscapedHtml.source),
		      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
		
		  /** Used to match template delimiters. */
		  var reEscape = /<%-([\s\S]+?)%>/g,
		      reEvaluate = /<%([\s\S]+?)%>/g,
		      reInterpolate = /<%=([\s\S]+?)%>/g;
		
		  /** Used to match property names within property paths. */
		  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		      reIsPlainProp = /^\w*$/,
		      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
		
		  /**
		   * Used to match `RegExp`
		   * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
		   */
		  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
		      reHasRegExpChar = RegExp(reRegExpChar.source);
		
		  /** Used to match leading and trailing whitespace. */
		  var reTrim = /^\s+|\s+$/g,
		      reTrimStart = /^\s+/,
		      reTrimEnd = /\s+$/;
		
		  /** Used to match non-compound words composed of alphanumeric characters. */
		  var reBasicWord = /[a-zA-Z0-9]+/g;
		
		  /** Used to match backslashes in property paths. */
		  var reEscapeChar = /\\(\\)?/g;
		
		  /**
		   * Used to match
		   * [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components).
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
		
		  /** Used to match `RegExp` flags from their coerced string values. */
		  var reFlags = /\w*$/;
		
		  /** Used to detect hexadecimal string values. */
		  var reHasHexPrefix = /^0x/i;
		
		  /** Used to detect bad signed hexadecimal string values. */
		  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
		
		  /** Used to detect binary string values. */
		  var reIsBinary = /^0b[01]+$/i;
		
		  /** Used to detect host constructors (Safari). */
		  var reIsHostCtor = /^\[object .+?Constructor\]$/;
		
		  /** Used to detect octal string values. */
		  var reIsOctal = /^0o[0-7]+$/i;
		
		  /** Used to detect unsigned integer values. */
		  var reIsUint = /^(?:0|[1-9]\d*)$/;
		
		  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
		  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
		
		  /** Used to ensure capturing order of template delimiters. */
		  var reNoMatch = /($^)/;
		
		  /** Used to match unescaped characters in compiled string literals. */
		  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
		
		  /** Used to compose unicode character classes. */
		  var rsAstralRange = '\\ud800-\\udfff',
		      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
		      rsComboSymbolsRange = '\\u20d0-\\u20f0',
		      rsDingbatRange = '\\u2700-\\u27bf',
		      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
		      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
		      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
		      rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
		      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
		      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
		      rsVarRange = '\\ufe0e\\ufe0f',
		      rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;
		
		  /** Used to compose unicode capture groups. */
		  var rsApos = "['\u2019]",
		      rsAstral = '[' + rsAstralRange + ']',
		      rsBreak = '[' + rsBreakRange + ']',
		      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
		      rsDigits = '\\d+',
		      rsDingbat = '[' + rsDingbatRange + ']',
		      rsLower = '[' + rsLowerRange + ']',
		      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
		      rsFitz = '\\ud83c[\\udffb-\\udfff]',
		      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		      rsNonAstral = '[^' + rsAstralRange + ']',
		      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		      rsUpper = '[' + rsUpperRange + ']',
		      rsZWJ = '\\u200d';
		
		  /** Used to compose unicode regexes. */
		  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
		      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
		      rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
		      rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
		      reOptMod = rsModifier + '?',
		      rsOptVar = '[' + rsVarRange + ']?',
		      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		      rsSeq = rsOptVar + reOptMod + rsOptJoin,
		      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
		      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
		
		  /** Used to match apostrophes. */
		  var reApos = RegExp(rsApos, 'g');
		
		  /**
		   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
		   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
		   */
		  var reComboMark = RegExp(rsCombo, 'g');
		
		  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		  var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
		
		  /** Used to match complex or compound words. */
		  var reComplexWord = RegExp([
		    rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
		    rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
		    rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
		    rsUpper + '+' + rsOptUpperContr,
		    rsDigits,
		    rsEmoji
		  ].join('|'), 'g');
		
		  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		  var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
		
		  /** Used to detect strings that need a more robust regexp to match words. */
		  var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
		
		  /** Used to assign default `context` object properties. */
		  var contextProps = [
		    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
		    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
		    'Promise', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError',
		    'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
		    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
		  ];
		
		  /** Used to make template sourceURLs easier to identify. */
		  var templateCounter = -1;
		
		  /** Used to identify `toStringTag` values of typed arrays. */
		  var typedArrayTags = {};
		  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		  typedArrayTags[uint32Tag] = true;
		  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		  typedArrayTags[setTag] = typedArrayTags[stringTag] =
		  typedArrayTags[weakMapTag] = false;
		
		  /** Used to identify `toStringTag` values supported by `_.clone`. */
		  var cloneableTags = {};
		  cloneableTags[argsTag] = cloneableTags[arrayTag] =
		  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		  cloneableTags[boolTag] = cloneableTags[dateTag] =
		  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		  cloneableTags[int32Tag] = cloneableTags[mapTag] =
		  cloneableTags[numberTag] = cloneableTags[objectTag] =
		  cloneableTags[regexpTag] = cloneableTags[setTag] =
		  cloneableTags[stringTag] = cloneableTags[symbolTag] =
		  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		  cloneableTags[errorTag] = cloneableTags[funcTag] =
		  cloneableTags[weakMapTag] = false;
		
		  /** Used to map latin-1 supplementary letters to basic latin letters. */
		  var deburredLetters = {
		    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
		    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
		    '\xc7': 'C',  '\xe7': 'c',
		    '\xd0': 'D',  '\xf0': 'd',
		    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
		    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
		    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
		    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
		    '\xd1': 'N',  '\xf1': 'n',
		    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
		    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
		    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
		    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
		    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
		    '\xc6': 'Ae', '\xe6': 'ae',
		    '\xde': 'Th', '\xfe': 'th',
		    '\xdf': 'ss'
		  };
		
		  /** Used to map characters to HTML entities. */
		  var htmlEscapes = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#39;',
		    '`': '&#96;'
		  };
		
		  /** Used to map HTML entities to characters. */
		  var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'",
		    '&#96;': '`'
		  };
		
		  /** Used to determine if values are of the language type `Object`. */
		  var objectTypes = {
		    'function': true,
		    'object': true
		  };
		
		  /** Used to escape characters for inclusion in compiled string literals. */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };
		
		  /** Built-in method references without a dependency on `root`. */
		  var freeParseFloat = parseFloat,
		      freeParseInt = parseInt;
		
		  /** Detect free variable `exports`. */
		  var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
		    ? exports
		    : undefined;
		
		  /** Detect free variable `module`. */
		  var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
		    ? module
		    : undefined;
		
		  /** Detect the popular CommonJS extension `module.exports`. */
		  var moduleExports = (freeModule && freeModule.exports === freeExports)
		    ? freeExports
		    : undefined;
		
		  /** Detect free variable `global` from Node.js. */
		  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
		
		  /** Detect free variable `self`. */
		  var freeSelf = checkGlobal(objectTypes[typeof self] && self);
		
		  /** Detect free variable `window`. */
		  var freeWindow = checkGlobal(objectTypes[typeof window] && window);
		
		  /** Detect `this` as the global object. */
		  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
		
		  /**
		   * Used as a reference to the global object.
		   *
		   * The `this` value is used if it's the global object to avoid Greasemonkey's
		   * restricted `window` object, otherwise the `window` object is used.
		   */
		  var root = freeGlobal ||
		    ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
		      freeSelf || thisGlobal || Function('return this')();
		
		  /*--------------------------------------------------------------------------*/
		
		  /**
		   * Adds the key-value `pair` to `map`.
		   *
		   * @private
		   * @param {Object} map The map to modify.
		   * @param {Array} pair The key-value pair to add.
		   * @returns {Object} Returns `map`.
		   */
		  function addMapEntry(map, pair) {
		    // Don't return `Map#set` because it doesn't return the map instance in IE 11.
		    map.set(pair[0], pair[1]);
		    return map;
		  }
		
		  /**
		   * Adds `value` to `set`.
		   *
		   * @private
		   * @param {Object} set The set to modify.
		   * @param {*} value The value to add.
		   * @returns {Object} Returns `set`.
		   */
		  function addSetEntry(set, value) {
		    set.add(value);
		    return set;
		  }
		
		  /**
		   * A faster alternative to `Function#apply`, this function invokes `func`
		   * with the `this` binding of `thisArg` and the arguments of `args`.
		   *
		   * @private
		   * @param {Function} func The function to invoke.
		   * @param {*} thisArg The `this` binding of `func`.
		   * @param {Array} args The arguments to invoke `func` with.
		   * @returns {*} Returns the result of `func`.
		   */
		  function apply(func, thisArg, args) {
		    var length = args.length;
		    switch (length) {
		      case 0: return func.call(thisArg);
		      case 1: return func.call(thisArg, args[0]);
		      case 2: return func.call(thisArg, args[0], args[1]);
		      case 3: return func.call(thisArg, args[0], args[1], args[2]);
		    }
		    return func.apply(thisArg, args);
		  }
		
		  /**
		   * A specialized version of `baseAggregator` for arrays.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} setter The function to set `accumulator` values.
		   * @param {Function} iteratee The iteratee to transform keys.
		   * @param {Object} accumulator The initial aggregated object.
		   * @returns {Function} Returns `accumulator`.
		   */
		  function arrayAggregator(array, setter, iteratee, accumulator) {
		    var index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      var value = array[index];
		      setter(accumulator, value, iteratee(value), array);
		    }
		    return accumulator;
		  }
		
		  /**
		   * Creates a new array concatenating `array` with `other`.
		   *
		   * @private
		   * @param {Array} array The first array to concatenate.
		   * @param {Array} other The second array to concatenate.
		   * @returns {Array} Returns the new concatenated array.
		   */
		  function arrayConcat(array, other) {
		    var index = -1,
		        length = array.length,
		        othIndex = -1,
		        othLength = other.length,
		        result = Array(length + othLength);
		
		    while (++index < length) {
		      result[index] = array[index];
		    }
		    while (++othIndex < othLength) {
		      result[index++] = other[othIndex];
		    }
		    return result;
		  }
		
		  /**
		   * A specialized version of `_.forEach` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEach(array, iteratee) {
		    var index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      if (iteratee(array[index], index, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }
		
		  /**
		   * A specialized version of `_.forEachRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEachRight(array, iteratee) {
		    var length = array.length;
		
		    while (length--) {
		      if (iteratee(array[length], length, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }
		
		  /**
		   * A specialized version of `_.every` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if all elements pass the predicate check,
		   *  else `false`.
		   */
		  function arrayEvery(array, predicate) {
		    var index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      if (!predicate(array[index], index, array)) {
		        return false;
		      }
		    }
		    return true;
		  }
		
		  /**
		   * A specialized version of `_.filter` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {Array} Returns the new filtered array.
		   */
		  function arrayFilter(array, predicate) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];
		
		    while (++index < length) {
		      var value = array[index];
		      if (predicate(value, index, array)) {
		        result[resIndex++] = value;
		      }
		    }
		    return result;
		  }
		
		  /**
		   * A specialized version of `_.includes` for arrays without support for
		   * specifying an index to search from.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {*} target The value to search for.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludes(array, value) {
		    return !!array.length && baseIndexOf(array, value, 0) > -1;
		  }
		
		  /**
		   * This function is like `arrayIncludes` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {*} target The value to search for.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludesWith(array, value, comparator) {
		    var index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      if (comparator(value, array[index])) {
		        return true;
		      }
		    }
		    return false;
		  }
		
		  /**
		   * A specialized version of `_.map` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the new mapped array.
		   */
		  function arrayMap(array, iteratee) {
		    var index = -1,
		        length = array.length,
		        result = Array(length);
		
		    while (++index < length) {
		      result[index] = iteratee(array[index], index, array);
		    }
		    return result;
		  }
		
		  /**
		   * Appends the elements of `values` to `array`.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {Array} values The values to append.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayPush(array, values) {
		    var index = -1,
		        length = values.length,
		        offset = array.length;
		
		    while (++index < length) {
		      array[offset + index] = values[index];
		    }
		    return array;
		  }
		
		  /**
		   * A specialized version of `_.reduce` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the first element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduce(array, iteratee, accumulator, initAccum) {
		    var index = -1,
		        length = array.length;
		
		    if (initAccum && length) {
		      accumulator = array[++index];
		    }
		    while (++index < length) {
		      accumulator = iteratee(accumulator, array[index], index, array);
		    }
		    return accumulator;
		  }
		
		  /**
		   * A specialized version of `_.reduceRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the last element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
		    var length = array.length;
		    if (initAccum && length) {
		      accumulator = array[--length];
		    }
		    while (length--) {
		      accumulator = iteratee(accumulator, array[length], length, array);
		    }
		    return accumulator;
		  }
		
		  /**
		   * A specialized version of `_.some` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if any element passes the predicate check,
		   *  else `false`.
		   */
		  function arraySome(array, predicate) {
		    var index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      if (predicate(array[index], index, array)) {
		        return true;
		      }
		    }
		    return false;
		  }
		
		  /**
		   * The base implementation of methods like `_.max` and `_.min` which accepts a
		   * `comparator` to determine the extremum value.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The iteratee invoked per iteration.
		   * @param {Function} comparator The comparator used to compare values.
		   * @returns {*} Returns the extremum value.
		   */
		  function baseExtremum(array, iteratee, comparator) {
		    var index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      var value = array[index],
		          current = iteratee(value);
		
		      if (current != null && (computed === undefined
		            ? current === current
		            : comparator(current, computed)
		          )) {
		        var computed = current,
		            result = value;
		      }
		    }
		    return result;
		  }
		
		  /**
		   * The base implementation of methods like `_.find` and `_.findKey`, without
		   * support for iteratee shorthands, which iterates over `collection` using
		   * `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to search.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @param {boolean} [retKey] Specify returning the key of the found element
		   *  instead of the element itself.
		   * @returns {*} Returns the found element or its key, else `undefined`.
		   */
		  function baseFind(collection, predicate, eachFunc, retKey) {
		    var result;
		    eachFunc(collection, function(value, key, collection) {
		      if (predicate(value, key, collection)) {
		        result = retKey ? key : value;
		        return false;
		      }
		    });
		    return result;
		  }
		
		  /**
		   * The base implementation of `_.findIndex` and `_.findLastIndex` without
		   * support for iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseFindIndex(array, predicate, fromRight) {
		    var length = array.length,
		        index = fromRight ? length : -1;
		
		    while ((fromRight ? index-- : ++index < length)) {
		      if (predicate(array[index], index, array)) {
		        return index;
		      }
		    }
		    return -1;
		  }
		
		  /**
		   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    if (value !== value) {
		      return indexOfNaN(array, fromIndex);
		    }
		    var index = fromIndex - 1,
		        length = array.length;
		
		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }
		
		  /**
		   * This function is like `baseIndexOf` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOfWith(array, value, fromIndex, comparator) {
		    var index = fromIndex - 1,
		        length = array.length;
		
		    while (++index < length) {
		      if (comparator(array[index], value)) {
		        return index;
		      }
		    }
		    return -1;
		  }
		
		  /**
		   * The base implementation of `_.mean` and `_.meanBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the mean.
		   */
		  function baseMean(array, iteratee) {
		    var length = array ? array.length : 0;
		    return length ? (baseSum(array, iteratee) / length) : NAN;
		  }
		
		  /**
		   * The base implementation of `_.reduce` and `_.reduceRight`, without support
		   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} accumulator The initial value.
		   * @param {boolean} initAccum Specify using the first or last element of
		   *  `collection` as the initial value.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the accumulated value.
		   */
		  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
		    eachFunc(collection, function(value, index, collection) {
		      accumulator = initAccum
		        ? (initAccum = false, value)
		        : iteratee(accumulator, value, index, collection);
		    });
		    return accumulator;
		  }
		
		  /**
		   * The base implementation of `_.sortBy` which uses `comparer` to define the
		   * sort order of `array` and replaces criteria objects with their corresponding
		   * values.
		   *
		   * @private
		   * @param {Array} array The array to sort.
		   * @param {Function} comparer The function to define sort order.
		   * @returns {Array} Returns `array`.
		   */
		  function baseSortBy(array, comparer) {
		    var length = array.length;
		
		    array.sort(comparer);
		    while (length--) {
		      array[length] = array[length].value;
		    }
		    return array;
		  }
		
		  /**
		   * The base implementation of `_.sum` and `_.sumBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the sum.
		   */
		  function baseSum(array, iteratee) {
		    var result,
		        index = -1,
		        length = array.length;
		
		    while (++index < length) {
		      var current = iteratee(array[index]);
		      if (current !== undefined) {
		        result = result === undefined ? current : (result + current);
		      }
		    }
		    return result;
		  }
		
		  /**
		   * The base implementation of `_.times` without support for iteratee shorthands
		   * or max array length checks.
		   *
		   * @private
		   * @param {number} n The number of times to invoke `iteratee`.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the array of results.
		   */
		  function baseTimes(n, iteratee) {
		    var index = -1,
		        result = Array(n);
		
		    while (++index < n) {
		      result[index] = iteratee(index);
		    }
		    return result;
		  }
		
		  /**
		   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		   * of key-value pairs for `object` corresponding to the property names of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the new array of key-value pairs.
		   */
		  function baseToPairs(object, props) {
		    return arrayMap(props, function(key) {
		      return [key, object[key]];
		    });
		  }
		
		  /**
		   * The base implementation of `_.unary` without support for storing wrapper metadata.
		   *
		   * @private
		   * @param {Function} func The function to cap arguments for.
		   * @returns {Function} Returns the new function.
		   */
		  function baseUnary(func) {
		    return function(value) {
		      return func(value);
		    };
		  }
		
		  /**
		   * The base implementation of `_.values` and `_.valuesIn` which creates an
		   * array of `object` property values corresponding to the property names
		   * of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the array of property values.
		   */
		  function baseValues(object, props) {
		    return arrayMap(props, function(key) {
		      return object[key];
		    });
		  }
		
		  /**
		   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the first unmatched string symbol.
		   */
		  function charsStartIndex(strSymbols, chrSymbols) {
		    var index = -1,
		        length = strSymbols.length;
		
		    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }
		
		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the last unmatched string symbol.
		   */
		  function charsEndIndex(strSymbols, chrSymbols) {
		    var index = strSymbols.length;
		
		    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }
		
		  /**
		   * Checks if `value` is a global object.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {null|Object} Returns `value` if it's a global object, else `null`.
		   */
		  function checkGlobal(value) {
		    return (value && value.Object === Object) ? value : null;
		  }
		
		  /**
		   * Compares values to sort them in ascending order.
		   *
		   * @private
		   * @param {*} value The value to compare.
		   * @param {*} other The other value to compare.
		   * @returns {number} Returns the sort order indicator for `value`.
		   */
		  function compareAscending(value, other) {
		    if (value !== other) {
		      var valIsNull = value === null,
		          valIsUndef = value === undefined,
		          valIsReflexive = value === value;
		
		      var othIsNull = other === null,
		          othIsUndef = other === undefined,
		          othIsReflexive = other === other;
		
		      if ((value > other && !othIsNull) || !valIsReflexive ||
		          (valIsNull && !othIsUndef && othIsReflexive) ||
		          (valIsUndef && othIsReflexive)) {
		        return 1;
		      }
		      if ((value < other && !valIsNull) || !othIsReflexive ||
		          (othIsNull && !valIsUndef && valIsReflexive) ||
		          (othIsUndef && valIsReflexive)) {
		        return -1;
		      }
		    }
		    return 0;
		  }
		
		  /**
		   * Used by `_.orderBy` to compare multiple properties of a value to another
		   * and stable sort them.
		   *
		   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
		   * specify an order of "desc" for descending or "asc" for ascending sort order
		   * of corresponding values.
		   *
		   * @private
		   * @param {Object} object The object to compare.
		   * @param {Object} other The other object to compare.
		   * @param {boolean[]|string[]} orders The order to sort by for each property.
		   * @returns {number} Returns the sort order indicator for `object`.
		   */
		  function compareMultiple(object, other, orders) {
		    var index = -1,
		        objCriteria = object.criteria,
		        othCriteria = other.criteria,
		        length = objCriteria.length,
		        ordersLength = orders.length;
		
		    while (++index < length) {
		      var result = compareAscending(objCriteria[index], othCriteria[index]);
		      if (result) {
		        if (index >= ordersLength) {
		          return result;
		        }
		        var order = orders[index];
		        return result * (order == 'desc' ? -1 : 1);
		      }
		    }
		    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		    // that causes it, under certain circumstances, to provide the same value for
		    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
		    // for more details.
		    //
		    // This also ensures a stable sort in V8 and other engines.
		    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
		    return object.index - other.index;
		  }
		
		  /**
		   * Gets the number of `placeholder` occurrences in `array`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} placeholder The placeholder to search for.
		   * @returns {number} Returns the placeholder count.
		   */
		  function countHolders(array, placeholder) {
		    var length = array.length,
		        result = 0;
		
		    while (length--) {
		      if (array[length] === placeholder) {
		        result++;
		      }
		    }
		    return result;
		  }
		
		  /**
		   * Creates a function that performs a mathematical operation on two values.
		   *
		   * @private
		   * @param {Function} operator The function to perform the operation.
		   * @returns {Function} Returns the new mathematical operation function.
		   */
		  function createMathOperation(operator) {
		    return function(value, other) {
		      var result;
		      if (value === undefined && other === undefined) {
		        return 0;
		      }
		      if (value !== undefined) {
		        result = value;
		      }
		      if (other !== undefined) {
		        result = result === undefined ? other : operator(result, other);
		      }
		      return result;
		    };
		  }
		
		  /**
		   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
		   *
		   * @private
		   * @param {string} letter The matched letter to deburr.
		   * @returns {string} Returns the deburred letter.
		   */
		  function deburrLetter(letter) {
		    return deburredLetters[letter];
		  }
		
		  /**
		   * Used by `_.escape` to convert characters to HTML entities.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeHtmlChar(chr) {
		    return htmlEscapes[chr];
		  }
		
		  /**
		   * Used by `_.template` to escape characters for inclusion in compiled string literals.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(chr) {
		    return '\\' + stringEscapes[chr];
		  }
		
		  /**
		   * Gets the index at which the first occurrence of `NaN` is found in `array`.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {number} fromIndex The index to search from.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
		   */
		  function indexOfNaN(array, fromIndex, fromRight) {
		    var length = array.length,
		        index = fromIndex + (fromRight ? 0 : -1);
		
		    while ((fromRight ? index-- : ++index < length)) {
		      var other = array[index];
		      if (other !== other) {
		        return index;
		      }
		    }
		    return -1;
		  }
		
		  /**
		   * Checks if `value` is a host object in IE < 9.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
		   */
		  function isHostObject(value) {
		    // Many host objects are `Object` objects that can coerce to strings
		    // despite having improperly defined `toString` methods.
		    var result = false;
		    if (value != null && typeof value.toString != 'function') {
		      try {
		        result = !!(value + '');
		      } catch (e) {}
		    }
		    return result;
		  }
		
		  /**
		   * Checks if `value` is a valid array-like index.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		   */
		  function isIndex(value, length) {
		    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
		    length = length == null ? MAX_SAFE_INTEGER : length;
		    return value > -1 && value % 1 == 0 && value < length;
		  }
		
		  /**
		   * Converts `iterator` to an array.
		   *
		   * @private
		   * @param {Object} iterator The iterator to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function iteratorToArray(iterator) {
		    var data,
		        result = [];
		
		    while (!(data = iterator.next()).done) {
		      result.push(data.value);
		    }
		    return result;
		  }
		
		  /**
		   * Converts `map` to an array.
		   *
		   * @private
		   * @param {Object} map The map to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function mapToArray(map) {
		    var index = -1,
		        result = Array(map.size);
		
		    map.forEach(function(value, key) {
		      result[++index] = [key, value];
		    });
		    return result;
		  }
		
		  /**
		   * Replaces all `placeholder` elements in `array` with an internal placeholder
		   * and returns an array of their indexes.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {*} placeholder The placeholder to replace.
		   * @returns {Array} Returns the new array of placeholder indexes.
		   */
		  function replaceHolders(array, placeholder) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];
		
		    while (++index < length) {
		      var value = array[index];
		      if (value === placeholder || value === PLACEHOLDER) {
		        array[index] = PLACEHOLDER;
		        result[resIndex++] = index;
		      }
		    }
		    return result;
		  }
		
		  /**
		   * Converts `set` to an array.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function setToArray(set) {
		    var index = -1,
		        result = Array(set.size);
		
		    set.forEach(function(value) {
		      result[++index] = value;
		    });
		    return result;
		  }
		
		  /**
		   * Gets the number of symbols in `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the string size.
		   */
		  function stringSize(string) {
		    if (!(string && reHasComplexSymbol.test(string))) {
		      return string.length;
		    }
		    var result = reComplexSymbol.lastIndex = 0;
		    while (reComplexSymbol.test(string)) {
		      result++;
		    }
		    return result;
		  }
		
		  /**
		   * Converts `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function stringToArray(string) {
		    return string.match(reComplexSymbol);
		  }
		
		  /**
		   * Used by `_.unescape` to convert HTML entities to characters.
		   *
		   * @private
		   * @param {string} chr The matched character to unescape.
		   * @returns {string} Returns the unescaped character.
		   */
		  function unescapeHtmlChar(chr) {
		    return htmlUnescapes[chr];
		  }
		
		  /*--------------------------------------------------------------------------*/
		
		  /**
		   * Create a new pristine `lodash` function using the `context` object.
		   *
		   * @static
		   * @memberOf _
		   * @since 1.1.0
		   * @category Util
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns a new `lodash` function.
		   * @example
		   *
		   * _.mixin({ 'foo': _.constant('foo') });
		   *
		   * var lodash = _.runInContext();
		   * lodash.mixin({ 'bar': lodash.constant('bar') });
		   *
		   * _.isFunction(_.foo);
		   * // => true
		   * _.isFunction(_.bar);
		   * // => false
		   *
		   * lodash.isFunction(lodash.foo);
		   * // => false
		   * lodash.isFunction(lodash.bar);
		   * // => true
		   *
		   * // Use `context` to mock `Date#getTime` use in `_.now`.
		   * var mock = _.runInContext({
		   *   'Date': function() {
		   *     return { 'getTime': getTimeMock };
		   *   }
		   * });
		   *
		   * // Create a suped-up `defer` in Node.js.
		   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
		   */
		  function runInContext(context) {
		    context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
		
		    /** Built-in constructor references. */
		    var Date = context.Date,
		        Error = context.Error,
		        Math = context.Math,
		        RegExp = context.RegExp,
		        TypeError = context.TypeError;
		
		    /** Used for built-in method references. */
		    var arrayProto = context.Array.prototype,
		        objectProto = context.Object.prototype,
		        stringProto = context.String.prototype;
		
		    /** Used to resolve the decompiled source of functions. */
		    var funcToString = context.Function.prototype.toString;
		
		    /** Used to check objects for own properties. */
		    var hasOwnProperty = objectProto.hasOwnProperty;
		
		    /** Used to generate unique IDs. */
		    var idCounter = 0;
		
		    /** Used to infer the `Object` constructor. */
		    var objectCtorString = funcToString.call(Object);
		
		    /**
		     * Used to resolve the
		     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		     * of values.
		     */
		    var objectToString = objectProto.toString;
		
		    /** Used to restore the original `_` reference in `_.noConflict`. */
		    var oldDash = root._;
		
		    /** Used to detect if a method is native. */
		    var reIsNative = RegExp('^' +
		      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		    );
		
		    /** Built-in value references. */
		    var Buffer = moduleExports ? context.Buffer : undefined,
		        Reflect = context.Reflect,
		        Symbol = context.Symbol,
		        Uint8Array = context.Uint8Array,
		        clearTimeout = context.clearTimeout,
		        enumerate = Reflect ? Reflect.enumerate : undefined,
		        getOwnPropertySymbols = Object.getOwnPropertySymbols,
		        iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,
		        objectCreate = Object.create,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        setTimeout = context.setTimeout,
		        splice = arrayProto.splice;
		
		    /* Built-in method references for those with the same name as other `lodash` methods. */
		    var nativeCeil = Math.ceil,
		        nativeFloor = Math.floor,
		        nativeGetPrototype = Object.getPrototypeOf,
		        nativeIsFinite = context.isFinite,
		        nativeJoin = arrayProto.join,
		        nativeKeys = Object.keys,
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random,
		        nativeReplace = stringProto.replace,
		        nativeReverse = arrayProto.reverse,
		        nativeSplit = stringProto.split;
		
		    /* Built-in method references that are verified to be native. */
		    var DataView = getNative(context, 'DataView'),
		        Map = getNative(context, 'Map'),
		        Promise = getNative(context, 'Promise'),
		        Set = getNative(context, 'Set'),
		        WeakMap = getNative(context, 'WeakMap'),
		        nativeCreate = getNative(Object, 'create');
		
		    /** Used to store function metadata. */
		    var metaMap = WeakMap && new WeakMap;
		
		    /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
		    var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
		
		    /** Used to lookup unminified function names. */
		    var realNames = {};
		
		    /** Used to detect maps, sets, and weakmaps. */
		    var dataViewCtorString = toSource(DataView),
		        mapCtorString = toSource(Map),
		        promiseCtorString = toSource(Promise),
		        setCtorString = toSource(Set),
		        weakMapCtorString = toSource(WeakMap);
		
		    /** Used to convert symbols to primitives and strings. */
		    var symbolProto = Symbol ? Symbol.prototype : undefined,
		        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
		        symbolToString = symbolProto ? symbolProto.toString : undefined;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates a `lodash` object which wraps `value` to enable implicit method
		     * chain sequences. Methods that operate on and return arrays, collections,
		     * and functions can be chained together. Methods that retrieve a single value
		     * or may return a primitive value will automatically end the chain sequence
		     * and return the unwrapped value. Otherwise, the value must be unwrapped
		     * with `_#value`.
		     *
		     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
		     * enabled using `_.chain`.
		     *
		     * The execution of chained methods is lazy, that is, it's deferred until
		     * `_#value` is implicitly or explicitly called.
		     *
		     * Lazy evaluation allows several methods to support shortcut fusion.
		     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
		     * the creation of intermediate arrays and can greatly reduce the number of
		     * iteratee executions. Sections of a chain sequence qualify for shortcut
		     * fusion if the section is applied to an array of at least `200` elements
		     * and any iteratees accept only one argument. The heuristic for whether a
		     * section qualifies for shortcut fusion is subject to change.
		     *
		     * Chaining is supported in custom builds as long as the `_#value` method is
		     * directly or indirectly included in the build.
		     *
		     * In addition to lodash methods, wrappers have `Array` and `String` methods.
		     *
		     * The wrapper `Array` methods are:
		     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
		     *
		     * The wrapper `String` methods are:
		     * `replace` and `split`
		     *
		     * The wrapper methods that support shortcut fusion are:
		     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
		     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
		     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
		     *
		     * The chainable wrapper methods are:
		     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
		     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
		     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
		     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
		     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
		     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
		     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
		     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
		     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
		     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
		     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
		     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
		     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
		     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
		     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
		     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
		     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
		     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
		     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
		     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
		     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
		     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
		     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
		     * `zipObject`, `zipObjectDeep`, and `zipWith`
		     *
		     * The wrapper methods that are **not** chainable by default are:
		     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
		     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
		     * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
		     * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
		     * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
		     * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
		     * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
		     * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`, `isBuffer`,
		     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`, `isError`,
		     * `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`, `isMatch`,
		     * `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`,
		     * `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, `isSafeInteger`,
		     * `isSet`, `isString`, `isUndefined`, `isTypedArray`, `isWeakMap`, `isWeakSet`,
		     * `join`, `kebabCase`, `last`, `lastIndexOf`, `lowerCase`, `lowerFirst`,
		     * `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`, `min`, `minBy`, `multiply`,
		     * `noConflict`, `noop`, `now`, `nth`, `pad`, `padEnd`, `padStart`, `parseInt`,
		     * `pop`, `random`, `reduce`, `reduceRight`, `repeat`, `result`, `round`,
		     * `runInContext`, `sample`, `shift`, `size`, `snakeCase`, `some`, `sortedIndex`,
		     * `sortedIndexBy`, `sortedLastIndex`, `sortedLastIndexBy`, `startCase`,
		     * `startsWith`, `subtract`, `sum`, `sumBy`, `template`, `times`, `toInteger`,
		     * `toJSON`, `toLength`, `toLower`, `toNumber`, `toSafeInteger`, `toString`,
		     * `toUpper`, `trim`, `trimEnd`, `trimStart`, `truncate`, `unescape`,
		     * `uniqueId`, `upperCase`, `upperFirst`, `value`, and `words`
		     *
		     * @name _
		     * @constructor
		     * @category Seq
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // Returns an unwrapped value.
		     * wrapped.reduce(_.add);
		     * // => 6
		     *
		     * // Returns a wrapped value.
		     * var squares = wrapped.map(square);
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		        if (value instanceof LodashWrapper) {
		          return value;
		        }
		        if (hasOwnProperty.call(value, '__wrapped__')) {
		          return wrapperClone(value);
		        }
		      }
		      return new LodashWrapper(value);
		    }
		
		    /**
		     * The function whose prototype chain sequence wrappers inherit from.
		     *
		     * @private
		     */
		    function baseLodash() {
		      // No operation performed.
		    }
		
		    /**
		     * The base constructor for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap.
		     * @param {boolean} [chainAll] Enable explicit method chain sequences.
		     */
		    function LodashWrapper(value, chainAll) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__chain__ = !!chainAll;
		      this.__index__ = 0;
		      this.__values__ = undefined;
		    }
		
		    /**
		     * By default, the template delimiters used by lodash are like those in
		     * embedded Ruby (ERB). Change the following template settings to use
		     * alternative delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type {Object}
		     */
		    lodash.templateSettings = {
		
		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'escape': reEscape,
		
		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'evaluate': reEvaluate,
		
		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'interpolate': reInterpolate,
		
		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type {string}
		       */
		      'variable': '',
		
		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type {Object}
		       */
		      'imports': {
		
		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type {Function}
		         */
		        '_': lodash
		      }
		    };
		
		    // Ensure wrappers are instances of `baseLodash`.
		    lodash.prototype = baseLodash.prototype;
		    lodash.prototype.constructor = lodash;
		
		    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
		    LodashWrapper.prototype.constructor = LodashWrapper;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
		     *
		     * @private
		     * @constructor
		     * @param {*} value The value to wrap.
		     */
		    function LazyWrapper(value) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__dir__ = 1;
		      this.__filtered__ = false;
		      this.__iteratees__ = [];
		      this.__takeCount__ = MAX_ARRAY_LENGTH;
		      this.__views__ = [];
		    }
		
		    /**
		     * Creates a clone of the lazy wrapper object.
		     *
		     * @private
		     * @name clone
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the cloned `LazyWrapper` object.
		     */
		    function lazyClone() {
		      var result = new LazyWrapper(this.__wrapped__);
		      result.__actions__ = copyArray(this.__actions__);
		      result.__dir__ = this.__dir__;
		      result.__filtered__ = this.__filtered__;
		      result.__iteratees__ = copyArray(this.__iteratees__);
		      result.__takeCount__ = this.__takeCount__;
		      result.__views__ = copyArray(this.__views__);
		      return result;
		    }
		
		    /**
		     * Reverses the direction of lazy iteration.
		     *
		     * @private
		     * @name reverse
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the new reversed `LazyWrapper` object.
		     */
		    function lazyReverse() {
		      if (this.__filtered__) {
		        var result = new LazyWrapper(this);
		        result.__dir__ = -1;
		        result.__filtered__ = true;
		      } else {
		        result = this.clone();
		        result.__dir__ *= -1;
		      }
		      return result;
		    }
		
		    /**
		     * Extracts the unwrapped value from its lazy wrapper.
		     *
		     * @private
		     * @name value
		     * @memberOf LazyWrapper
		     * @returns {*} Returns the unwrapped value.
		     */
		    function lazyValue() {
		      var array = this.__wrapped__.value(),
		          dir = this.__dir__,
		          isArr = isArray(array),
		          isRight = dir < 0,
		          arrLength = isArr ? array.length : 0,
		          view = getView(0, arrLength, this.__views__),
		          start = view.start,
		          end = view.end,
		          length = end - start,
		          index = isRight ? end : (start - 1),
		          iteratees = this.__iteratees__,
		          iterLength = iteratees.length,
		          resIndex = 0,
		          takeCount = nativeMin(length, this.__takeCount__);
		
		      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
		          (arrLength == length && takeCount == length)) {
		        return baseWrapperValue(array, this.__actions__);
		      }
		      var result = [];
		
		      outer:
		      while (length-- && resIndex < takeCount) {
		        index += dir;
		
		        var iterIndex = -1,
		            value = array[index];
		
		        while (++iterIndex < iterLength) {
		          var data = iteratees[iterIndex],
		              iteratee = data.iteratee,
		              type = data.type,
		              computed = iteratee(value);
		
		          if (type == LAZY_MAP_FLAG) {
		            value = computed;
		          } else if (!computed) {
		            if (type == LAZY_FILTER_FLAG) {
		              continue outer;
		            } else {
		              break outer;
		            }
		          }
		        }
		        result[resIndex++] = value;
		      }
		      return result;
		    }
		
		    // Ensure `LazyWrapper` is an instance of `baseLodash`.
		    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
		    LazyWrapper.prototype.constructor = LazyWrapper;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates a hash object.
		     *
		     * @private
		     * @constructor
		     * @returns {Object} Returns the new hash object.
		     */
		    function Hash() {}
		
		    /**
		     * Removes `key` and its value from the hash.
		     *
		     * @private
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function hashDelete(hash, key) {
		      return hashHas(hash, key) && delete hash[key];
		    }
		
		    /**
		     * Gets the hash value for `key`.
		     *
		     * @private
		     * @param {Object} hash The hash to query.
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function hashGet(hash, key) {
		      if (nativeCreate) {
		        var result = hash[key];
		        return result === HASH_UNDEFINED ? undefined : result;
		      }
		      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
		    }
		
		    /**
		     * Checks if a hash value for `key` exists.
		     *
		     * @private
		     * @param {Object} hash The hash to query.
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function hashHas(hash, key) {
		      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
		    }
		
		    /**
		     * Sets the hash `key` to `value`.
		     *
		     * @private
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     */
		    function hashSet(hash, key, value) {
		      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
		    }
		
		    // Avoid inheriting from `Object.prototype` when possible.
		    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates a map cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function MapCache(values) {
		      var index = -1,
		          length = values ? values.length : 0;
		
		      this.clear();
		      while (++index < length) {
		        var entry = values[index];
		        this.set(entry[0], entry[1]);
		      }
		    }
		
		    /**
		     * Removes all key-value entries from the map.
		     *
		     * @private
		     * @name clear
		     * @memberOf MapCache
		     */
		    function mapClear() {
		      this.__data__ = {
		        'hash': new Hash,
		        'map': Map ? new Map : [],
		        'string': new Hash
		      };
		    }
		
		    /**
		     * Removes `key` and its value from the map.
		     *
		     * @private
		     * @name delete
		     * @memberOf MapCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function mapDelete(key) {
		      var data = this.__data__;
		      if (isKeyable(key)) {
		        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
		      }
		      return Map ? data.map['delete'](key) : assocDelete(data.map, key);
		    }
		
		    /**
		     * Gets the map value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf MapCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function mapGet(key) {
		      var data = this.__data__;
		      if (isKeyable(key)) {
		        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
		      }
		      return Map ? data.map.get(key) : assocGet(data.map, key);
		    }
		
		    /**
		     * Checks if a map value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf MapCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function mapHas(key) {
		      var data = this.__data__;
		      if (isKeyable(key)) {
		        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
		      }
		      return Map ? data.map.has(key) : assocHas(data.map, key);
		    }
		
		    /**
		     * Sets the map `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf MapCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the map cache instance.
		     */
		    function mapSet(key, value) {
		      var data = this.__data__;
		      if (isKeyable(key)) {
		        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
		      } else if (Map) {
		        data.map.set(key, value);
		      } else {
		        assocSet(data.map, key, value);
		      }
		      return this;
		    }
		
		    // Add methods to `MapCache`.
		    MapCache.prototype.clear = mapClear;
		    MapCache.prototype['delete'] = mapDelete;
		    MapCache.prototype.get = mapGet;
		    MapCache.prototype.has = mapHas;
		    MapCache.prototype.set = mapSet;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     *
		     * Creates a set cache object to store unique values.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function SetCache(values) {
		      var index = -1,
		          length = values ? values.length : 0;
		
		      this.__data__ = new MapCache;
		      while (++index < length) {
		        this.push(values[index]);
		      }
		    }
		
		    /**
		     * Checks if `value` is in `cache`.
		     *
		     * @private
		     * @param {Object} cache The set cache to search.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns `true` if `value` is found, else `false`.
		     */
		    function cacheHas(cache, value) {
		      var map = cache.__data__;
		      if (isKeyable(value)) {
		        var data = map.__data__,
		            hash = typeof value == 'string' ? data.string : data.hash;
		
		        return hash[value] === HASH_UNDEFINED;
		      }
		      return map.has(value);
		    }
		
		    /**
		     * Adds `value` to the set cache.
		     *
		     * @private
		     * @name push
		     * @memberOf SetCache
		     * @param {*} value The value to cache.
		     */
		    function cachePush(value) {
		      var map = this.__data__;
		      if (isKeyable(value)) {
		        var data = map.__data__,
		            hash = typeof value == 'string' ? data.string : data.hash;
		
		        hash[value] = HASH_UNDEFINED;
		      }
		      else {
		        map.set(value, HASH_UNDEFINED);
		      }
		    }
		
		    // Add methods to `SetCache`.
		    SetCache.prototype.push = cachePush;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates a stack cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function Stack(values) {
		      var index = -1,
		          length = values ? values.length : 0;
		
		      this.clear();
		      while (++index < length) {
		        var entry = values[index];
		        this.set(entry[0], entry[1]);
		      }
		    }
		
		    /**
		     * Removes all key-value entries from the stack.
		     *
		     * @private
		     * @name clear
		     * @memberOf Stack
		     */
		    function stackClear() {
		      this.__data__ = { 'array': [], 'map': null };
		    }
		
		    /**
		     * Removes `key` and its value from the stack.
		     *
		     * @private
		     * @name delete
		     * @memberOf Stack
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function stackDelete(key) {
		      var data = this.__data__,
		          array = data.array;
		
		      return array ? assocDelete(array, key) : data.map['delete'](key);
		    }
		
		    /**
		     * Gets the stack value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Stack
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function stackGet(key) {
		      var data = this.__data__,
		          array = data.array;
		
		      return array ? assocGet(array, key) : data.map.get(key);
		    }
		
		    /**
		     * Checks if a stack value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Stack
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function stackHas(key) {
		      var data = this.__data__,
		          array = data.array;
		
		      return array ? assocHas(array, key) : data.map.has(key);
		    }
		
		    /**
		     * Sets the stack `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Stack
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the stack cache instance.
		     */
		    function stackSet(key, value) {
		      var data = this.__data__,
		          array = data.array;
		
		      if (array) {
		        if (array.length < (LARGE_ARRAY_SIZE - 1)) {
		          assocSet(array, key, value);
		        } else {
		          data.array = null;
		          data.map = new MapCache(array);
		        }
		      }
		      var map = data.map;
		      if (map) {
		        map.set(key, value);
		      }
		      return this;
		    }
		
		    // Add methods to `Stack`.
		    Stack.prototype.clear = stackClear;
		    Stack.prototype['delete'] = stackDelete;
		    Stack.prototype.get = stackGet;
		    Stack.prototype.has = stackHas;
		    Stack.prototype.set = stackSet;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Removes `key` and its value from the associative array.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function assocDelete(array, key) {
		      var index = assocIndexOf(array, key);
		      if (index < 0) {
		        return false;
		      }
		      var lastIndex = array.length - 1;
		      if (index == lastIndex) {
		        array.pop();
		      } else {
		        splice.call(array, index, 1);
		      }
		      return true;
		    }
		
		    /**
		     * Gets the associative array value for `key`.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function assocGet(array, key) {
		      var index = assocIndexOf(array, key);
		      return index < 0 ? undefined : array[index][1];
		    }
		
		    /**
		     * Checks if an associative array value for `key` exists.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function assocHas(array, key) {
		      return assocIndexOf(array, key) > -1;
		    }
		
		    /**
		     * Gets the index at which the `key` is found in `array` of key-value pairs.
		     *
		     * @private
		     * @param {Array} array The array to search.
		     * @param {*} key The key to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     */
		    function assocIndexOf(array, key) {
		      var length = array.length;
		      while (length--) {
		        if (eq(array[length][0], key)) {
		          return length;
		        }
		      }
		      return -1;
		    }
		
		    /**
		     * Sets the associative array `key` to `value`.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     */
		    function assocSet(array, key, value) {
		      var index = assocIndexOf(array, key);
		      if (index < 0) {
		        array.push([key, value]);
		      } else {
		        array[index][1] = value;
		      }
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Used by `_.defaults` to customize its `_.assignIn` use.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to assign.
		     * @param {Object} object The parent object of `objValue`.
		     * @returns {*} Returns the value to assign.
		     */
		    function assignInDefaults(objValue, srcValue, key, object) {
		      if (objValue === undefined ||
		          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		        return srcValue;
		      }
		      return objValue;
		    }
		
		    /**
		     * This function is like `assignValue` except that it doesn't assign
		     * `undefined` values.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignMergeValue(object, key, value) {
		      if ((value !== undefined && !eq(object[key], value)) ||
		          (typeof key == 'number' && value === undefined && !(key in object))) {
		        object[key] = value;
		      }
		    }
		
		    /**
		     * Assigns `value` to `key` of `object` if the existing value is not equivalent
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignValue(object, key, value) {
		      var objValue = object[key];
		      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		          (value === undefined && !(key in object))) {
		        object[key] = value;
		      }
		    }
		
		    /**
		     * Aggregates elements of `collection` on `accumulator` with keys transformed
		     * by `iteratee` and values set by `setter`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform keys.
		     * @param {Object} accumulator The initial aggregated object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseAggregator(collection, setter, iteratee, accumulator) {
		      baseEach(collection, function(value, key, collection) {
		        setter(accumulator, value, iteratee(value), collection);
		      });
		      return accumulator;
		    }
		
		    /**
		     * The base implementation of `_.assign` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssign(object, source) {
		      return object && copyObject(source, keys(source), object);
		    }
		
		    /**
		     * The base implementation of `_.at` without support for individual paths.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {string[]} paths The property paths of elements to pick.
		     * @returns {Array} Returns the new array of picked elements.
		     */
		    function baseAt(object, paths) {
		      var index = -1,
		          isNil = object == null,
		          length = paths.length,
		          result = Array(length);
		
		      while (++index < length) {
		        result[index] = isNil ? undefined : get(object, paths[index]);
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
		     *
		     * @private
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     */
		    function baseClamp(number, lower, upper) {
		      if (number === number) {
		        if (upper !== undefined) {
		          number = number <= upper ? number : upper;
		        }
		        if (lower !== undefined) {
		          number = number >= lower ? number : lower;
		        }
		      }
		      return number;
		    }
		
		    /**
		     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		     * traversed objects.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @param {boolean} [isFull] Specify a clone including symbols.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @param {string} [key] The key of `value`.
		     * @param {Object} [object] The parent object of `value`.
		     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
		      var result;
		      if (customizer) {
		        result = object ? customizer(value, key, object, stack) : customizer(value);
		      }
		      if (result !== undefined) {
		        return result;
		      }
		      if (!isObject(value)) {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isArr) {
		        result = initCloneArray(value);
		        if (!isDeep) {
		          return copyArray(value, result);
		        }
		      } else {
		        var tag = getTag(value),
		            isFunc = tag == funcTag || tag == genTag;
		
		        if (isBuffer(value)) {
		          return cloneBuffer(value, isDeep);
		        }
		        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		          if (isHostObject(value)) {
		            return object ? value : {};
		          }
		          result = initCloneObject(isFunc ? {} : value);
		          if (!isDeep) {
		            return copySymbols(value, baseAssign(result, value));
		          }
		        } else {
		          if (!cloneableTags[tag]) {
		            return object ? value : {};
		          }
		          result = initCloneByTag(value, tag, baseClone, isDeep);
		        }
		      }
		      // Check for circular references and return its corresponding clone.
		      stack || (stack = new Stack);
		      var stacked = stack.get(value);
		      if (stacked) {
		        return stacked;
		      }
		      stack.set(value, result);
		
		      if (!isArr) {
		        var props = isFull ? getAllKeys(value) : keys(value);
		      }
		      // Recursively populate clone (susceptible to call stack limits).
		      arrayEach(props || value, function(subValue, key) {
		        if (props) {
		          key = subValue;
		          subValue = value[key];
		        }
		        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
		      });
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.conforms` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new function.
		     */
		    function baseConforms(source) {
		      var props = keys(source),
		          length = props.length;
		
		      return function(object) {
		        if (object == null) {
		          return !length;
		        }
		        var index = length;
		        while (index--) {
		          var key = props[index],
		              predicate = source[key],
		              value = object[key];
		
		          if ((value === undefined &&
		              !(key in Object(object))) || !predicate(value)) {
		            return false;
		          }
		        }
		        return true;
		      };
		    }
		
		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} prototype The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    function baseCreate(proto) {
		      return isObject(proto) ? objectCreate(proto) : {};
		    }
		
		    /**
		     * The base implementation of `_.delay` and `_.defer` which accepts an array
		     * of `func` arguments.
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {Object} args The arguments to provide to `func`.
		     * @returns {number} Returns the timer id.
		     */
		    function baseDelay(func, wait, args) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return setTimeout(function() { func.apply(undefined, args); }, wait);
		    }
		
		    /**
		     * The base implementation of methods like `_.difference` without support
		     * for excluding multiple arrays or iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Array} values The values to exclude.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     */
		    function baseDifference(array, values, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          isCommon = true,
		          length = array.length,
		          result = [],
		          valuesLength = values.length;
		
		      if (!length) {
		        return result;
		      }
		      if (iteratee) {
		        values = arrayMap(values, baseUnary(iteratee));
		      }
		      if (comparator) {
		        includes = arrayIncludesWith;
		        isCommon = false;
		      }
		      else if (values.length >= LARGE_ARRAY_SIZE) {
		        includes = cacheHas;
		        isCommon = false;
		        values = new SetCache(values);
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;
		
		        if (isCommon && computed === computed) {
		          var valuesIndex = valuesLength;
		          while (valuesIndex--) {
		            if (values[valuesIndex] === computed) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		        else if (!includes(values, computed, comparator)) {
		          result.push(value);
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.forEach` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEach = createBaseEach(baseForOwn);
		
		    /**
		     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEachRight = createBaseEach(baseForOwnRight, true);
		
		    /**
		     * The base implementation of `_.every` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`
		     */
		    function baseEvery(collection, predicate) {
		      var result = true;
		      baseEach(collection, function(value, index, collection) {
		        result = !!predicate(value, index, collection);
		        return result;
		      });
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.fill` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     */
		    function baseFill(array, value, start, end) {
		      var length = array.length;
		
		      start = toInteger(start);
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = (end === undefined || end > length) ? length : toInteger(end);
		      if (end < 0) {
		        end += length;
		      }
		      end = start > end ? 0 : toLength(end);
		      while (start < end) {
		        array[start++] = value;
		      }
		      return array;
		    }
		
		    /**
		     * The base implementation of `_.filter` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     */
		    function baseFilter(collection, predicate) {
		      var result = [];
		      baseEach(collection, function(value, index, collection) {
		        if (predicate(value, index, collection)) {
		          result.push(value);
		        }
		      });
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.flatten` with support for restricting flattening.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {number} depth The maximum recursion depth.
		     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		     * @param {Array} [result=[]] The initial result value.
		     * @returns {Array} Returns the new flattened array.
		     */
		    function baseFlatten(array, depth, predicate, isStrict, result) {
		      var index = -1,
		          length = array.length;
		
		      predicate || (predicate = isFlattenable);
		      result || (result = []);
		
		      while (++index < length) {
		        var value = array[index];
		        if (depth > 0 && predicate(value)) {
		          if (depth > 1) {
		            // Recursively flatten arrays (susceptible to call stack limits).
		            baseFlatten(value, depth - 1, predicate, isStrict, result);
		          } else {
		            arrayPush(result, value);
		          }
		        } else if (!isStrict) {
		          result[result.length] = value;
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `baseForOwn` which iterates over `object`
		     * properties returned by `keysFunc` and invokes `iteratee` for each property.
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseFor = createBaseFor();
		
		    /**
		     * This function is like `baseFor` except that it iterates over properties
		     * in the opposite order.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseForRight = createBaseFor(true);
		
		    /**
		     * The base implementation of `_.forOwn` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwn(object, iteratee) {
		      return object && baseFor(object, iteratee, keys);
		    }
		
		    /**
		     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwnRight(object, iteratee) {
		      return object && baseForRight(object, iteratee, keys);
		    }
		
		    /**
		     * The base implementation of `_.functions` which creates an array of
		     * `object` function property names filtered from `props`.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Array} props The property names to filter.
		     * @returns {Array} Returns the new array of filtered property names.
		     */
		    function baseFunctions(object, props) {
		      return arrayFilter(props, function(key) {
		        return isFunction(object[key]);
		      });
		    }
		
		    /**
		     * The base implementation of `_.get` without support for default values.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseGet(object, path) {
		      path = isKey(path, object) ? [path] : castPath(path);
		
		      var index = 0,
		          length = path.length;
		
		      while (object != null && index < length) {
		        object = object[path[index++]];
		      }
		      return (index && index == length) ? object : undefined;
		    }
		
		    /**
		     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @param {Function} symbolsFunc The function to get the symbols of `object`.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		      var result = keysFunc(object);
		      return isArray(object)
		        ? result
		        : arrayPush(result, symbolsFunc(object));
		    }
		
		    /**
		     * The base implementation of `_.has` without support for deep paths.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHas(object, key) {
		      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
		      // that are composed entirely of index properties, return `false` for
		      // `hasOwnProperty` checks of them.
		      return hasOwnProperty.call(object, key) ||
		        (typeof object == 'object' && key in object && getPrototype(object) === null);
		    }
		
		    /**
		     * The base implementation of `_.hasIn` without support for deep paths.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHasIn(object, key) {
		      return key in Object(object);
		    }
		
		    /**
		     * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
		     *
		     * @private
		     * @param {number} number The number to check.
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     */
		    function baseInRange(number, start, end) {
		      return number >= nativeMin(start, end) && number < nativeMax(start, end);
		    }
		
		    /**
		     * The base implementation of methods like `_.intersection`, without support
		     * for iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of shared values.
		     */
		    function baseIntersection(arrays, iteratee, comparator) {
		      var includes = comparator ? arrayIncludesWith : arrayIncludes,
		          length = arrays[0].length,
		          othLength = arrays.length,
		          othIndex = othLength,
		          caches = Array(othLength),
		          maxLength = Infinity,
		          result = [];
		
		      while (othIndex--) {
		        var array = arrays[othIndex];
		        if (othIndex && iteratee) {
		          array = arrayMap(array, baseUnary(iteratee));
		        }
		        maxLength = nativeMin(array.length, maxLength);
		        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
		          ? new SetCache(othIndex && array)
		          : undefined;
		      }
		      array = arrays[0];
		
		      var index = -1,
		          seen = caches[0];
		
		      outer:
		      while (++index < length && result.length < maxLength) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;
		
		        if (!(seen
		              ? cacheHas(seen, computed)
		              : includes(result, computed, comparator)
		            )) {
		          othIndex = othLength;
		          while (--othIndex) {
		            var cache = caches[othIndex];
		            if (!(cache
		                  ? cacheHas(cache, computed)
		                  : includes(arrays[othIndex], computed, comparator))
		                ) {
		              continue outer;
		            }
		          }
		          if (seen) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.invert` and `_.invertBy` which inverts
		     * `object` with values transformed by `iteratee` and set by `setter`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform values.
		     * @param {Object} accumulator The initial inverted object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseInverter(object, setter, iteratee, accumulator) {
		      baseForOwn(object, function(value, key, object) {
		        setter(accumulator, iteratee(value), key, object);
		      });
		      return accumulator;
		    }
		
		    /**
		     * The base implementation of `_.invoke` without support for individual
		     * method arguments.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {Array} args The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     */
		    function baseInvoke(object, path, args) {
		      if (!isKey(path, object)) {
		        path = castPath(path);
		        object = parent(object, path);
		        path = last(path);
		      }
		      var func = object == null ? object : object[path];
		      return func == null ? undefined : apply(func, object, args);
		    }
		
		    /**
		     * The base implementation of `_.isEqual` which supports partial comparisons
		     * and tracks traversed objects.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {boolean} [bitmask] The bitmask of comparison flags.
		     *  The bitmask may be composed of the following flags:
		     *     1 - Unordered comparison
		     *     2 - Partial comparison
		     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(value, other, customizer, bitmask, stack) {
		      if (value === other) {
		        return true;
		      }
		      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
		        return value !== value && other !== other;
		      }
		      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
		    }
		
		    /**
		     * A specialized version of `baseIsEqual` for arrays and objects which performs
		     * deep comparisons and tracks traversed objects enabling objects with circular
		     * references to be compared.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
		     *  for more details.
		     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
		      var objIsArr = isArray(object),
		          othIsArr = isArray(other),
		          objTag = arrayTag,
		          othTag = arrayTag;
		
		      if (!objIsArr) {
		        objTag = getTag(object);
		        objTag = objTag == argsTag ? objectTag : objTag;
		      }
		      if (!othIsArr) {
		        othTag = getTag(other);
		        othTag = othTag == argsTag ? objectTag : othTag;
		      }
		      var objIsObj = objTag == objectTag && !isHostObject(object),
		          othIsObj = othTag == objectTag && !isHostObject(other),
		          isSameTag = objTag == othTag;
		
		      if (isSameTag && !objIsObj) {
		        stack || (stack = new Stack);
		        return (objIsArr || isTypedArray(object))
		          ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
		          : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
		      }
		      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
		        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
		
		        if (objIsWrapped || othIsWrapped) {
		          var objUnwrapped = objIsWrapped ? object.value() : object,
		              othUnwrapped = othIsWrapped ? other.value() : other;
		
		          stack || (stack = new Stack);
		          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
		        }
		      }
		      if (!isSameTag) {
		        return false;
		      }
		      stack || (stack = new Stack);
		      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
		    }
		
		    /**
		     * The base implementation of `_.isMatch` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Array} matchData The property names, values, and compare flags to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     */
		    function baseIsMatch(object, source, matchData, customizer) {
		      var index = matchData.length,
		          length = index,
		          noCustomizer = !customizer;
		
		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (index--) {
		        var data = matchData[index];
		        if ((noCustomizer && data[2])
		              ? data[1] !== object[data[0]]
		              : !(data[0] in object)
		            ) {
		          return false;
		        }
		      }
		      while (++index < length) {
		        data = matchData[index];
		        var key = data[0],
		            objValue = object[key],
		            srcValue = data[1];
		
		        if (noCustomizer && data[2]) {
		          if (objValue === undefined && !(key in object)) {
		            return false;
		          }
		        } else {
		          var stack = new Stack;
		          if (customizer) {
		            var result = customizer(objValue, srcValue, key, object, source, stack);
		          }
		          if (!(result === undefined
		                ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
		                : result
		              )) {
		            return false;
		          }
		        }
		      }
		      return true;
		    }
		
		    /**
		     * The base implementation of `_.iteratee`.
		     *
		     * @private
		     * @param {*} [value=_.identity] The value to convert to an iteratee.
		     * @returns {Function} Returns the iteratee.
		     */
		    function baseIteratee(value) {
		      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		      if (typeof value == 'function') {
		        return value;
		      }
		      if (value == null) {
		        return identity;
		      }
		      if (typeof value == 'object') {
		        return isArray(value)
		          ? baseMatchesProperty(value[0], value[1])
		          : baseMatches(value);
		      }
		      return property(value);
		    }
		
		    /**
		     * The base implementation of `_.keys` which doesn't skip the constructor
		     * property of prototypes or treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeys(object) {
		      return nativeKeys(Object(object));
		    }
		
		    /**
		     * The base implementation of `_.keysIn` which doesn't skip the constructor
		     * property of prototypes or treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeysIn(object) {
		      object = object == null ? object : Object(object);
		
		      var result = [];
		      for (var key in object) {
		        result.push(key);
		      }
		      return result;
		    }
		
		    // Fallback for IE < 9 with es6-shim.
		    if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
		      baseKeysIn = function(object) {
		        return iteratorToArray(enumerate(object));
		      };
		    }
		
		    /**
		     * The base implementation of `_.map` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     */
		    function baseMap(collection, iteratee) {
		      var index = -1,
		          result = isArrayLike(collection) ? Array(collection.length) : [];
		
		      baseEach(collection, function(value, key, collection) {
		        result[++index] = iteratee(value, key, collection);
		      });
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.matches` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new function.
		     */
		    function baseMatches(source) {
		      var matchData = getMatchData(source);
		      if (matchData.length == 1 && matchData[0][2]) {
		        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		      }
		      return function(object) {
		        return object === source || baseIsMatch(object, source, matchData);
		      };
		    }
		
		    /**
		     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		     *
		     * @private
		     * @param {string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new function.
		     */
		    function baseMatchesProperty(path, srcValue) {
		      if (isKey(path) && isStrictComparable(srcValue)) {
		        return matchesStrictComparable(path, srcValue);
		      }
		      return function(object) {
		        var objValue = get(object, path);
		        return (objValue === undefined && objValue === srcValue)
		          ? hasIn(object, path)
		          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
		      };
		    }
		
		    /**
		     * The base implementation of `_.merge` without support for multiple sources.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} [customizer] The function to customize merged values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMerge(object, source, srcIndex, customizer, stack) {
		      if (object === source) {
		        return;
		      }
		      if (!(isArray(source) || isTypedArray(source))) {
		        var props = keysIn(source);
		      }
		      arrayEach(props || source, function(srcValue, key) {
		        if (props) {
		          key = srcValue;
		          srcValue = source[key];
		        }
		        if (isObject(srcValue)) {
		          stack || (stack = new Stack);
		          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		        }
		        else {
		          var newValue = customizer
		            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
		            : undefined;
		
		          if (newValue === undefined) {
		            newValue = srcValue;
		          }
		          assignMergeValue(object, key, newValue);
		        }
		      });
		    }
		
		    /**
		     * A specialized version of `baseMerge` for arrays and objects which performs
		     * deep merges and tracks traversed objects enabling objects with circular
		     * references to be merged.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {string} key The key of the value to merge.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} mergeFunc The function to merge values.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
		      var objValue = object[key],
		          srcValue = source[key],
		          stacked = stack.get(srcValue);
		
		      if (stacked) {
		        assignMergeValue(object, key, stacked);
		        return;
		      }
		      var newValue = customizer
		        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
		        : undefined;
		
		      var isCommon = newValue === undefined;
		
		      if (isCommon) {
		        newValue = srcValue;
		        if (isArray(srcValue) || isTypedArray(srcValue)) {
		          if (isArray(objValue)) {
		            newValue = objValue;
		          }
		          else if (isArrayLikeObject(objValue)) {
		            newValue = copyArray(objValue);
		          }
		          else {
		            isCommon = false;
		            newValue = baseClone(srcValue, true);
		          }
		        }
		        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
		          if (isArguments(objValue)) {
		            newValue = toPlainObject(objValue);
		          }
		          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
		            isCommon = false;
		            newValue = baseClone(srcValue, true);
		          }
		          else {
		            newValue = objValue;
		          }
		        }
		        else {
		          isCommon = false;
		        }
		      }
		      stack.set(srcValue, newValue);
		
		      if (isCommon) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		      }
		      stack['delete'](srcValue);
		      assignMergeValue(object, key, newValue);
		    }
		
		    /**
		     * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {number} n The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     */
		    function baseNth(array, n) {
		      var length = array.length;
		      if (!length) {
		        return;
		      }
		      n += n < 0 ? length : 0;
		      return isIndex(n, length) ? array[n] : undefined;
		    }
		
		    /**
		     * The base implementation of `_.orderBy` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
		     * @param {string[]} orders The sort orders of `iteratees`.
		     * @returns {Array} Returns the new sorted array.
		     */
		    function baseOrderBy(collection, iteratees, orders) {
		      var index = -1;
		      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
		
		      var result = baseMap(collection, function(value, key, collection) {
		        var criteria = arrayMap(iteratees, function(iteratee) {
		          return iteratee(value);
		        });
		        return { 'criteria': criteria, 'index': ++index, 'value': value };
		      });
		
		      return baseSortBy(result, function(object, other) {
		        return compareMultiple(object, other, orders);
		      });
		    }
		
		    /**
		     * The base implementation of `_.pick` without support for individual
		     * property identifiers.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} props The property identifiers to pick.
		     * @returns {Object} Returns the new object.
		     */
		    function basePick(object, props) {
		      object = Object(object);
		      return arrayReduce(props, function(result, key) {
		        if (key in object) {
		          result[key] = object[key];
		        }
		        return result;
		      }, {});
		    }
		
		    /**
		     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {Function} predicate The function invoked per property.
		     * @returns {Object} Returns the new object.
		     */
		    function basePickBy(object, predicate) {
		      var index = -1,
		          props = getAllKeysIn(object),
		          length = props.length,
		          result = {};
		
		      while (++index < length) {
		        var key = props[index],
		            value = object[key];
		
		        if (predicate(value, key)) {
		          result[key] = value;
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.property` without support for deep paths.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @returns {Function} Returns the new function.
		     */
		    function baseProperty(key) {
		      return function(object) {
		        return object == null ? undefined : object[key];
		      };
		    }
		
		    /**
		     * A specialized version of `baseProperty` which supports deep paths.
		     *
		     * @private
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new function.
		     */
		    function basePropertyDeep(path) {
		      return function(object) {
		        return baseGet(object, path);
		      };
		    }
		
		    /**
		     * The base implementation of `_.pullAllBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAll(array, values, iteratee, comparator) {
		      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
		          index = -1,
		          length = values.length,
		          seen = array;
		
		      if (iteratee) {
		        seen = arrayMap(array, baseUnary(iteratee));
		      }
		      while (++index < length) {
		        var fromIndex = 0,
		            value = values[index],
		            computed = iteratee ? iteratee(value) : value;
		
		        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
		          if (seen !== array) {
		            splice.call(seen, fromIndex, 1);
		          }
		          splice.call(array, fromIndex, 1);
		        }
		      }
		      return array;
		    }
		
		    /**
		     * The base implementation of `_.pullAt` without support for individual
		     * indexes or capturing the removed elements.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {number[]} indexes The indexes of elements to remove.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAt(array, indexes) {
		      var length = array ? indexes.length : 0,
		          lastIndex = length - 1;
		
		      while (length--) {
		        var index = indexes[length];
		        if (lastIndex == length || index != previous) {
		          var previous = index;
		          if (isIndex(index)) {
		            splice.call(array, index, 1);
		          }
		          else if (!isKey(index, array)) {
		            var path = castPath(index),
		                object = parent(array, path);
		
		            if (object != null) {
		              delete object[last(path)];
		            }
		          }
		          else {
		            delete array[index];
		          }
		        }
		      }
		      return array;
		    }
		
		    /**
		     * The base implementation of `_.random` without support for returning
		     * floating-point numbers.
		     *
		     * @private
		     * @param {number} lower The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the random number.
		     */
		    function baseRandom(lower, upper) {
		      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
		    }
		
		    /**
		     * The base implementation of `_.range` and `_.rangeRight` which doesn't
		     * coerce arguments to numbers.
		     *
		     * @private
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} step The value to increment or decrement by.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the new array of numbers.
		     */
		    function baseRange(start, end, step, fromRight) {
		      var index = -1,
		          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
		          result = Array(length);
		
		      while (length--) {
		        result[fromRight ? length : ++index] = start;
		        start += step;
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.repeat` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {string} string The string to repeat.
		     * @param {number} n The number of times to repeat the string.
		     * @returns {string} Returns the repeated string.
		     */
		    function baseRepeat(string, n) {
		      var result = '';
		      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		        return result;
		      }
		      // Leverage the exponentiation by squaring algorithm for a faster repeat.
		      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
		      do {
		        if (n % 2) {
		          result += string;
		        }
		        n = nativeFloor(n / 2);
		        if (n) {
		          string += string;
		        }
		      } while (n);
		
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.set`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseSet(object, path, value, customizer) {
		      path = isKey(path, object) ? [path] : castPath(path);
		
		      var index = -1,
		          length = path.length,
		          lastIndex = length - 1,
		          nested = object;
		
		      while (nested != null && ++index < length) {
		        var key = path[index];
		        if (isObject(nested)) {
		          var newValue = value;
		          if (index != lastIndex) {
		            var objValue = nested[key];
		            newValue = customizer ? customizer(objValue, key, nested) : undefined;
		            if (newValue === undefined) {
		              newValue = objValue == null
		                ? (isIndex(path[index + 1]) ? [] : {})
		                : objValue;
		            }
		          }
		          assignValue(nested, key, newValue);
		        }
		        nested = nested[key];
		      }
		      return object;
		    }
		
		    /**
		     * The base implementation of `setData` without support for hot loop detection.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetData = !metaMap ? identity : function(func, data) {
		      metaMap.set(func, data);
		      return func;
		    };
		
		    /**
		     * The base implementation of `_.slice` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseSlice(array, start, end) {
		      var index = -1,
		          length = array.length;
		
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = end > length ? length : end;
		      if (end < 0) {
		        end += length;
		      }
		      length = start > end ? 0 : ((end - start) >>> 0);
		      start >>>= 0;
		
		      var result = Array(length);
		      while (++index < length) {
		        result[index] = array[index + start];
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.some` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     */
		    function baseSome(collection, predicate) {
		      var result;
		
		      baseEach(collection, function(value, index, collection) {
		        result = predicate(value, index, collection);
		        return !result;
		      });
		      return !!result;
		    }
		
		    /**
		     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
		     * performs a binary search of `array` to determine the index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndex(array, value, retHighest) {
		      var low = 0,
		          high = array ? array.length : low;
		
		      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		        while (low < high) {
		          var mid = (low + high) >>> 1,
		              computed = array[mid];
		
		          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
		            low = mid + 1;
		          } else {
		            high = mid;
		          }
		        }
		        return high;
		      }
		      return baseSortedIndexBy(array, value, identity, retHighest);
		    }
		
		    /**
		     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
		     * which invokes `iteratee` for `value` and each element of `array` to compute
		     * their sort ranking. The iteratee is invoked with one argument; (value).
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} iteratee The iteratee invoked per element.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndexBy(array, value, iteratee, retHighest) {
		      value = iteratee(value);
		
		      var low = 0,
		          high = array ? array.length : 0,
		          valIsNaN = value !== value,
		          valIsNull = value === null,
		          valIsUndef = value === undefined;
		
		      while (low < high) {
		        var mid = nativeFloor((low + high) / 2),
		            computed = iteratee(array[mid]),
		            isDef = computed !== undefined,
		            isReflexive = computed === computed;
		
		        if (valIsNaN) {
		          var setLow = isReflexive || retHighest;
		        } else if (valIsNull) {
		          setLow = isReflexive && isDef && (retHighest || computed != null);
		        } else if (valIsUndef) {
		          setLow = isReflexive && (retHighest || isDef);
		        } else if (computed == null) {
		          setLow = false;
		        } else {
		          setLow = retHighest ? (computed <= value) : (computed < value);
		        }
		        if (setLow) {
		          low = mid + 1;
		        } else {
		          high = mid;
		        }
		      }
		      return nativeMin(high, MAX_ARRAY_INDEX);
		    }
		
		    /**
		     * The base implementation of `_.sortedUniq`.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniq(array) {
		      return baseSortedUniqBy(array);
		    }
		
		    /**
		     * The base implementation of `_.sortedUniqBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniqBy(array, iteratee) {
		      var index = 0,
		          length = array.length,
		          value = array[0],
		          computed = iteratee ? iteratee(value) : value,
		          seen = computed,
		          resIndex = 1,
		          result = [value];
		
		      while (++index < length) {
		        value = array[index],
		        computed = iteratee ? iteratee(value) : value;
		
		        if (!eq(computed, seen)) {
		          seen = computed;
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseUniq(array, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          length = array.length,
		          isCommon = true,
		          result = [],
		          seen = result;
		
		      if (comparator) {
		        isCommon = false;
		        includes = arrayIncludesWith;
		      }
		      else if (length >= LARGE_ARRAY_SIZE) {
		        var set = iteratee ? null : createSet(array);
		        if (set) {
		          return setToArray(set);
		        }
		        isCommon = false;
		        includes = cacheHas;
		        seen = new SetCache;
		      }
		      else {
		        seen = iteratee ? [] : result;
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;
		
		        if (isCommon && computed === computed) {
		          var seenIndex = seen.length;
		          while (seenIndex--) {
		            if (seen[seenIndex] === computed) {
		              continue outer;
		            }
		          }
		          if (iteratee) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		        else if (!includes(seen, computed, comparator)) {
		          if (seen !== result) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The base implementation of `_.unset`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     */
		    function baseUnset(object, path) {
		      path = isKey(path, object) ? [path] : castPath(path);
		      object = parent(object, path);
		      var key = last(path);
		      return (object != null && has(object, key)) ? delete object[key] : true;
		    }
		
		    /**
		     * The base implementation of `_.update`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to update.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseUpdate(object, path, updater, customizer) {
		      return baseSet(object, path, updater(baseGet(object, path)), customizer);
		    }
		
		    /**
		     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
		     * without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {Function} predicate The function invoked per iteration.
		     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseWhile(array, predicate, isDrop, fromRight) {
		      var length = array.length,
		          index = fromRight ? length : -1;
		
		      while ((fromRight ? index-- : ++index < length) &&
		        predicate(array[index], index, array)) {}
		
		      return isDrop
		        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
		        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
		    }
		
		    /**
		     * The base implementation of `wrapperValue` which returns the result of
		     * performing a sequence of actions on the unwrapped `value`, where each
		     * successive action is supplied the return value of the previous.
		     *
		     * @private
		     * @param {*} value The unwrapped value.
		     * @param {Array} actions Actions to perform to resolve the unwrapped value.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseWrapperValue(value, actions) {
		      var result = value;
		      if (result instanceof LazyWrapper) {
		        result = result.value();
		      }
		      return arrayReduce(actions, function(result, action) {
		        return action.func.apply(action.thisArg, arrayPush([result], action.args));
		      }, result);
		    }
		
		    /**
		     * The base implementation of methods like `_.xor`, without support for
		     * iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     */
		    function baseXor(arrays, iteratee, comparator) {
		      var index = -1,
		          length = arrays.length;
		
		      while (++index < length) {
		        var result = result
		          ? arrayPush(
		              baseDifference(result, arrays[index], iteratee, comparator),
		              baseDifference(arrays[index], result, iteratee, comparator)
		            )
		          : arrays[index];
		      }
		      return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
		    }
		
		    /**
		     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
		     *
		     * @private
		     * @param {Array} props The property identifiers.
		     * @param {Array} values The property values.
		     * @param {Function} assignFunc The function to assign values.
		     * @returns {Object} Returns the new object.
		     */
		    function baseZipObject(props, values, assignFunc) {
		      var index = -1,
		          length = props.length,
		          valsLength = values.length,
		          result = {};
		
		      while (++index < length) {
		        var value = index < valsLength ? values[index] : undefined;
		        assignFunc(result, props[index], value);
		      }
		      return result;
		    }
		
		    /**
		     * Casts `value` to an empty array if it's not an array like object.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array|Object} Returns the cast array-like object.
		     */
		    function castArrayLikeObject(value) {
		      return isArrayLikeObject(value) ? value : [];
		    }
		
		    /**
		     * Casts `value` to `identity` if it's not a function.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Function} Returns cast function.
		     */
		    function castFunction(value) {
		      return typeof value == 'function' ? value : identity;
		    }
		
		    /**
		     * Casts `value` to a path array if it's not one.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast property path array.
		     */
		    function castPath(value) {
		      return isArray(value) ? value : stringToPath(value);
		    }
		
		    /**
		     * Casts `array` to a slice if it's needed.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {number} start The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the cast slice.
		     */
		    function castSlice(array, start, end) {
		      var length = array.length;
		      end = end === undefined ? length : end;
		      return (!start && end >= length) ? array : baseSlice(array, start, end);
		    }
		
		    /**
		     * Creates a clone of  `buffer`.
		     *
		     * @private
		     * @param {Buffer} buffer The buffer to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Buffer} Returns the cloned buffer.
		     */
		    function cloneBuffer(buffer, isDeep) {
		      if (isDeep) {
		        return buffer.slice();
		      }
		      var result = new buffer.constructor(buffer.length);
		      buffer.copy(result);
		      return result;
		    }
		
		    /**
		     * Creates a clone of `arrayBuffer`.
		     *
		     * @private
		     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		     * @returns {ArrayBuffer} Returns the cloned array buffer.
		     */
		    function cloneArrayBuffer(arrayBuffer) {
		      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		      return result;
		    }
		
		    /**
		     * Creates a clone of `dataView`.
		     *
		     * @private
		     * @param {Object} dataView The data view to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned data view.
		     */
		    function cloneDataView(dataView, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		    }
		
		    /**
		     * Creates a clone of `map`.
		     *
		     * @private
		     * @param {Object} map The map to clone.
		     * @param {Function} cloneFunc The function to clone values.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned map.
		     */
		    function cloneMap(map, isDeep, cloneFunc) {
		      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
		      return arrayReduce(array, addMapEntry, new map.constructor);
		    }
		
		    /**
		     * Creates a clone of `regexp`.
		     *
		     * @private
		     * @param {Object} regexp The regexp to clone.
		     * @returns {Object} Returns the cloned regexp.
		     */
		    function cloneRegExp(regexp) {
		      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		      result.lastIndex = regexp.lastIndex;
		      return result;
		    }
		
		    /**
		     * Creates a clone of `set`.
		     *
		     * @private
		     * @param {Object} set The set to clone.
		     * @param {Function} cloneFunc The function to clone values.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned set.
		     */
		    function cloneSet(set, isDeep, cloneFunc) {
		      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
		      return arrayReduce(array, addSetEntry, new set.constructor);
		    }
		
		    /**
		     * Creates a clone of the `symbol` object.
		     *
		     * @private
		     * @param {Object} symbol The symbol object to clone.
		     * @returns {Object} Returns the cloned symbol object.
		     */
		    function cloneSymbol(symbol) {
		      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		    }
		
		    /**
		     * Creates a clone of `typedArray`.
		     *
		     * @private
		     * @param {Object} typedArray The typed array to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned typed array.
		     */
		    function cloneTypedArray(typedArray, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		    }
		
		    /**
		     * Creates an array that is the composition of partially applied arguments,
		     * placeholders, and provided arguments into a single array of arguments.
		     *
		     * @private
		     * @param {Array|Object} args The provided arguments.
		     * @param {Array} partials The arguments to prepend to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgs(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersLength = holders.length,
		          leftIndex = -1,
		          leftLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(leftLength + rangeLength),
		          isUncurried = !isCurried;
		
		      while (++leftIndex < leftLength) {
		        result[leftIndex] = partials[leftIndex];
		      }
		      while (++argsIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[holders[argsIndex]] = args[argsIndex];
		        }
		      }
		      while (rangeLength--) {
		        result[leftIndex++] = args[argsIndex++];
		      }
		      return result;
		    }
		
		    /**
		     * This function is like `composeArgs` except that the arguments composition
		     * is tailored for `_.partialRight`.
		     *
		     * @private
		     * @param {Array|Object} args The provided arguments.
		     * @param {Array} partials The arguments to append to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgsRight(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersIndex = -1,
		          holdersLength = holders.length,
		          rightIndex = -1,
		          rightLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(rangeLength + rightLength),
		          isUncurried = !isCurried;
		
		      while (++argsIndex < rangeLength) {
		        result[argsIndex] = args[argsIndex];
		      }
		      var offset = argsIndex;
		      while (++rightIndex < rightLength) {
		        result[offset + rightIndex] = partials[rightIndex];
		      }
		      while (++holdersIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[offset + holders[holdersIndex]] = args[argsIndex++];
		        }
		      }
		      return result;
		    }
		
		    /**
		     * Copies the values of `source` to `array`.
		     *
		     * @private
		     * @param {Array} source The array to copy values from.
		     * @param {Array} [array=[]] The array to copy values to.
		     * @returns {Array} Returns `array`.
		     */
		    function copyArray(source, array) {
		      var index = -1,
		          length = source.length;
		
		      array || (array = Array(length));
		      while (++index < length) {
		        array[index] = source[index];
		      }
		      return array;
		    }
		
		    /**
		     * Copies properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy properties from.
		     * @param {Array} props The property identifiers to copy.
		     * @param {Object} [object={}] The object to copy properties to.
		     * @param {Function} [customizer] The function to customize copied values.
		     * @returns {Object} Returns `object`.
		     */
		    function copyObject(source, props, object, customizer) {
		      object || (object = {});
		
		      var index = -1,
		          length = props.length;
		
		      while (++index < length) {
		        var key = props[index];
		
		        var newValue = customizer
		          ? customizer(object[key], source[key], key, object, source)
		          : source[key];
		
		        assignValue(object, key, newValue);
		      }
		      return object;
		    }
		
		    /**
		     * Copies own symbol properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbols(source, object) {
		      return copyObject(source, getSymbols(source), object);
		    }
		
		    /**
		     * Creates a function like `_.groupBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} [initializer] The accumulator object initializer.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter, initializer) {
		      return function(collection, iteratee) {
		        var func = isArray(collection) ? arrayAggregator : baseAggregator,
		            accumulator = initializer ? initializer() : {};
		
		        return func(collection, setter, getIteratee(iteratee), accumulator);
		      };
		    }
		
		    /**
		     * Creates a function like `_.assign`.
		     *
		     * @private
		     * @param {Function} assigner The function to assign values.
		     * @returns {Function} Returns the new assigner function.
		     */
		    function createAssigner(assigner) {
		      return rest(function(object, sources) {
		        var index = -1,
		            length = sources.length,
		            customizer = length > 1 ? sources[length - 1] : undefined,
		            guard = length > 2 ? sources[2] : undefined;
		
		        customizer = typeof customizer == 'function'
		          ? (length--, customizer)
		          : undefined;
		
		        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		          customizer = length < 3 ? undefined : customizer;
		          length = 1;
		        }
		        object = Object(object);
		        while (++index < length) {
		          var source = sources[index];
		          if (source) {
		            assigner(object, source, index, customizer);
		          }
		        }
		        return object;
		      });
		    }
		
		    /**
		     * Creates a `baseEach` or `baseEachRight` function.
		     *
		     * @private
		     * @param {Function} eachFunc The function to iterate over a collection.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseEach(eachFunc, fromRight) {
		      return function(collection, iteratee) {
		        if (collection == null) {
		          return collection;
		        }
		        if (!isArrayLike(collection)) {
		          return eachFunc(collection, iteratee);
		        }
		        var length = collection.length,
		            index = fromRight ? length : -1,
		            iterable = Object(collection);
		
		        while ((fromRight ? index-- : ++index < length)) {
		          if (iteratee(iterable[index], index, iterable) === false) {
		            break;
		          }
		        }
		        return collection;
		      };
		    }
		
		    /**
		     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseFor(fromRight) {
		      return function(object, iteratee, keysFunc) {
		        var index = -1,
		            iterable = Object(object),
		            props = keysFunc(object),
		            length = props.length;
		
		        while (length--) {
		          var key = props[fromRight ? length : ++index];
		          if (iteratee(iterable[key], key, iterable) === false) {
		            break;
		          }
		        }
		        return object;
		      };
		    }
		
		    /**
		     * Creates a function that wraps `func` to invoke it with the optional `this`
		     * binding of `thisArg`.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
		     *  for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createBaseWrapper(func, bitmask, thisArg) {
		      var isBind = bitmask & BIND_FLAG,
		          Ctor = createCtorWrapper(func);
		
		      function wrapper() {
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return fn.apply(isBind ? thisArg : this, arguments);
		      }
		      return wrapper;
		    }
		
		    /**
		     * Creates a function like `_.lowerFirst`.
		     *
		     * @private
		     * @param {string} methodName The name of the `String` case method to use.
		     * @returns {Function} Returns the new function.
		     */
		    function createCaseFirst(methodName) {
		      return function(string) {
		        string = toString(string);
		
		        var strSymbols = reHasComplexSymbol.test(string)
		          ? stringToArray(string)
		          : undefined;
		
		        var chr = strSymbols
		          ? strSymbols[0]
		          : string.charAt(0);
		
		        var trailing = strSymbols
		          ? castSlice(strSymbols, 1).join('')
		          : string.slice(1);
		
		        return chr[methodName]() + trailing;
		      };
		    }
		
		    /**
		     * Creates a function like `_.camelCase`.
		     *
		     * @private
		     * @param {Function} callback The function to combine each word.
		     * @returns {Function} Returns the new compounder function.
		     */
		    function createCompounder(callback) {
		      return function(string) {
		        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
		      };
		    }
		
		    /**
		     * Creates a function that produces an instance of `Ctor` regardless of
		     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
		     *
		     * @private
		     * @param {Function} Ctor The constructor to wrap.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCtorWrapper(Ctor) {
		      return function() {
		        // Use a `switch` statement to work with class constructors. See
		        // http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
		        // for more details.
		        var args = arguments;
		        switch (args.length) {
		          case 0: return new Ctor;
		          case 1: return new Ctor(args[0]);
		          case 2: return new Ctor(args[0], args[1]);
		          case 3: return new Ctor(args[0], args[1], args[2]);
		          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
		          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
		          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
		          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		        }
		        var thisBinding = baseCreate(Ctor.prototype),
		            result = Ctor.apply(thisBinding, args);
		
		        // Mimic the constructor's `return` behavior.
		        // See https://es5.github.io/#x13.2.2 for more details.
		        return isObject(result) ? result : thisBinding;
		      };
		    }
		
		    /**
		     * Creates a function that wraps `func` to enable currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
		     *  for more details.
		     * @param {number} arity The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCurryWrapper(func, bitmask, arity) {
		      var Ctor = createCtorWrapper(func);
		
		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length,
		            placeholder = getPlaceholder(wrapper);
		
		        while (index--) {
		          args[index] = arguments[index];
		        }
		        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
		          ? []
		          : replaceHolders(args, placeholder);
		
		        length -= holders.length;
		        if (length < arity) {
		          return createRecurryWrapper(
		            func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
		            args, holders, undefined, undefined, arity - length);
		        }
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return apply(fn, this, args);
		      }
		      return wrapper;
		    }
		
		    /**
		     * Creates a `_.flow` or `_.flowRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new flow function.
		     */
		    function createFlow(fromRight) {
		      return rest(function(funcs) {
		        funcs = baseFlatten(funcs, 1);
		
		        var length = funcs.length,
		            index = length,
		            prereq = LodashWrapper.prototype.thru;
		
		        if (fromRight) {
		          funcs.reverse();
		        }
		        while (index--) {
		          var func = funcs[index];
		          if (typeof func != 'function') {
		            throw new TypeError(FUNC_ERROR_TEXT);
		          }
		          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
		            var wrapper = new LodashWrapper([], true);
		          }
		        }
		        index = wrapper ? index : length;
		        while (++index < length) {
		          func = funcs[index];
		
		          var funcName = getFuncName(func),
		              data = funcName == 'wrapper' ? getData(func) : undefined;
		
		          if (data && isLaziable(data[0]) &&
		                data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&
		                !data[4].length && data[9] == 1
		              ) {
		            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
		          } else {
		            wrapper = (func.length == 1 && isLaziable(func))
		              ? wrapper[funcName]()
		              : wrapper.thru(func);
		          }
		        }
		        return function() {
		          var args = arguments,
		              value = args[0];
		
		          if (wrapper && args.length == 1 &&
		              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
		            return wrapper.plant(value).value();
		          }
		          var index = 0,
		              result = length ? funcs[index].apply(this, args) : value;
		
		          while (++index < length) {
		            result = funcs[index].call(this, result);
		          }
		          return result;
		        };
		      });
		    }
		
		    /**
		     * Creates a function that wraps `func` to invoke it with optional `this`
		     * binding of `thisArg`, partial application, and currying.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
		     *  for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [partialsRight] The arguments to append to those provided
		     *  to the new function.
		     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
		      var isAry = bitmask & ARY_FLAG,
		          isBind = bitmask & BIND_FLAG,
		          isBindKey = bitmask & BIND_KEY_FLAG,
		          isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
		          isFlip = bitmask & FLIP_FLAG,
		          Ctor = isBindKey ? undefined : createCtorWrapper(func);
		
		      function wrapper() {
		        var length = arguments.length,
		            index = length,
		            args = Array(length);
		
		        while (index--) {
		          args[index] = arguments[index];
		        }
		        if (isCurried) {
		          var placeholder = getPlaceholder(wrapper),
		              holdersCount = countHolders(args, placeholder);
		        }
		        if (partials) {
		          args = composeArgs(args, partials, holders, isCurried);
		        }
		        if (partialsRight) {
		          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		        }
		        length -= holdersCount;
		        if (isCurried && length < arity) {
		          var newHolders = replaceHolders(args, placeholder);
		          return createRecurryWrapper(
		            func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
		            args, newHolders, argPos, ary, arity - length
		          );
		        }
		        var thisBinding = isBind ? thisArg : this,
		            fn = isBindKey ? thisBinding[func] : func;
		
		        length = args.length;
		        if (argPos) {
		          args = reorder(args, argPos);
		        } else if (isFlip && length > 1) {
		          args.reverse();
		        }
		        if (isAry && ary < length) {
		          args.length = ary;
		        }
		        if (this && this !== root && this instanceof wrapper) {
		          fn = Ctor || createCtorWrapper(fn);
		        }
		        return fn.apply(thisBinding, args);
		      }
		      return wrapper;
		    }
		
		    /**
		     * Creates a function like `_.invertBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} toIteratee The function to resolve iteratees.
		     * @returns {Function} Returns the new inverter function.
		     */
		    function createInverter(setter, toIteratee) {
		      return function(object, iteratee) {
		        return baseInverter(object, setter, toIteratee(iteratee), {});
		      };
		    }
		
		    /**
		     * Creates a function like `_.over`.
		     *
		     * @private
		     * @param {Function} arrayFunc The function to iterate over iteratees.
		     * @returns {Function} Returns the new invoker function.
		     */
		    function createOver(arrayFunc) {
		      return rest(function(iteratees) {
		        iteratees = (iteratees.length == 1 && isArray(iteratees[0]))
		          ? arrayMap(iteratees[0], baseUnary(getIteratee()))
		          : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));
		
		        return rest(function(args) {
		          var thisArg = this;
		          return arrayFunc(iteratees, function(iteratee) {
		            return apply(iteratee, thisArg, args);
		          });
		        });
		      });
		    }
		
		    /**
		     * Creates the padding for `string` based on `length`. The `chars` string
		     * is truncated if the number of characters exceeds `length`.
		     *
		     * @private
		     * @param {number} length The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padding for `string`.
		     */
		    function createPadding(length, chars) {
		      chars = chars === undefined ? ' ' : (chars + '');
		
		      var charsLength = chars.length;
		      if (charsLength < 2) {
		        return charsLength ? baseRepeat(chars, length) : chars;
		      }
		      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
		      return reHasComplexSymbol.test(chars)
		        ? castSlice(stringToArray(result), 0, length).join('')
		        : result.slice(0, length);
		    }
		
		    /**
		     * Creates a function that wraps `func` to invoke it with the `this` binding
		     * of `thisArg` and `partials` prepended to the arguments it receives.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
		     *  for more details.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {Array} partials The arguments to prepend to those provided to
		     *  the new function.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createPartialWrapper(func, bitmask, thisArg, partials) {
		      var isBind = bitmask & BIND_FLAG,
		          Ctor = createCtorWrapper(func);
		
		      function wrapper() {
		        var argsIndex = -1,
		            argsLength = arguments.length,
		            leftIndex = -1,
		            leftLength = partials.length,
		            args = Array(leftLength + argsLength),
		            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		
		        while (++leftIndex < leftLength) {
		          args[leftIndex] = partials[leftIndex];
		        }
		        while (argsLength--) {
		          args[leftIndex++] = arguments[++argsIndex];
		        }
		        return apply(fn, isBind ? thisArg : this, args);
		      }
		      return wrapper;
		    }
		
		    /**
		     * Creates a `_.range` or `_.rangeRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new range function.
		     */
		    function createRange(fromRight) {
		      return function(start, end, step) {
		        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
		          end = step = undefined;
		        }
		        // Ensure the sign of `-0` is preserved.
		        start = toNumber(start);
		        start = start === start ? start : 0;
		        if (end === undefined) {
		          end = start;
		          start = 0;
		        } else {
		          end = toNumber(end) || 0;
		        }
		        step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);
		        return baseRange(start, end, step, fromRight);
		      };
		    }
		
		    /**
		     * Creates a function that wraps `func` to continue currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
		     *  for more details.
		     * @param {Function} wrapFunc The function to create the `func` wrapper.
		     * @param {*} placeholder The placeholder value.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
		      var isCurry = bitmask & CURRY_FLAG,
		          newHolders = isCurry ? holders : undefined,
		          newHoldersRight = isCurry ? undefined : holders,
		          newPartials = isCurry ? partials : undefined,
		          newPartialsRight = isCurry ? undefined : partials;
		
		      bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
		      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
		
		      if (!(bitmask & CURRY_BOUND_FLAG)) {
		        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
		      }
		      var newData = [
		        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
		        newHoldersRight, argPos, ary, arity
		      ];
		
		      var result = wrapFunc.apply(undefined, newData);
		      if (isLaziable(func)) {
		        setData(result, newData);
		      }
		      result.placeholder = placeholder;
		      return result;
		    }
		
		    /**
		     * Creates a function like `_.round`.
		     *
		     * @private
		     * @param {string} methodName The name of the `Math` method to use when rounding.
		     * @returns {Function} Returns the new round function.
		     */
		    function createRound(methodName) {
		      var func = Math[methodName];
		      return function(number, precision) {
		        number = toNumber(number);
		        precision = toInteger(precision);
		        if (precision) {
		          // Shift with exponential notation to avoid floating-point issues.
		          // See [MDN](https://mdn.io/round#Examples) for more details.
		          var pair = (toString(number) + 'e').split('e'),
		              value = func(pair[0] + 'e' + (+pair[1] + precision));
		
		          pair = (toString(value) + 'e').split('e');
		          return +(pair[0] + 'e' + (+pair[1] - precision));
		        }
		        return func(number);
		      };
		    }
		
		    /**
		     * Creates a set of `values`.
		     *
		     * @private
		     * @param {Array} values The values to add to the set.
		     * @returns {Object} Returns the new set.
		     */
		    var createSet = !(Set && new Set([1, 2]).size === 2) ? noop : function(values) {
		      return new Set(values);
		    };
		
		    /**
		     * Creates a function that either curries or invokes `func` with optional
		     * `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask of wrapper flags.
		     *  The bitmask may be composed of the following flags:
		     *     1 - `_.bind`
		     *     2 - `_.bindKey`
		     *     4 - `_.curry` or `_.curryRight` of a bound function
		     *     8 - `_.curry`
		     *    16 - `_.curryRight`
		     *    32 - `_.partial`
		     *    64 - `_.partialRight`
		     *   128 - `_.rearg`
		     *   256 - `_.ary`
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to be partially applied.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
		      var isBindKey = bitmask & BIND_KEY_FLAG;
		      if (!isBindKey && typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var length = partials ? partials.length : 0;
		      if (!length) {
		        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
		        partials = holders = undefined;
		      }
		      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
		      arity = arity === undefined ? arity : toInteger(arity);
		      length -= holders ? holders.length : 0;
		
		      if (bitmask & PARTIAL_RIGHT_FLAG) {
		        var partialsRight = partials,
		            holdersRight = holders;
		
		        partials = holders = undefined;
		      }
		      var data = isBindKey ? undefined : getData(func);
		
		      var newData = [
		        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
		        argPos, ary, arity
		      ];
		
		      if (data) {
		        mergeData(newData, data);
		      }
		      func = newData[0];
		      bitmask = newData[1];
		      thisArg = newData[2];
		      partials = newData[3];
		      holders = newData[4];
		      arity = newData[9] = newData[9] == null
		        ? (isBindKey ? 0 : func.length)
		        : nativeMax(newData[9] - length, 0);
		
		      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
		        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
		      }
		      if (!bitmask || bitmask == BIND_FLAG) {
		        var result = createBaseWrapper(func, bitmask, thisArg);
		      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
		        result = createCurryWrapper(func, bitmask, arity);
		      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
		        result = createPartialWrapper(func, bitmask, thisArg, partials);
		      } else {
		        result = createHybridWrapper.apply(undefined, newData);
		      }
		      var setter = data ? baseSetData : setData;
		      return setter(result, newData);
		    }
		
		    /**
		     * A specialized version of `baseIsEqualDeep` for arrays with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Array} array The array to compare.
		     * @param {Array} other The other array to compare.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
		     *  for more details.
		     * @param {Object} stack Tracks traversed `array` and `other` objects.
		     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		     */
		    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
		      var index = -1,
		          isPartial = bitmask & PARTIAL_COMPARE_FLAG,
		          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,
		          arrLength = array.length,
		          othLength = other.length;
		
		      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		        return false;
		      }
		      // Assume cyclic values are equal.
		      var stacked = stack.get(array);
		      if (stacked) {
		        return stacked == other;
		      }
		      var result = true;
		      stack.set(array, other);
		
		      // Ignore non-index properties.
		      while (++index < arrLength) {
		        var arrValue = array[index],
		            othValue = other[index];
		
		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, arrValue, index, other, array, stack)
		            : customizer(arrValue, othValue, index, array, other, stack);
		        }
		        if (compared !== undefined) {
		          if (compared) {
		            continue;
		          }
		          result = false;
		          break;
		        }
		        // Recursively compare arrays (susceptible to call stack limits).
		        if (isUnordered) {
		          if (!arraySome(other, function(othValue) {
		                return arrValue === othValue ||
		                  equalFunc(arrValue, othValue, customizer, bitmask, stack);
		              })) {
		            result = false;
		            break;
		          }
		        } else if (!(
		              arrValue === othValue ||
		                equalFunc(arrValue, othValue, customizer, bitmask, stack)
		            )) {
		          result = false;
		          break;
		        }
		      }
		      stack['delete'](array);
		      return result;
		    }
		
		    /**
		     * A specialized version of `baseIsEqualDeep` for comparing objects of
		     * the same `toStringTag`.
		     *
		     * **Note:** This function only supports comparing values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {string} tag The `toStringTag` of the objects to compare.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
		     *  for more details.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
		      switch (tag) {
		        case dataViewTag:
		          if ((object.byteLength != other.byteLength) ||
		              (object.byteOffset != other.byteOffset)) {
		            return false;
		          }
		          object = object.buffer;
		          other = other.buffer;
		
		        case arrayBufferTag:
		          if ((object.byteLength != other.byteLength) ||
		              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		            return false;
		          }
		          return true;
		
		        case boolTag:
		        case dateTag:
		          // Coerce dates and booleans to numbers, dates to milliseconds and
		          // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
		          // not equal.
		          return +object == +other;
		
		        case errorTag:
		          return object.name == other.name && object.message == other.message;
		
		        case numberTag:
		          // Treat `NaN` vs. `NaN` as equal.
		          return (object != +object) ? other != +other : object == +other;
		
		        case regexpTag:
		        case stringTag:
		          // Coerce regexes to strings and treat strings, primitives and objects,
		          // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
		          // for more details.
		          return object == (other + '');
		
		        case mapTag:
		          var convert = mapToArray;
		
		        case setTag:
		          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
		          convert || (convert = setToArray);
		
		          if (object.size != other.size && !isPartial) {
		            return false;
		          }
		          // Assume cyclic values are equal.
		          var stacked = stack.get(object);
		          if (stacked) {
		            return stacked == other;
		          }
		          bitmask |= UNORDERED_COMPARE_FLAG;
		          stack.set(object, other);
		
		          // Recursively compare objects (susceptible to call stack limits).
		          return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
		
		        case symbolTag:
		          if (symbolValueOf) {
		            return symbolValueOf.call(object) == symbolValueOf.call(other);
		          }
		      }
		      return false;
		    }
		
		    /**
		     * A specialized version of `baseIsEqualDeep` for objects with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
		     *  for more details.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
		      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
		          objProps = keys(object),
		          objLength = objProps.length,
		          othProps = keys(other),
		          othLength = othProps.length;
		
		      if (objLength != othLength && !isPartial) {
		        return false;
		      }
		      var index = objLength;
		      while (index--) {
		        var key = objProps[index];
		        if (!(isPartial ? key in other : baseHas(other, key))) {
		          return false;
		        }
		      }
		      // Assume cyclic values are equal.
		      var stacked = stack.get(object);
		      if (stacked) {
		        return stacked == other;
		      }
		      var result = true;
		      stack.set(object, other);
		
		      var skipCtor = isPartial;
		      while (++index < objLength) {
		        key = objProps[index];
		        var objValue = object[key],
		            othValue = other[key];
		
		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, objValue, key, other, object, stack)
		            : customizer(objValue, othValue, key, object, other, stack);
		        }
		        // Recursively compare objects (susceptible to call stack limits).
		        if (!(compared === undefined
		              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
		              : compared
		            )) {
		          result = false;
		          break;
		        }
		        skipCtor || (skipCtor = key == 'constructor');
		      }
		      if (result && !skipCtor) {
		        var objCtor = object.constructor,
		            othCtor = other.constructor;
		
		        // Non `Object` object instances with different constructors are not equal.
		        if (objCtor != othCtor &&
		            ('constructor' in object && 'constructor' in other) &&
		            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		          result = false;
		        }
		      }
		      stack['delete'](object);
		      return result;
		    }
		
		    /**
		     * Creates an array of own enumerable property names and symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeys(object) {
		      return baseGetAllKeys(object, keys, getSymbols);
		    }
		
		    /**
		     * Creates an array of own and inherited enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeysIn(object) {
		      return baseGetAllKeys(object, keysIn, getSymbolsIn);
		    }
		
		    /**
		     * Gets metadata for `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {*} Returns the metadata for `func`.
		     */
		    var getData = !metaMap ? noop : function(func) {
		      return metaMap.get(func);
		    };
		
		    /**
		     * Gets the name of `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {string} Returns the function name.
		     */
		    function getFuncName(func) {
		      var result = (func.name + ''),
		          array = realNames[result],
		          length = hasOwnProperty.call(realNames, result) ? array.length : 0;
		
		      while (length--) {
		        var data = array[length],
		            otherFunc = data.func;
		        if (otherFunc == null || otherFunc == func) {
		          return data.name;
		        }
		      }
		      return result;
		    }
		
		    /**
		     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
		     * this function returns the custom method, otherwise it returns `baseIteratee`.
		     * If arguments are provided, the chosen function is invoked with them and
		     * its result is returned.
		     *
		     * @private
		     * @param {*} [value] The value to convert to an iteratee.
		     * @param {number} [arity] The arity of the created iteratee.
		     * @returns {Function} Returns the chosen function or its result.
		     */
		    function getIteratee() {
		      var result = lodash.iteratee || iteratee;
		      result = result === iteratee ? baseIteratee : result;
		      return arguments.length ? result(arguments[0], arguments[1]) : result;
		    }
		
		    /**
		     * Gets the "length" property value of `object`.
		     *
		     * **Note:** This function is used to avoid a
		     * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
		     * Safari on at least iOS 8.1-8.3 ARM64.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {*} Returns the "length" value.
		     */
		    var getLength = baseProperty('length');
		
		    /**
		     * Gets the property names, values, and compare flags of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the match data of `object`.
		     */
		    function getMatchData(object) {
		      var result = toPairs(object),
		          length = result.length;
		
		      while (length--) {
		        result[length][2] = isStrictComparable(result[length][1]);
		      }
		      return result;
		    }
		
		    /**
		     * Gets the native function at `key` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the method to get.
		     * @returns {*} Returns the function if it's native, else `undefined`.
		     */
		    function getNative(object, key) {
		      var value = object[key];
		      return isNative(value) ? value : undefined;
		    }
		
		    /**
		     * Gets the argument placeholder value for `func`.
		     *
		     * @private
		     * @param {Function} func The function to inspect.
		     * @returns {*} Returns the placeholder value.
		     */
		    function getPlaceholder(func) {
		      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
		      return object.placeholder;
		    }
		
		    /**
		     * Gets the `[[Prototype]]` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {null|Object} Returns the `[[Prototype]]`.
		     */
		    function getPrototype(value) {
		      return nativeGetPrototype(Object(value));
		    }
		
		    /**
		     * Creates an array of the own enumerable symbol properties of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    function getSymbols(object) {
		      // Coerce `object` to an object to avoid non-object errors in V8.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
		      return getOwnPropertySymbols(Object(object));
		    }
		
		    // Fallback for IE < 11.
		    if (!getOwnPropertySymbols) {
		      getSymbols = function() {
		        return [];
		      };
		    }
		
		    /**
		     * Creates an array of the own and inherited enumerable symbol properties
		     * of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
		      var result = [];
		      while (object) {
		        arrayPush(result, getSymbols(object));
		        object = getPrototype(object);
		      }
		      return result;
		    };
		
		    /**
		     * Gets the `toStringTag` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    function getTag(value) {
		      return objectToString.call(value);
		    }
		
		    // Fallback for data views, maps, sets, and weak maps in IE 11,
		    // for data views in Edge, and promises in Node.js.
		    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		        (Map && getTag(new Map) != mapTag) ||
		        (Promise && getTag(Promise.resolve()) != promiseTag) ||
		        (Set && getTag(new Set) != setTag) ||
		        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		      getTag = function(value) {
		        var result = objectToString.call(value),
		            Ctor = result == objectTag ? value.constructor : undefined,
		            ctorString = Ctor ? toSource(Ctor) : undefined;
		
		        if (ctorString) {
		          switch (ctorString) {
		            case dataViewCtorString: return dataViewTag;
		            case mapCtorString: return mapTag;
		            case promiseCtorString: return promiseTag;
		            case setCtorString: return setTag;
		            case weakMapCtorString: return weakMapTag;
		          }
		        }
		        return result;
		      };
		    }
		
		    /**
		     * Gets the view, applying any `transforms` to the `start` and `end` positions.
		     *
		     * @private
		     * @param {number} start The start of the view.
		     * @param {number} end The end of the view.
		     * @param {Array} transforms The transformations to apply to the view.
		     * @returns {Object} Returns an object containing the `start` and `end`
		     *  positions of the view.
		     */
		    function getView(start, end, transforms) {
		      var index = -1,
		          length = transforms.length;
		
		      while (++index < length) {
		        var data = transforms[index],
		            size = data.size;
		
		        switch (data.type) {
		          case 'drop':      start += size; break;
		          case 'dropRight': end -= size; break;
		          case 'take':      end = nativeMin(end, start + size); break;
		          case 'takeRight': start = nativeMax(start, end - size); break;
		        }
		      }
		      return { 'start': start, 'end': end };
		    }
		
		    /**
		     * Checks if `path` exists on `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @param {Function} hasFunc The function to check properties.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     */
		    function hasPath(object, path, hasFunc) {
		      path = isKey(path, object) ? [path] : castPath(path);
		
		      var result,
		          index = -1,
		          length = path.length;
		
		      while (++index < length) {
		        var key = path[index];
		        if (!(result = object != null && hasFunc(object, key))) {
		          break;
		        }
		        object = object[key];
		      }
		      if (result) {
		        return result;
		      }
		      var length = object ? object.length : 0;
		      return !!length && isLength(length) && isIndex(key, length) &&
		        (isArray(object) || isString(object) || isArguments(object));
		    }
		
		    /**
		     * Initializes an array clone.
		     *
		     * @private
		     * @param {Array} array The array to clone.
		     * @returns {Array} Returns the initialized clone.
		     */
		    function initCloneArray(array) {
		      var length = array.length,
		          result = array.constructor(length);
		
		      // Add properties assigned by `RegExp#exec`.
		      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		        result.index = array.index;
		        result.input = array.input;
		      }
		      return result;
		    }
		
		    /**
		     * Initializes an object clone.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneObject(object) {
		      return (typeof object.constructor == 'function' && !isPrototype(object))
		        ? baseCreate(getPrototype(object))
		        : {};
		    }
		
		    /**
		     * Initializes an object clone based on its `toStringTag`.
		     *
		     * **Note:** This function only supports cloning values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @param {string} tag The `toStringTag` of the object to clone.
		     * @param {Function} cloneFunc The function to clone values.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneByTag(object, tag, cloneFunc, isDeep) {
		      var Ctor = object.constructor;
		      switch (tag) {
		        case arrayBufferTag:
		          return cloneArrayBuffer(object);
		
		        case boolTag:
		        case dateTag:
		          return new Ctor(+object);
		
		        case dataViewTag:
		          return cloneDataView(object, isDeep);
		
		        case float32Tag: case float64Tag:
		        case int8Tag: case int16Tag: case int32Tag:
		        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		          return cloneTypedArray(object, isDeep);
		
		        case mapTag:
		          return cloneMap(object, isDeep, cloneFunc);
		
		        case numberTag:
		        case stringTag:
		          return new Ctor(object);
		
		        case regexpTag:
		          return cloneRegExp(object);
		
		        case setTag:
		          return cloneSet(object, isDeep, cloneFunc);
		
		        case symbolTag:
		          return cloneSymbol(object);
		      }
		    }
		
		    /**
		     * Creates an array of index keys for `object` values of arrays,
		     * `arguments` objects, and strings, otherwise `null` is returned.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array|null} Returns index keys, else `null`.
		     */
		    function indexKeys(object) {
		      var length = object ? object.length : undefined;
		      if (isLength(length) &&
		          (isArray(object) || isString(object) || isArguments(object))) {
		        return baseTimes(length, String);
		      }
		      return null;
		    }
		
		    /**
		     * Checks if `value` is a flattenable `arguments` object or array.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenable(value) {
		      return isArrayLikeObject(value) && (isArray(value) || isArguments(value));
		    }
		
		    /**
		     * Checks if `value` is a flattenable array and not a `_.matchesProperty`
		     * iteratee shorthand.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenableIteratee(value) {
		      return isArray(value) && !(value.length == 2 && !isFunction(value[0]));
		    }
		
		    /**
		     * Checks if the given arguments are from an iteratee call.
		     *
		     * @private
		     * @param {*} value The potential iteratee value argument.
		     * @param {*} index The potential iteratee index or key argument.
		     * @param {*} object The potential iteratee object argument.
		     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		     *  else `false`.
		     */
		    function isIterateeCall(value, index, object) {
		      if (!isObject(object)) {
		        return false;
		      }
		      var type = typeof index;
		      if (type == 'number'
		            ? (isArrayLike(object) && isIndex(index, object.length))
		            : (type == 'string' && index in object)
		          ) {
		        return eq(object[index], value);
		      }
		      return false;
		    }
		
		    /**
		     * Checks if `value` is a property name and not a property path.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		     */
		    function isKey(value, object) {
		      var type = typeof value;
		      if (type == 'number' || type == 'symbol') {
		        return true;
		      }
		      return !isArray(value) &&
		        (isSymbol(value) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		          (object != null && value in Object(object)));
		    }
		
		    /**
		     * Checks if `value` is suitable for use as unique object key.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		     */
		    function isKeyable(value) {
		      var type = typeof value;
		      return type == 'number' || type == 'boolean' ||
		        (type == 'string' && value != '__proto__') || value == null;
		    }
		
		    /**
		     * Checks if `func` has a lazy counterpart.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
		     *  else `false`.
		     */
		    function isLaziable(func) {
		      var funcName = getFuncName(func),
		          other = lodash[funcName];
		
		      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		        return false;
		      }
		      if (func === other) {
		        return true;
		      }
		      var data = getData(other);
		      return !!data && func === data[0];
		    }
		
		    /**
		     * Checks if `value` is likely a prototype object.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		     */
		    function isPrototype(value) {
		      var Ctor = value && value.constructor,
		          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
		
		      return value === proto;
		    }
		
		    /**
		     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` if suitable for strict
		     *  equality comparisons, else `false`.
		     */
		    function isStrictComparable(value) {
		      return value === value && !isObject(value);
		    }
		
		    /**
		     * A specialized version of `matchesProperty` for source values suitable
		     * for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new function.
		     */
		    function matchesStrictComparable(key, srcValue) {
		      return function(object) {
		        if (object == null) {
		          return false;
		        }
		        return object[key] === srcValue &&
		          (srcValue !== undefined || (key in Object(object)));
		      };
		    }
		
		    /**
		     * Merges the function metadata of `source` into `data`.
		     *
		     * Merging metadata reduces the number of wrappers used to invoke a function.
		     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
		     * may be applied regardless of execution order. Methods like `_.ary` and
		     * `_.rearg` modify function arguments, making the order in which they are
		     * executed important, preventing the merging of metadata. However, we make
		     * an exception for a safe combined case where curried functions have `_.ary`
		     * and or `_.rearg` applied.
		     *
		     * @private
		     * @param {Array} data The destination metadata.
		     * @param {Array} source The source metadata.
		     * @returns {Array} Returns `data`.
		     */
		    function mergeData(data, source) {
		      var bitmask = data[1],
		          srcBitmask = source[1],
		          newBitmask = bitmask | srcBitmask,
		          isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
		
		      var isCombo =
		        ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
		        ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
		        ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));
		
		      // Exit early if metadata can't be merged.
		      if (!(isCommon || isCombo)) {
		        return data;
		      }
		      // Use source `thisArg` if available.
		      if (srcBitmask & BIND_FLAG) {
		        data[2] = source[2];
		        // Set when currying a bound function.
		        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
		      }
		      // Compose partial arguments.
		      var value = source[3];
		      if (value) {
		        var partials = data[3];
		        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
		      }
		      // Compose partial right arguments.
		      value = source[5];
		      if (value) {
		        partials = data[5];
		        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
		      }
		      // Use source `argPos` if available.
		      value = source[7];
		      if (value) {
		        data[7] = value;
		      }
		      // Use source `ary` if it's smaller.
		      if (srcBitmask & ARY_FLAG) {
		        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
		      }
		      // Use source `arity` if one is not provided.
		      if (data[9] == null) {
		        data[9] = source[9];
		      }
		      // Use source `func` and merge bitmasks.
		      data[0] = source[0];
		      data[1] = newBitmask;
		
		      return data;
		    }
		
		    /**
		     * Used by `_.defaultsDeep` to customize its `_.merge` use.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to merge.
		     * @param {Object} object The parent object of `objValue`.
		     * @param {Object} source The parent object of `srcValue`.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     * @returns {*} Returns the value to assign.
		     */
		    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
		      if (isObject(objValue) && isObject(srcValue)) {
		        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
		      }
		      return objValue;
		    }
		
		    /**
		     * Gets the parent value at `path` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array} path The path to get the parent value of.
		     * @returns {*} Returns the parent value.
		     */
		    function parent(object, path) {
		      return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
		    }
		
		    /**
		     * Reorder `array` according to the specified indexes where the element at
		     * the first index is assigned as the first element, the element at
		     * the second index is assigned as the second element, and so on.
		     *
		     * @private
		     * @param {Array} array The array to reorder.
		     * @param {Array} indexes The arranged array indexes.
		     * @returns {Array} Returns `array`.
		     */
		    function reorder(array, indexes) {
		      var arrLength = array.length,
		          length = nativeMin(indexes.length, arrLength),
		          oldArray = copyArray(array);
		
		      while (length--) {
		        var index = indexes[length];
		        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
		      }
		      return array;
		    }
		
		    /**
		     * Sets metadata for `func`.
		     *
		     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
		     * period of time, it will trip its breaker and transition to an identity
		     * function to avoid garbage collection pauses in V8. See
		     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
		     * for more details.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var setData = (function() {
		      var count = 0,
		          lastCalled = 0;
		
		      return function(key, value) {
		        var stamp = now(),
		            remaining = HOT_SPAN - (stamp - lastCalled);
		
		        lastCalled = stamp;
		        if (remaining > 0) {
		          if (++count >= HOT_COUNT) {
		            return key;
		          }
		        } else {
		          count = 0;
		        }
		        return baseSetData(key, value);
		      };
		    }());
		
		    /**
		     * Converts `string` to a property path array.
		     *
		     * @private
		     * @param {string} string The string to convert.
		     * @returns {Array} Returns the property path array.
		     */
		    var stringToPath = memoize(function(string) {
		      var result = [];
		      toString(string).replace(rePropName, function(match, number, quote, string) {
		        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
		      });
		      return result;
		    });
		
		    /**
		     * Converts `value` to a string key if it's not a string or symbol.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {string|symbol} Returns the key.
		     */
		    function toKey(key) {
		      return (typeof key == 'string' || isSymbol(key)) ? key : (key + '');
		    }
		
		    /**
		     * Converts `func` to its source code.
		     *
		     * @private
		     * @param {Function} func The function to process.
		     * @returns {string} Returns the source code.
		     */
		    function toSource(func) {
		      if (func != null) {
		        try {
		          return funcToString.call(func);
		        } catch (e) {}
		        try {
		          return (func + '');
		        } catch (e) {}
		      }
		      return '';
		    }
		
		    /**
		     * Creates a clone of `wrapper`.
		     *
		     * @private
		     * @param {Object} wrapper The wrapper to clone.
		     * @returns {Object} Returns the cloned wrapper.
		     */
		    function wrapperClone(wrapper) {
		      if (wrapper instanceof LazyWrapper) {
		        return wrapper.clone();
		      }
		      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
		      result.__actions__ = copyArray(wrapper.__actions__);
		      result.__index__  = wrapper.__index__;
		      result.__values__ = wrapper.__values__;
		      return result;
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates an array of elements split into groups the length of `size`.
		     * If `array` can't be split evenly, the final chunk will be the remaining
		     * elements.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to process.
		     * @param {number} [size=1] The length of each chunk
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the new array containing chunks.
		     * @example
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 2);
		     * // => [['a', 'b'], ['c', 'd']]
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 3);
		     * // => [['a', 'b', 'c'], ['d']]
		     */
		    function chunk(array, size, guard) {
		      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
		        size = 1;
		      } else {
		        size = nativeMax(toInteger(size), 0);
		      }
		      var length = array ? array.length : 0;
		      if (!length || size < 1) {
		        return [];
		      }
		      var index = 0,
		          resIndex = 0,
		          result = Array(nativeCeil(length / size));
		
		      while (index < length) {
		        result[resIndex++] = baseSlice(array, index, (index += size));
		      }
		      return result;
		    }
		
		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are falsey.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array ? array.length : 0,
		          resIndex = 0,
		          result = [];
		
		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }
		
		    /**
		     * Creates a new array concatenating `array` with any additional arrays
		     * and/or values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to concatenate.
		     * @param {...*} [values] The values to concatenate.
		     * @returns {Array} Returns the new concatenated array.
		     * @example
		     *
		     * var array = [1];
		     * var other = _.concat(array, 2, [3], [[4]]);
		     *
		     * console.log(other);
		     * // => [1, 2, 3, [4]]
		     *
		     * console.log(array);
		     * // => [1]
		     */
		    function concat() {
		      var length = arguments.length,
		          array = castArray(arguments[0]);
		
		      if (length < 2) {
		        return length ? copyArray(array) : [];
		      }
		      var args = Array(length - 1);
		      while (length--) {
		        args[length - 1] = arguments[length];
		      }
		      return arrayConcat(array, baseFlatten(args, 1));
		    }
		
		    /**
		     * Creates an array of unique `array` values not included in the other given
		     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons. The order of result values is determined by the
		     * order they occur in the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.difference([3, 2, 1], [4, 2]);
		     * // => [3, 1]
		     */
		    var difference = rest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
		        : [];
		    });
		
		    /**
		     * This method is like `_.difference` except that it accepts `iteratee` which
		     * is invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. Result values are chosen from the first array.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
		     * // => [3.1, 1.3]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var differenceBy = rest(function(array, values) {
		      var iteratee = last(values);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee))
		        : [];
		    });
		
		    /**
		     * This method is like `_.difference` except that it accepts `comparator`
		     * which is invoked to compare elements of `array` to `values`. Result values
		     * are chosen from the first array. The comparator is invoked with two arguments:
		     * (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     *
		     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }]
		     */
		    var differenceWith = rest(function(array, values) {
		      var comparator = last(values);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
		        : [];
		    });
		
		    /**
		     * Creates a slice of `array` with `n` elements dropped from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.drop([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.drop([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.drop([1, 2, 3], 5);
		     * // => []
		     *
		     * _.drop([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function drop(array, n, guard) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined) ? 1 : toInteger(n);
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }
		
		    /**
		     * Creates a slice of `array` with `n` elements dropped from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.dropRight([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.dropRight([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.dropRight([1, 2, 3], 5);
		     * // => []
		     *
		     * _.dropRight([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function dropRight(array, n, guard) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }
		
		    /**
		     * Creates a slice of `array` excluding elements dropped from the end.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.dropRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropRightWhile(users, ['active', false]);
		     * // => objects for ['barney']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropRightWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true, true)
		        : [];
		    }
		
		    /**
		     * Creates a slice of `array` excluding elements dropped from the beginning.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.dropWhile(users, function(o) { return !o.active; });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropWhile(users, ['active', false]);
		     * // => objects for ['pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true)
		        : [];
		    }
		
		    /**
		     * Fills elements of `array` with `value` from `start` up to, but not
		     * including, `end`.
		     *
		     * **Note:** This method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Array
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.fill(array, 'a');
		     * console.log(array);
		     * // => ['a', 'a', 'a']
		     *
		     * _.fill(Array(3), 2);
		     * // => [2, 2, 2]
		     *
		     * _.fill([4, 6, 8, 10], '*', 1, 3);
		     * // => [4, '*', '*', 10]
		     */
		    function fill(array, value, start, end) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return [];
		      }
		      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		        start = 0;
		        end = length;
		      }
		      return baseFill(array, value, start, end);
		    }
		
		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Array
		     * @param {Array} array The array to search.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.findIndex(users, function(o) { return o.user == 'barney'; });
		     * // => 0
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findIndex(users, { 'user': 'fred', 'active': false });
		     * // => 1
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findIndex(users, ['active', false]);
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findIndex(users, 'active');
		     * // => 2
		     */
		    function findIndex(array, predicate) {
		      return (array && array.length)
		        ? baseFindIndex(array, getIteratee(predicate, 3))
		        : -1;
		    }
		
		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to search.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
		     * // => 2
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
		     * // => 0
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastIndex(users, ['active', false]);
		     * // => 2
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastIndex(users, 'active');
		     * // => 0
		     */
		    function findLastIndex(array, predicate) {
		      return (array && array.length)
		        ? baseFindIndex(array, getIteratee(predicate, 3), true)
		        : -1;
		    }
		
		    /**
		     * Flattens `array` a single level deep.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, [3, [4]], 5]
		     */
		    function flatten(array) {
		      var length = array ? array.length : 0;
		      return length ? baseFlatten(array, 1) : [];
		    }
		
		    /**
		     * Recursively flattens `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flattenDeep([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, 3, 4, 5]
		     */
		    function flattenDeep(array) {
		      var length = array ? array.length : 0;
		      return length ? baseFlatten(array, INFINITY) : [];
		    }
		
		    /**
		     * Recursively flatten `array` up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * var array = [1, [2, [3, [4]], 5]];
		     *
		     * _.flattenDepth(array, 1);
		     * // => [1, 2, [3, [4]], 5]
		     *
		     * _.flattenDepth(array, 2);
		     * // => [1, 2, 3, [4], 5]
		     */
		    function flattenDepth(array, depth) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return [];
		      }
		      depth = depth === undefined ? 1 : toInteger(depth);
		      return baseFlatten(array, depth);
		    }
		
		    /**
		     * The inverse of `_.toPairs`; this method returns an object composed
		     * from key-value `pairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} pairs The key-value pairs.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.fromPairs([['fred', 30], ['barney', 40]]);
		     * // => { 'fred': 30, 'barney': 40 }
		     */
		    function fromPairs(pairs) {
		      var index = -1,
		          length = pairs ? pairs.length : 0,
		          result = {};
		
		      while (++index < length) {
		        var pair = pairs[index];
		        result[pair[0]] = pair[1];
		      }
		      return result;
		    }
		
		    /**
		     * Gets the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias first
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the first element of `array`.
		     * @example
		     *
		     * _.head([1, 2, 3]);
		     * // => 1
		     *
		     * _.head([]);
		     * // => undefined
		     */
		    function head(array) {
		      return (array && array.length) ? array[0] : undefined;
		    }
		
		    /**
		     * Gets the index at which the first occurrence of `value` is found in `array`
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons. If `fromIndex` is negative, it's used as the
		     * offset from the end of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to search.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 1, 2], 2);
		     * // => 1
		     *
		     * // Search from the `fromIndex`.
		     * _.indexOf([1, 2, 1, 2], 2, 2);
		     * // => 3
		     */
		    function indexOf(array, value, fromIndex) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return -1;
		      }
		      fromIndex = toInteger(fromIndex);
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return baseIndexOf(array, value, fromIndex);
		    }
		
		    /**
		     * Gets all but the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     */
		    function initial(array) {
		      return dropRight(array, 1);
		    }
		
		    /**
		     * Creates an array of unique values that are included in all given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons. The order of result values is determined by the
		     * order they occur in the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersection([2, 1], [4, 2], [1, 2]);
		     * // => [2]
		     */
		    var intersection = rest(function(arrays) {
		      var mapped = arrayMap(arrays, castArrayLikeObject);
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped)
		        : [];
		    });
		
		    /**
		     * This method is like `_.intersection` except that it accepts `iteratee`
		     * which is invoked for each element of each `arrays` to generate the criterion
		     * by which they're compared. Result values are chosen from the first array.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
		     * // => [2.1]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }]
		     */
		    var intersectionBy = rest(function(arrays) {
		      var iteratee = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);
		
		      if (iteratee === last(mapped)) {
		        iteratee = undefined;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, getIteratee(iteratee))
		        : [];
		    });
		
		    /**
		     * This method is like `_.intersection` except that it accepts `comparator`
		     * which is invoked to compare elements of `arrays`. Result values are chosen
		     * from the first array. The comparator is invoked with two arguments:
		     * (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.intersectionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }]
		     */
		    var intersectionWith = rest(function(arrays) {
		      var comparator = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);
		
		      if (comparator === last(mapped)) {
		        comparator = undefined;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, undefined, comparator)
		        : [];
		    });
		
		    /**
		     * Converts all elements in `array` into a string separated by `separator`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to convert.
		     * @param {string} [separator=','] The element separator.
		     * @returns {string} Returns the joined string.
		     * @example
		     *
		     * _.join(['a', 'b', 'c'], '~');
		     * // => 'a~b~c'
		     */
		    function join(array, separator) {
		      return array ? nativeJoin.call(array, separator) : '';
		    }
		
		    /**
		     * Gets the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the last element of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     */
		    function last(array) {
		      var length = array ? array.length : 0;
		      return length ? array[length - 1] : undefined;
		    }
		
		    /**
		     * This method is like `_.indexOf` except that it iterates over elements of
		     * `array` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to search.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 1, 2], 2);
		     * // => 3
		     *
		     * // Search from the `fromIndex`.
		     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return -1;
		      }
		      var index = length;
		      if (fromIndex !== undefined) {
		        index = toInteger(fromIndex);
		        index = (
		          index < 0
		            ? nativeMax(length + index, 0)
		            : nativeMin(index, length - 1)
		        ) + 1;
		      }
		      if (value !== value) {
		        return indexOfNaN(array, index, true);
		      }
		      while (index--) {
		        if (array[index] === value) {
		          return index;
		        }
		      }
		      return -1;
		    }
		
		    /**
		     * Gets the nth element of `array`. If `n` is negative, the nth element
		     * from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.11.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=0] The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     *
		     * _.nth(array, 1);
		     * // => 'b'
		     *
		     * _.nth(array, -2);
		     * // => 'c';
		     */
		    function nth(array, n) {
		      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
		    }
		
		    /**
		     * Removes all given values from `array` using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
		     * to remove elements from an array by predicate.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...*} [values] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3, 1, 2, 3];
		     *
		     * _.pull(array, 2, 3);
		     * console.log(array);
		     * // => [1, 1]
		     */
		    var pull = rest(pullAll);
		
		    /**
		     * This method is like `_.pull` except that it accepts an array of values to remove.
		     *
		     * **Note:** Unlike `_.difference`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3, 1, 2, 3];
		     *
		     * _.pullAll(array, [2, 3]);
		     * console.log(array);
		     * // => [1, 1]
		     */
		    function pullAll(array, values) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values)
		        : array;
		    }
		
		    /**
		     * This method is like `_.pullAll` except that it accepts `iteratee` which is
		     * invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The iteratee is invoked with one argument: (value).
		     *
		     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
		     *
		     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
		     * console.log(array);
		     * // => [{ 'x': 2 }]
		     */
		    function pullAllBy(array, values, iteratee) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, getIteratee(iteratee))
		        : array;
		    }
		
		    /**
		     * This method is like `_.pullAll` except that it accepts `comparator` which
		     * is invoked to compare elements of `array` to `values`. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
		     *
		     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
		     * console.log(array);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
		     */
		    function pullAllWith(array, values, comparator) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, undefined, comparator)
		        : array;
		    }
		
		    /**
		     * Removes elements from `array` corresponding to `indexes` and returns an
		     * array of removed elements.
		     *
		     * **Note:** Unlike `_.at`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [5, 10, 15, 20];
		     * var evens = _.pullAt(array, 1, 3);
		     *
		     * console.log(array);
		     * // => [5, 15]
		     *
		     * console.log(evens);
		     * // => [10, 20]
		     */
		    var pullAt = rest(function(array, indexes) {
		      indexes = arrayMap(baseFlatten(indexes, 1), String);
		
		      var result = baseAt(array, indexes);
		      basePullAt(array, indexes.sort(compareAscending));
		      return result;
		    });
		
		    /**
		     * Removes all elements from `array` that `predicate` returns truthy for
		     * and returns an array of the removed elements. The predicate is invoked
		     * with three arguments: (value, index, array).
		     *
		     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
		     * to pull elements from an array by value.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4];
		     * var evens = _.remove(array, function(n) {
		     *   return n % 2 == 0;
		     * });
		     *
		     * console.log(array);
		     * // => [1, 3]
		     *
		     * console.log(evens);
		     * // => [2, 4]
		     */
		    function remove(array, predicate) {
		      var result = [];
		      if (!(array && array.length)) {
		        return result;
		      }
		      var index = -1,
		          indexes = [],
		          length = array.length;
		
		      predicate = getIteratee(predicate, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (predicate(value, index, array)) {
		          result.push(value);
		          indexes.push(index);
		        }
		      }
		      basePullAt(array, indexes);
		      return result;
		    }
		
		    /**
		     * Reverses `array` so that the first element becomes the last, the second
		     * element becomes the second to last, and so on.
		     *
		     * **Note:** This method mutates `array` and is based on
		     * [`Array#reverse`](https://mdn.io/Array/reverse).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.reverse(array);
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function reverse(array) {
		      return array ? nativeReverse.call(array) : array;
		    }
		
		    /**
		     * Creates a slice of `array` from `start` up to, but not including, `end`.
		     *
		     * **Note:** This method is used instead of
		     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
		     * returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function slice(array, start, end) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return [];
		      }
		      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		        start = 0;
		        end = length;
		      }
		      else {
		        start = start == null ? 0 : toInteger(start);
		        end = end === undefined ? length : toInteger(end);
		      }
		      return baseSlice(array, start, end);
		    }
		
		    /**
		     * Uses a binary search to determine the lowest index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([30, 50], 40);
		     * // => 1
		     *
		     * _.sortedIndex([4, 5], 4);
		     * // => 0
		     */
		    function sortedIndex(array, value) {
		      return baseSortedIndex(array, value);
		    }
		
		    /**
		     * This method is like `_.sortedIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
		     *
		     * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
		     * // => 1
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
		     * // => 0
		     */
		    function sortedIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee));
		    }
		
		    /**
		     * This method is like `_.indexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to search.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedIndexOf([1, 1, 2, 2], 2);
		     * // => 2
		     */
		    function sortedIndexOf(array, value) {
		      var length = array ? array.length : 0;
		      if (length) {
		        var index = baseSortedIndex(array, value);
		        if (index < length && eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }
		
		    /**
		     * This method is like `_.sortedIndex` except that it returns the highest
		     * index at which `value` should be inserted into `array` in order to
		     * maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedLastIndex([4, 5], 4);
		     * // => 1
		     */
		    function sortedLastIndex(array, value) {
		      return baseSortedIndex(array, value, true);
		    }
		
		    /**
		     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
		     * // => 1
		     */
		    function sortedLastIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
		    }
		
		    /**
		     * This method is like `_.lastIndexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to search.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedLastIndexOf([1, 1, 2, 2], 2);
		     * // => 3
		     */
		    function sortedLastIndexOf(array, value) {
		      var length = array ? array.length : 0;
		      if (length) {
		        var index = baseSortedIndex(array, value, true) - 1;
		        if (eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }
		
		    /**
		     * This method is like `_.uniq` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniq([1, 1, 2]);
		     * // => [1, 2]
		     */
		    function sortedUniq(array) {
		      return (array && array.length)
		        ? baseSortedUniq(array)
		        : [];
		    }
		
		    /**
		     * This method is like `_.uniqBy` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
		     * // => [1.1, 2.3]
		     */
		    function sortedUniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSortedUniqBy(array, getIteratee(iteratee))
		        : [];
		    }
		
		    /**
		     * Gets all but the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.tail([1, 2, 3]);
		     * // => [2, 3]
		     */
		    function tail(array) {
		      return drop(array, 1);
		    }
		
		    /**
		     * Creates a slice of `array` with `n` elements taken from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.take([1, 2, 3]);
		     * // => [1]
		     *
		     * _.take([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.take([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.take([1, 2, 3], 0);
		     * // => []
		     */
		    function take(array, n, guard) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      n = (guard || n === undefined) ? 1 : toInteger(n);
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }
		
		    /**
		     * Creates a slice of `array` with `n` elements taken from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.takeRight([1, 2, 3]);
		     * // => [3]
		     *
		     * _.takeRight([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.takeRight([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.takeRight([1, 2, 3], 0);
		     * // => []
		     */
		    function takeRight(array, n, guard) {
		      var length = array ? array.length : 0;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }
		
		    /**
		     * Creates a slice of `array` with elements taken from the end. Elements are
		     * taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.takeRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeRightWhile(users, ['active', false]);
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeRightWhile(users, 'active');
		     * // => []
		     */
		    function takeRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), false, true)
		        : [];
		    }
		
		    /**
		     * Creates a slice of `array` with elements taken from the beginning. Elements
		     * are taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false},
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.takeWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeWhile(users, ['active', false]);
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeWhile(users, 'active');
		     * // => []
		     */
		    function takeWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3))
		        : [];
		    }
		
		    /**
		     * Creates an array of unique values, in order, from all given arrays using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.union([2, 1], [4, 2], [1, 2]);
		     * // => [2, 1, 4]
		     */
		    var union = rest(function(arrays) {
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		    });
		
		    /**
		     * This method is like `_.union` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which uniqueness is computed. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
		     * // => [2.1, 1.2, 4.3]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    var unionBy = rest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee));
		    });
		
		    /**
		     * This method is like `_.union` except that it accepts `comparator` which
		     * is invoked to compare elements of `arrays`. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.unionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var unionWith = rest(function(arrays) {
		      var comparator = last(arrays);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
		    });
		
		    /**
		     * Creates a duplicate-free version of an array, using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons, in which only the first occurrence of each
		     * element is kept.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniq([2, 1, 2]);
		     * // => [2, 1]
		     */
		    function uniq(array) {
		      return (array && array.length)
		        ? baseUniq(array)
		        : [];
		    }
		
		    /**
		     * This method is like `_.uniq` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * uniqueness is computed. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseUniq(array, getIteratee(iteratee))
		        : [];
		    }
		
		    /**
		     * This method is like `_.uniq` except that it accepts `comparator` which
		     * is invoked to compare elements of `array`. The comparator is invoked with
		     * two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
		     *
		     * _.uniqWith(objects, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
		     */
		    function uniqWith(array, comparator) {
		      return (array && array.length)
		        ? baseUniq(array, undefined, comparator)
		        : [];
		    }
		
		    /**
		     * This method is like `_.zip` except that it accepts an array of grouped
		     * elements and creates an array regrouping the elements to their pre-zip
		     * configuration.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.2.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
		     * // => [['fred', 30, true], ['barney', 40, false]]
		     *
		     * _.unzip(zipped);
		     * // => [['fred', 'barney'], [30, 40], [true, false]]
		     */
		    function unzip(array) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var length = 0;
		      array = arrayFilter(array, function(group) {
		        if (isArrayLikeObject(group)) {
		          length = nativeMax(group.length, length);
		          return true;
		        }
		      });
		      return baseTimes(length, function(index) {
		        return arrayMap(array, baseProperty(index));
		      });
		    }
		
		    /**
		     * This method is like `_.unzip` except that it accepts `iteratee` to specify
		     * how regrouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  regrouped values.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
		     * // => [[1, 10, 100], [2, 20, 200]]
		     *
		     * _.unzipWith(zipped, _.add);
		     * // => [3, 30, 300]
		     */
		    function unzipWith(array, iteratee) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var result = unzip(array);
		      if (iteratee == null) {
		        return result;
		      }
		      return arrayMap(result, function(group) {
		        return apply(iteratee, undefined, group);
		      });
		    }
		
		    /**
		     * Creates an array excluding all given values using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to filter.
		     * @param {...*} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.without([1, 2, 1, 3], 1, 2);
		     * // => [3]
		     */
		    var without = rest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, values)
		        : [];
		    });
		
		    /**
		     * Creates an array of unique values that is the
		     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
		     * of the given arrays. The order of result values is determined by the order
		     * they occur in the arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of values.
		     * @example
		     *
		     * _.xor([2, 1], [4, 2]);
		     * // => [1, 4]
		     */
		    var xor = rest(function(arrays) {
		      return baseXor(arrayFilter(arrays, isArrayLikeObject));
		    });
		
		    /**
		     * This method is like `_.xor` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which by which they're compared. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Array} Returns the new array of values.
		     * @example
		     *
		     * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
		     * // => [1.2, 4.3]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var xorBy = rest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
		    });
		
		    /**
		     * This method is like `_.xor` except that it accepts `comparator` which is
		     * invoked to compare elements of `arrays`. The comparator is invoked with
		     * two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.xorWith(objects, others, _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var xorWith = rest(function(arrays) {
		      var comparator = last(arrays);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
		    });
		
		    /**
		     * Creates an array of grouped elements, the first of which contains the
		     * first elements of the given arrays, the second of which contains the
		     * second elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
		     * // => [['fred', 30, true], ['barney', 40, false]]
		     */
		    var zip = rest(unzip);
		
		    /**
		     * This method is like `_.fromPairs` except that it accepts two arrays,
		     * one of property identifiers and one of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.4.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObject(['a', 'b'], [1, 2]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function zipObject(props, values) {
		      return baseZipObject(props || [], values || [], assignValue);
		    }
		
		    /**
		     * This method is like `_.zipObject` except that it supports property paths.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
		     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
		     */
		    function zipObjectDeep(props, values) {
		      return baseZipObject(props || [], values || [], baseSet);
		    }
		
		    /**
		     * This method is like `_.zip` except that it accepts `iteratee` to specify
		     * how grouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
		     *   return a + b + c;
		     * });
		     * // => [111, 222]
		     */
		    var zipWith = rest(function(arrays) {
		      var length = arrays.length,
		          iteratee = length > 1 ? arrays[length - 1] : undefined;
		
		      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
		      return unzipWith(arrays, iteratee);
		    });
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
		     * chain sequences enabled. The result of such sequences must be unwrapped
		     * with `_#value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Seq
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36 },
		     *   { 'user': 'fred',    'age': 40 },
		     *   { 'user': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _
		     *   .chain(users)
		     *   .sortBy('age')
		     *   .map(function(o) {
		     *     return o.user + ' is ' + o.age;
		     *   })
		     *   .head()
		     *   .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      var result = lodash(value);
		      result.__chain__ = true;
		      return result;
		    }
		
		    /**
		     * This method invokes `interceptor` and returns `value`. The interceptor
		     * is invoked with one argument; (value). The purpose of this method is to
		     * "tap into" a method chain sequence in order to modify intermediate results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3])
		     *  .tap(function(array) {
		     *    // Mutate input array.
		     *    array.pop();
		     *  })
		     *  .reverse()
		     *  .value();
		     * // => [2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }
		
		    /**
		     * This method is like `_.tap` except that it returns the result of `interceptor`.
		     * The purpose of this method is to "pass thru" values replacing intermediate
		     * results in a method chain sequence.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns the result of `interceptor`.
		     * @example
		     *
		     * _('  abc  ')
		     *  .chain()
		     *  .trim()
		     *  .thru(function(value) {
		     *    return [value];
		     *  })
		     *  .value();
		     * // => ['abc']
		     */
		    function thru(value, interceptor) {
		      return interceptor(value);
		    }
		
		    /**
		     * This method is the wrapper version of `_.at`.
		     *
		     * @name at
		     * @memberOf _
		     * @since 1.0.0
		     * @category Seq
		     * @param {...(string|string[])} [paths] The property paths of elements to pick.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _(object).at(['a[0].b.c', 'a[1]']).value();
		     * // => [3, 4]
		     *
		     * _(['a', 'b', 'c']).at(0, 2).value();
		     * // => ['a', 'c']
		     */
		    var wrapperAt = rest(function(paths) {
		      paths = baseFlatten(paths, 1);
		      var length = paths.length,
		          start = length ? paths[0] : 0,
		          value = this.__wrapped__,
		          interceptor = function(object) { return baseAt(object, paths); };
		
		      if (length > 1 || this.__actions__.length ||
		          !(value instanceof LazyWrapper) || !isIndex(start)) {
		        return this.thru(interceptor);
		      }
		      value = value.slice(start, +start + (length ? 1 : 0));
		      value.__actions__.push({
		        'func': thru,
		        'args': [interceptor],
		        'thisArg': undefined
		      });
		      return new LodashWrapper(value, this.__chain__).thru(function(array) {
		        if (length && !array.length) {
		          array.push(undefined);
		        }
		        return array;
		      });
		    });
		
		    /**
		     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
		     *
		     * @name chain
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * // A sequence without explicit chaining.
		     * _(users).head();
		     * // => { 'user': 'barney', 'age': 36 }
		     *
		     * // A sequence with explicit chaining.
		     * _(users)
		     *   .chain()
		     *   .head()
		     *   .pick('user')
		     *   .value();
		     * // => { 'user': 'barney' }
		     */
		    function wrapperChain() {
		      return chain(this);
		    }
		
		    /**
		     * Executes the chain sequence and returns the wrapped result.
		     *
		     * @name commit
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2];
		     * var wrapped = _(array).push(3);
		     *
		     * console.log(array);
		     * // => [1, 2]
		     *
		     * wrapped = wrapped.commit();
		     * console.log(array);
		     * // => [1, 2, 3]
		     *
		     * wrapped.last();
		     * // => 3
		     *
		     * console.log(array);
		     * // => [1, 2, 3]
		     */
		    function wrapperCommit() {
		      return new LodashWrapper(this.value(), this.__chain__);
		    }
		
		    /**
		     * Gets the next value on a wrapped object following the
		     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
		     *
		     * @name next
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the next iterator value.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 1 }
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 2 }
		     *
		     * wrapped.next();
		     * // => { 'done': true, 'value': undefined }
		     */
		    function wrapperNext() {
		      if (this.__values__ === undefined) {
		        this.__values__ = toArray(this.value());
		      }
		      var done = this.__index__ >= this.__values__.length,
		          value = done ? undefined : this.__values__[this.__index__++];
		
		      return { 'done': done, 'value': value };
		    }
		
		    /**
		     * Enables the wrapper to be iterable.
		     *
		     * @name Symbol.iterator
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped[Symbol.iterator]() === wrapped;
		     * // => true
		     *
		     * Array.from(wrapped);
		     * // => [1, 2]
		     */
		    function wrapperToIterator() {
		      return this;
		    }
		
		    /**
		     * Creates a clone of the chain sequence planting `value` as the wrapped value.
		     *
		     * @name plant
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @param {*} value The value to plant.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2]).map(square);
		     * var other = wrapped.plant([3, 4]);
		     *
		     * other.value();
		     * // => [9, 16]
		     *
		     * wrapped.value();
		     * // => [1, 4]
		     */
		    function wrapperPlant(value) {
		      var result,
		          parent = this;
		
		      while (parent instanceof baseLodash) {
		        var clone = wrapperClone(parent);
		        clone.__index__ = 0;
		        clone.__values__ = undefined;
		        if (result) {
		          previous.__wrapped__ = clone;
		        } else {
		          result = clone;
		        }
		        var previous = clone;
		        parent = parent.__wrapped__;
		      }
		      previous.__wrapped__ = value;
		      return result;
		    }
		
		    /**
		     * This method is the wrapper version of `_.reverse`.
		     *
		     * **Note:** This method mutates the wrapped array.
		     *
		     * @name reverse
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _(array).reverse().value()
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function wrapperReverse() {
		      var value = this.__wrapped__;
		      if (value instanceof LazyWrapper) {
		        var wrapped = value;
		        if (this.__actions__.length) {
		          wrapped = new LazyWrapper(this);
		        }
		        wrapped = wrapped.reverse();
		        wrapped.__actions__.push({
		          'func': thru,
		          'args': [reverse],
		          'thisArg': undefined
		        });
		        return new LodashWrapper(wrapped, this.__chain__);
		      }
		      return this.thru(reverse);
		    }
		
		    /**
		     * Executes the chain sequence to resolve the unwrapped value.
		     *
		     * @name value
		     * @memberOf _
		     * @since 0.1.0
		     * @alias toJSON, valueOf
		     * @category Seq
		     * @returns {*} Returns the resolved unwrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).value();
		     * // => [1, 2, 3]
		     */
		    function wrapperValue() {
		      return baseWrapperValue(this.__wrapped__, this.__actions__);
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the number of times the key was returned by `iteratee`. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': 1, '6': 2 }
		     *
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
		    });
		
		    /**
		     * Checks if `predicate` returns truthy for **all** elements of `collection`.
		     * Iteration is stopped once `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes'], Boolean);
		     * // => false
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.every(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.every(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.every(users, 'active');
		     * // => false
		     */
		    function every(collection, predicate, guard) {
		      var func = isArray(collection) ? arrayEvery : baseEvery;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }
		
		    /**
		     * Iterates over elements of `collection`, returning an array of all elements
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, { 'age': 36, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.filter(users, 'active');
		     * // => objects for ['barney']
		     */
		    function filter(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, getIteratee(predicate, 3));
		    }
		
		    /**
		     * Iterates over elements of `collection`, returning the first element
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to search.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': true },
		     *   { 'user': 'fred',    'age': 40, 'active': false },
		     *   { 'user': 'pebbles', 'age': 1,  'active': true }
		     * ];
		     *
		     * _.find(users, function(o) { return o.age < 40; });
		     * // => object for 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.find(users, { 'age': 1, 'active': true });
		     * // => object for 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.find(users, ['active', false]);
		     * // => object for 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.find(users, 'active');
		     * // => object for 'barney'
		     */
		    function find(collection, predicate) {
		      predicate = getIteratee(predicate, 3);
		      if (isArray(collection)) {
		        var index = baseFindIndex(collection, predicate);
		        return index > -1 ? collection[index] : undefined;
		      }
		      return baseFind(collection, predicate, baseEach);
		    }
		
		    /**
		     * This method is like `_.find` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to search.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(n) {
		     *   return n % 2 == 1;
		     * });
		     * // => 3
		     */
		    function findLast(collection, predicate) {
		      predicate = getIteratee(predicate, 3);
		      if (isArray(collection)) {
		        var index = baseFindIndex(collection, predicate, true);
		        return index > -1 ? collection[index] : undefined;
		      }
		      return baseFind(collection, predicate, baseEachRight);
		    }
		
		    /**
		     * Creates a flattened array of values by running each element in `collection`
		     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
		     * with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [n, n];
		     * }
		     *
		     * _.flatMap([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMap(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), 1);
		    }
		
		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDeep([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMapDeep(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), INFINITY);
		    }
		
		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The function invoked per iteration.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDepth([1, 2], duplicate, 2);
		     * // => [[1, 1], [2, 2]]
		     */
		    function flatMapDepth(collection, iteratee, depth) {
		      depth = depth === undefined ? 1 : toInteger(depth);
		      return baseFlatten(map(collection, iteratee), depth);
		    }
		
		    /**
		     * Iterates over elements of `collection` and invokes `iteratee` for each element.
		     * The iteratee is invoked with three arguments: (value, index|key, collection).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * **Note:** As with other "Collections" methods, objects with a "length"
		     * property are iterated like arrays. To avoid this behavior use `_.forIn`
		     * or `_.forOwn` for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias each
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @example
		     *
		     * _([1, 2]).forEach(function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `1` then `2`.
		     *
		     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forEach(collection, iteratee) {
		      return (typeof iteratee == 'function' && isArray(collection))
		        ? arrayEach(collection, iteratee)
		        : baseEach(collection, getIteratee(iteratee));
		    }
		
		    /**
		     * This method is like `_.forEach` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @alias eachRight
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @example
		     *
		     * _.forEachRight([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `2` then `1`.
		     */
		    function forEachRight(collection, iteratee) {
		      return (typeof iteratee == 'function' && isArray(collection))
		        ? arrayEachRight(collection, iteratee)
		        : baseEachRight(collection, getIteratee(iteratee));
		    }
		
		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The order of grouped values
		     * is determined by the order they occur in `collection`. The corresponding
		     * value of each key is an array of elements responsible for generating the
		     * key. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': [4.2], '6': [6.1, 6.3] }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        result[key].push(value);
		      } else {
		        result[key] = [value];
		      }
		    });
		
		    /**
		     * Checks if `value` is in `collection`. If `collection` is a string, it's
		     * checked for a substring of `value`, otherwise
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * is used for equality comparisons. If `fromIndex` is negative, it's used as
		     * the offset from the end of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to search.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {boolean} Returns `true` if `value` is found, else `false`.
		     * @example
		     *
		     * _.includes([1, 2, 3], 1);
		     * // => true
		     *
		     * _.includes([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
		     * // => true
		     *
		     * _.includes('pebbles', 'eb');
		     * // => true
		     */
		    function includes(collection, value, fromIndex, guard) {
		      collection = isArrayLike(collection) ? collection : values(collection);
		      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
		
		      var length = collection.length;
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return isString(collection)
		        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		    }
		
		    /**
		     * Invokes the method at `path` of each element in `collection`, returning
		     * an array of the results of each invoked method. Any additional arguments
		     * are provided to each invoked method. If `methodName` is a function, it's
		     * invoked for and `this` bound to, each element in `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|string} path The path of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [args] The arguments to invoke each method with.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invokeMap([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    var invokeMap = rest(function(collection, path, args) {
		      var index = -1,
		          isFunc = typeof path == 'function',
		          isProp = isKey(path),
		          result = isArrayLike(collection) ? Array(collection.length) : [];
		
		      baseEach(collection, function(value) {
		        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
		        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
		      });
		      return result;
		    });
		
		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the last element responsible for generating the key. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var array = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.keyBy(array, function(o) {
		     *   return String.fromCharCode(o.code);
		     * });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.keyBy(array, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     */
		    var keyBy = createAggregator(function(result, value, key) {
		      result[key] = value;
		    });
		
		    /**
		     * Creates an array of values by running each element in `collection` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		     *
		     * The guarded methods are:
		     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * _.map([4, 8], square);
		     * // => [16, 64]
		     *
		     * _.map({ 'a': 4, 'b': 8 }, square);
		     * // => [16, 64] (iteration order is not guaranteed)
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, 'user');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, iteratee) {
		      var func = isArray(collection) ? arrayMap : baseMap;
		      return func(collection, getIteratee(iteratee, 3));
		    }
		
		    /**
		     * This method is like `_.sortBy` except that it allows specifying the sort
		     * orders of the iteratees to sort by. If `orders` is unspecified, all values
		     * are sorted in ascending order. Otherwise, specify an order of "desc" for
		     * descending or "asc" for ascending sort order of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @param {string[]} [orders] The sort orders of `iteratees`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 34 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 36 }
		     * ];
		     *
		     * // Sort by `user` in ascending order and by `age` in descending order.
		     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    function orderBy(collection, iteratees, orders, guard) {
		      if (collection == null) {
		        return [];
		      }
		      if (!isArray(iteratees)) {
		        iteratees = iteratees == null ? [] : [iteratees];
		      }
		      orders = guard ? undefined : orders;
		      if (!isArray(orders)) {
		        orders = orders == null ? [] : [orders];
		      }
		      return baseOrderBy(collection, iteratees, orders);
		    }
		
		    /**
		     * Creates an array of elements split into two groups, the first of which
		     * contains elements `predicate` returns truthy for, the second of which
		     * contains elements `predicate` returns falsey for. The predicate is
		     * invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the array of grouped elements.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': false },
		     *   { 'user': 'fred',    'age': 40, 'active': true },
		     *   { 'user': 'pebbles', 'age': 1,  'active': false }
		     * ];
		     *
		     * _.partition(users, function(o) { return o.active; });
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.partition(users, { 'age': 1, 'active': false });
		     * // => objects for [['pebbles'], ['barney', 'fred']]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.partition(users, ['active', false]);
		     * // => objects for [['barney', 'pebbles'], ['fred']]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.partition(users, 'active');
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     */
		    var partition = createAggregator(function(result, value, key) {
		      result[key ? 0 : 1].push(value);
		    }, function() { return [[], []]; });
		
		    /**
		     * Reduces `collection` to a value which is the accumulated result of running
		     * each element in `collection` thru `iteratee`, where each successive
		     * invocation is supplied the return value of the previous. If `accumulator`
		     * is not given, the first element of `collection` is used as the initial
		     * value. The iteratee is invoked with four arguments:
		     * (accumulator, value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.reduce`, `_.reduceRight`, and `_.transform`.
		     *
		     * The guarded methods are:
		     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
		     * and `sortBy`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.reduce([1, 2], function(sum, n) {
		     *   return sum + n;
		     * }, 0);
		     * // => 3
		     *
		     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     *   return result;
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
		     */
		    function reduce(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduce : baseReduce,
		          initAccum = arguments.length < 3;
		
		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
		    }
		
		    /**
		     * This method is like `_.reduce` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * var array = [[0, 1], [2, 3], [4, 5]];
		     *
		     * _.reduceRight(array, function(flattened, other) {
		     *   return flattened.concat(other);
		     * }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduceRight : baseReduce,
		          initAccum = arguments.length < 3;
		
		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
		    }
		
		    /**
		     * The opposite of `_.filter`; this method returns the elements of `collection`
		     * that `predicate` does **not** return truthy for.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': true }
		     * ];
		     *
		     * _.reject(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.reject(users, { 'age': 40, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.reject(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.reject(users, 'active');
		     * // => objects for ['barney']
		     */
		    function reject(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      predicate = getIteratee(predicate, 3);
		      return func(collection, function(value, index, collection) {
		        return !predicate(value, index, collection);
		      });
		    }
		
		    /**
		     * Gets a random element from `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     */
		    function sample(collection) {
		      var array = isArrayLike(collection) ? collection : values(collection),
		          length = array.length;
		
		      return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
		    }
		
		    /**
		     * Gets `n` random elements at unique keys from `collection` up to the
		     * size of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} [n=1] The number of elements to sample.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the random elements.
		     * @example
		     *
		     * _.sampleSize([1, 2, 3], 2);
		     * // => [3, 1]
		     *
		     * _.sampleSize([1, 2, 3], 4);
		     * // => [2, 3, 1]
		     */
		    function sampleSize(collection, n, guard) {
		      var index = -1,
		          result = toArray(collection),
		          length = result.length,
		          lastIndex = length - 1;
		
		      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
		        n = 1;
		      } else {
		        n = baseClamp(toInteger(n), 0, length);
		      }
		      while (++index < n) {
		        var rand = baseRandom(index, lastIndex),
		            value = result[rand];
		
		        result[rand] = result[index];
		        result[index] = value;
		      }
		      result.length = n;
		      return result;
		    }
		
		    /**
		     * Creates an array of shuffled values, using a version of the
		     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4]);
		     * // => [4, 1, 3, 2]
		     */
		    function shuffle(collection) {
		      return sampleSize(collection, MAX_ARRAY_LENGTH);
		    }
		
		    /**
		     * Gets the size of `collection` by returning its length for array-like
		     * values or the number of own enumerable string keyed properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @returns {number} Returns the collection size.
		     * @example
		     *
		     * _.size([1, 2, 3]);
		     * // => 3
		     *
		     * _.size({ 'a': 1, 'b': 2 });
		     * // => 2
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      if (collection == null) {
		        return 0;
		      }
		      if (isArrayLike(collection)) {
		        var result = collection.length;
		        return (result && isString(collection)) ? stringSize(collection) : result;
		      }
		      if (isObjectLike(collection)) {
		        var tag = getTag(collection);
		        if (tag == mapTag || tag == setTag) {
		          return collection.size;
		        }
		      }
		      return keys(collection).length;
		    }
		
		    /**
		     * Checks if `predicate` returns truthy for **any** element of `collection`.
		     * Iteration is stopped once `predicate` returns truthy. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var users = [
		     *   { 'user': 'barney', 'active': true },
		     *   { 'user': 'fred',   'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.some(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.some(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.some(users, 'active');
		     * // => true
		     */
		    function some(collection, predicate, guard) {
		      var func = isArray(collection) ? arraySome : baseSome;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }
		
		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection thru each iteratee. This method
		     * performs a stable sort, that is, it preserves the original sort order of
		     * equal elements. The iteratees are invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
		     *  [iteratees=[_.identity]] The iteratees to sort by.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 34 }
		     * ];
		     *
		     * _.sortBy(users, function(o) { return o.user; });
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     *
		     * _.sortBy(users, ['user', 'age']);
		     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
		     *
		     * _.sortBy(users, 'user', function(o) {
		     *   return Math.floor(o.age / 10);
		     * });
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    var sortBy = rest(function(collection, iteratees) {
		      if (collection == null) {
		        return [];
		      }
		      var length = iteratees.length;
		      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		        iteratees = [];
		      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		        iteratees = [iteratees[0]];
		      }
		      iteratees = (iteratees.length == 1 && isArray(iteratees[0]))
		        ? iteratees[0]
		        : baseFlatten(iteratees, 1, isFlattenableIteratee);
		
		      return baseOrderBy(collection, iteratees, []);
		    });
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Gets the timestamp of the number of milliseconds that have elapsed since
		     * the Unix epoch (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @type {Function}
		     * @category Date
		     * @returns {number} Returns the timestamp.
		     * @example
		     *
		     * _.defer(function(stamp) {
		     *   console.log(_.now() - stamp);
		     * }, _.now());
		     * // => Logs the number of milliseconds it took for the deferred function to be invoked.
		     */
		    var now = Date.now;
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * The opposite of `_.before`; this method creates a function that invokes
		     * `func` once it's called `n` or more times.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {number} n The number of calls before `func` is invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => Logs 'done saving!' after the two async saves have completed.
		     */
		    function after(n, func) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }
		
		    /**
		     * Creates a function that invokes `func`, with up to `n` arguments,
		     * ignoring any additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @param {number} [n=func.length] The arity cap.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
		     * // => [6, 8, 10]
		     */
		    function ary(func, n, guard) {
		      n = guard ? undefined : n;
		      n = (func && n == null) ? func.length : n;
		      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
		    }
		
		    /**
		     * Creates a function that invokes `func`, with the `this` binding and arguments
		     * of the created function, while it's called less than `n` times. Subsequent
		     * calls to the created function return the result of the last `func` invocation.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {number} n The number of calls at which `func` is no longer invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * jQuery(element).on('click', _.before(5, addContactToList));
		     * // => allows adding up to 4 contacts to the list
		     */
		    function before(n, func) {
		      var result;
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n > 0) {
		          result = func.apply(this, arguments);
		        }
		        if (n <= 1) {
		          func = undefined;
		        }
		        return result;
		      };
		    }
		
		    /**
		     * Creates a function that invokes `func` with the `this` binding of `thisArg`
		     * and `partials` prepended to the arguments it receives.
		     *
		     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** Unlike native `Function#bind` this method doesn't set the "length"
		     * property of bound functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to bind.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var greet = function(greeting, punctuation) {
		     *   return greeting + ' ' + this.user + punctuation;
		     * };
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * var bound = _.bind(greet, object, 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bind(greet, object, _, '!');
		     * bound('hi');
		     * // => 'hi fred!'
		     */
		    var bind = rest(function(func, thisArg, partials) {
		      var bitmask = BIND_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getPlaceholder(bind));
		        bitmask |= PARTIAL_FLAG;
		      }
		      return createWrapper(func, bitmask, thisArg, partials, holders);
		    });
		
		    /**
		     * Creates a function that invokes the method at `object[key]` with `partials`
		     * prepended to the arguments it receives.
		     *
		     * This method differs from `_.bind` by allowing bound functions to reference
		     * methods that may be redefined or don't yet exist. See
		     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
		     * for more details.
		     *
		     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Function
		     * @param {Object} object The object to invoke the method on.
		     * @param {string} key The key of the method.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'user': 'fred',
		     *   'greet': function(greeting, punctuation) {
		     *     return greeting + ' ' + this.user + punctuation;
		     *   }
		     * };
		     *
		     * var bound = _.bindKey(object, 'greet', 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * object.greet = function(greeting, punctuation) {
		     *   return greeting + 'ya ' + this.user + punctuation;
		     * };
		     *
		     * bound('!');
		     * // => 'hiya fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bindKey(object, 'greet', _, '!');
		     * bound('hi');
		     * // => 'hiya fred!'
		     */
		    var bindKey = rest(function(object, key, partials) {
		      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getPlaceholder(bindKey));
		        bitmask |= PARTIAL_FLAG;
		      }
		      return createWrapper(key, bitmask, object, partials, holders);
		    });
		
		    /**
		     * Creates a function that accepts arguments of `func` and either invokes
		     * `func` returning its result, if at least `arity` number of arguments have
		     * been provided, or returns a function that accepts the remaining `func`
		     * arguments, and so on. The arity of `func` may be specified if `func.length`
		     * is not sufficient.
		     *
		     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curry(abc);
		     *
		     * curried(1)(2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(1)(_, 3)(2);
		     * // => [1, 2, 3]
		     */
		    function curry(func, arity, guard) {
		      arity = guard ? undefined : arity;
		      var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
		      result.placeholder = curry.placeholder;
		      return result;
		    }
		
		    /**
		     * This method is like `_.curry` except that arguments are applied to `func`
		     * in the manner of `_.partialRight` instead of `_.partial`.
		     *
		     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curryRight(abc);
		     *
		     * curried(3)(2)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(2, 3)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(3)(1, _)(2);
		     * // => [1, 2, 3]
		     */
		    function curryRight(func, arity, guard) {
		      arity = guard ? undefined : arity;
		      var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
		      result.placeholder = curryRight.placeholder;
		      return result;
		    }
		
		    /**
		     * Creates a debounced function that delays invoking `func` until after `wait`
		     * milliseconds have elapsed since the last time the debounced function was
		     * invoked. The debounced function comes with a `cancel` method to cancel
		     * delayed `func` invocations and a `flush` method to immediately invoke them.
		     * Provide an options object to indicate whether `func` should be invoked on
		     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
		     * with the last arguments provided to the debounced function. Subsequent calls
		     * to the debounced function return the result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
		     * on the trailing edge of the timeout only if the debounced function is
		     * invoked more than once during the `wait` timeout.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.debounce` and `_.throttle`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to debounce.
		     * @param {number} [wait=0] The number of milliseconds to delay.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=false]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {number} [options.maxWait]
		     *  The maximum time `func` is allowed to be delayed before it's invoked.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // Avoid costly calculations while the window size is in flux.
		     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
		     *
		     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
		     * jQuery(element).on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * }));
		     *
		     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
		     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
		     * var source = new EventSource('/stream');
		     * jQuery(source).on('message', debounced);
		     *
		     * // Cancel the trailing debounced invocation.
		     * jQuery(window).on('popstate', debounced.cancel);
		     */
		    function debounce(func, wait, options) {
		      var lastArgs,
		          lastThis,
		          maxWait,
		          result,
		          timerId,
		          lastCallTime = 0,
		          lastInvokeTime = 0,
		          leading = false,
		          maxing = false,
		          trailing = true;
		
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      wait = toNumber(wait) || 0;
		      if (isObject(options)) {
		        leading = !!options.leading;
		        maxing = 'maxWait' in options;
		        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		
		      function invokeFunc(time) {
		        var args = lastArgs,
		            thisArg = lastThis;
		
		        lastArgs = lastThis = undefined;
		        lastInvokeTime = time;
		        result = func.apply(thisArg, args);
		        return result;
		      }
		
		      function leadingEdge(time) {
		        // Reset any `maxWait` timer.
		        lastInvokeTime = time;
		        // Start the timer for the trailing edge.
		        timerId = setTimeout(timerExpired, wait);
		        // Invoke the leading edge.
		        return leading ? invokeFunc(time) : result;
		      }
		
		      function remainingWait(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime,
		            result = wait - timeSinceLastCall;
		
		        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
		      }
		
		      function shouldInvoke(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime;
		
		        // Either this is the first call, activity has stopped and we're at the
		        // trailing edge, the system time has gone backwards and we're treating
		        // it as the trailing edge, or we've hit the `maxWait` limit.
		        return (!lastCallTime || (timeSinceLastCall >= wait) ||
		          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		      }
		
		      function timerExpired() {
		        var time = now();
		        if (shouldInvoke(time)) {
		          return trailingEdge(time);
		        }
		        // Restart the timer.
		        timerId = setTimeout(timerExpired, remainingWait(time));
		      }
		
		      function trailingEdge(time) {
		        clearTimeout(timerId);
		        timerId = undefined;
		
		        // Only invoke if we have `lastArgs` which means `func` has been
		        // debounced at least once.
		        if (trailing && lastArgs) {
		          return invokeFunc(time);
		        }
		        lastArgs = lastThis = undefined;
		        return result;
		      }
		
		      function cancel() {
		        if (timerId !== undefined) {
		          clearTimeout(timerId);
		        }
		        lastCallTime = lastInvokeTime = 0;
		        lastArgs = lastThis = timerId = undefined;
		      }
		
		      function flush() {
		        return timerId === undefined ? result : trailingEdge(now());
		      }
		
		      function debounced() {
		        var time = now(),
		            isInvoking = shouldInvoke(time);
		
		        lastArgs = arguments;
		        lastThis = this;
		        lastCallTime = time;
		
		        if (isInvoking) {
		          if (timerId === undefined) {
		            return leadingEdge(lastCallTime);
		          }
		          if (maxing) {
		            // Handle invocations in a tight loop.
		            clearTimeout(timerId);
		            timerId = setTimeout(timerExpired, wait);
		            return invokeFunc(lastCallTime);
		          }
		        }
		        if (timerId === undefined) {
		          timerId = setTimeout(timerExpired, wait);
		        }
		        return result;
		      }
		      debounced.cancel = cancel;
		      debounced.flush = flush;
		      return debounced;
		    }
		
		    /**
		     * Defers invoking the `func` until the current call stack has cleared. Any
		     * additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to defer.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) {
		     *   console.log(text);
		     * }, 'deferred');
		     * // => Logs 'deferred' after one or more milliseconds.
		     */
		    var defer = rest(function(func, args) {
		      return baseDelay(func, 1, args);
		    });
		
		    /**
		     * Invokes `func` after `wait` milliseconds. Any additional arguments are
		     * provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) {
		     *   console.log(text);
		     * }, 1000, 'later');
		     * // => Logs 'later' after one second.
		     */
		    var delay = rest(function(func, wait, args) {
		      return baseDelay(func, toNumber(wait) || 0, args);
		    });
		
		    /**
		     * Creates a function that invokes `func` with arguments reversed.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to flip arguments for.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var flipped = _.flip(function() {
		     *   return _.toArray(arguments);
		     * });
		     *
		     * flipped('a', 'b', 'c', 'd');
		     * // => ['d', 'c', 'b', 'a']
		     */
		    function flip(func) {
		      return createWrapper(func, FLIP_FLAG);
		    }
		
		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided, it determines the cache key for storing the result based on the
		     * arguments provided to the memoized function. By default, the first argument
		     * provided to the memoized function is used as the map cache key. The `func`
		     * is invoked with the `this` binding of the memoized function.
		     *
		     * **Note:** The cache is exposed as the `cache` property on the memoized
		     * function. Its creation may be customized by replacing the `_.memoize.Cache`
		     * constructor with one whose instances implement the
		     * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
		     * method interface of `delete`, `get`, `has`, and `set`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] The function to resolve the cache key.
		     * @returns {Function} Returns the new memoizing function.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     * var other = { 'c': 3, 'd': 4 };
		     *
		     * var values = _.memoize(_.values);
		     * values(object);
		     * // => [1, 2]
		     *
		     * values(other);
		     * // => [3, 4]
		     *
		     * object.a = 2;
		     * values(object);
		     * // => [1, 2]
		     *
		     * // Modify the result cache.
		     * values.cache.set(object, ['a', 'b']);
		     * values(object);
		     * // => ['a', 'b']
		     *
		     * // Replace `_.memoize.Cache`.
		     * _.memoize.Cache = WeakMap;
		     */
		    function memoize(func, resolver) {
		      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var memoized = function() {
		        var args = arguments,
		            key = resolver ? resolver.apply(this, args) : args[0],
		            cache = memoized.cache;
		
		        if (cache.has(key)) {
		          return cache.get(key);
		        }
		        var result = func.apply(this, args);
		        memoized.cache = cache.set(key, result);
		        return result;
		      };
		      memoized.cache = new (memoize.Cache || MapCache);
		      return memoized;
		    }
		
		    // Assign cache to `_.memoize`.
		    memoize.Cache = MapCache;
		
		    /**
		     * Creates a function that negates the result of the predicate `func`. The
		     * `func` predicate is invoked with the `this` binding and arguments of the
		     * created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} predicate The predicate to negate.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function isEven(n) {
		     *   return n % 2 == 0;
		     * }
		     *
		     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		     * // => [1, 3, 5]
		     */
		    function negate(predicate) {
		      if (typeof predicate != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return function() {
		        return !predicate.apply(this, arguments);
		      };
		    }
		
		    /**
		     * Creates a function that is restricted to invoking `func` once. Repeat calls
		     * to the function return the value of the first invocation. The `func` is
		     * invoked with the `this` binding and arguments of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // `initialize` invokes `createApplication` once
		     */
		    function once(func) {
		      return before(2, func);
		    }
		
		    /**
		     * Creates a function that invokes `func` with arguments transformed by
		     * corresponding `transforms`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Function
		     * @param {Function} func The function to wrap.
		     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
		     *  [transforms[_.identity]] The functions to transform.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function doubled(n) {
		     *   return n * 2;
		     * }
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var func = _.overArgs(function(x, y) {
		     *   return [x, y];
		     * }, square, doubled);
		     *
		     * func(9, 3);
		     * // => [81, 6]
		     *
		     * func(10, 5);
		     * // => [100, 10]
		     */
		    var overArgs = rest(function(func, transforms) {
		      transforms = (transforms.length == 1 && isArray(transforms[0]))
		        ? arrayMap(transforms[0], baseUnary(getIteratee()))
		        : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));
		
		      var funcsLength = transforms.length;
		      return rest(function(args) {
		        var index = -1,
		            length = nativeMin(args.length, funcsLength);
		
		        while (++index < length) {
		          args[index] = transforms[index].call(this, args[index]);
		        }
		        return apply(func, this, args);
		      });
		    });
		
		    /**
		     * Creates a function that invokes `func` with `partials` prepended to the
		     * arguments it receives. This method is like `_.bind` except it does **not**
		     * alter the `this` binding.
		     *
		     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.2.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * var greet = function(greeting, name) {
		     *   return greeting + ' ' + name;
		     * };
		     *
		     * var sayHelloTo = _.partial(greet, 'hello');
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     *
		     * // Partially applied with placeholders.
		     * var greetFred = _.partial(greet, _, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     */
		    var partial = rest(function(func, partials) {
		      var holders = replaceHolders(partials, getPlaceholder(partial));
		      return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
		    });
		
		    /**
		     * This method is like `_.partial` except that partially applied arguments
		     * are appended to the arguments it receives.
		     *
		     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * var greet = function(greeting, name) {
		     *   return greeting + ' ' + name;
		     * };
		     *
		     * var greetFred = _.partialRight(greet, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     *
		     * // Partially applied with placeholders.
		     * var sayHelloTo = _.partialRight(greet, 'hello', _);
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     */
		    var partialRight = rest(function(func, partials) {
		      var holders = replaceHolders(partials, getPlaceholder(partialRight));
		      return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
		    });
		
		    /**
		     * Creates a function that invokes `func` with arguments arranged according
		     * to the specified `indexes` where the argument value at the first index is
		     * provided as the first argument, the argument value at the second index is
		     * provided as the second argument, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to rearrange arguments for.
		     * @param {...(number|number[])} indexes The arranged argument indexes.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var rearged = _.rearg(function(a, b, c) {
		     *   return [a, b, c];
		     * }, 2, 0, 1);
		     *
		     * rearged('b', 'c', 'a')
		     * // => ['a', 'b', 'c']
		     */
		    var rearg = rest(function(func, indexes) {
		      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
		    });
		
		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * created function and arguments from `start` and beyond provided as
		     * an array.
		     *
		     * **Note:** This method is based on the
		     * [rest parameter](https://mdn.io/rest_parameters).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.rest(function(what, names) {
		     *   return what + ' ' + _.initial(names).join(', ') +
		     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
		     * });
		     *
		     * say('hello', 'fred', 'barney', 'pebbles');
		     * // => 'hello fred, barney, & pebbles'
		     */
		    function rest(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
		      return function() {
		        var args = arguments,
		            index = -1,
		            length = nativeMax(args.length - start, 0),
		            array = Array(length);
		
		        while (++index < length) {
		          array[index] = args[start + index];
		        }
		        switch (start) {
		          case 0: return func.call(this, array);
		          case 1: return func.call(this, args[0], array);
		          case 2: return func.call(this, args[0], args[1], array);
		        }
		        var otherArgs = Array(start + 1);
		        index = -1;
		        while (++index < start) {
		          otherArgs[index] = args[index];
		        }
		        otherArgs[start] = array;
		        return apply(func, this, otherArgs);
		      };
		    }
		
		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * create function and an array of arguments much like
		     * [`Function#apply`](http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply).
		     *
		     * **Note:** This method is based on the
		     * [spread operator](https://mdn.io/spread_operator).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Function
		     * @param {Function} func The function to spread arguments over.
		     * @param {number} [start=0] The start position of the spread.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.spread(function(who, what) {
		     *   return who + ' says ' + what;
		     * });
		     *
		     * say(['fred', 'hello']);
		     * // => 'fred says hello'
		     *
		     * var numbers = Promise.all([
		     *   Promise.resolve(40),
		     *   Promise.resolve(36)
		     * ]);
		     *
		     * numbers.then(_.spread(function(x, y) {
		     *   return x + y;
		     * }));
		     * // => a Promise of 76
		     */
		    function spread(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
		      return rest(function(args) {
		        var array = args[start],
		            otherArgs = castSlice(args, 0, start);
		
		        if (array) {
		          arrayPush(otherArgs, array);
		        }
		        return apply(func, this, otherArgs);
		      });
		    }
		
		    /**
		     * Creates a throttled function that only invokes `func` at most once per
		     * every `wait` milliseconds. The throttled function comes with a `cancel`
		     * method to cancel delayed `func` invocations and a `flush` method to
		     * immediately invoke them. Provide an options object to indicate whether
		     * `func` should be invoked on the leading and/or trailing edge of the `wait`
		     * timeout. The `func` is invoked with the last arguments provided to the
		     * throttled function. Subsequent calls to the throttled function return the
		     * result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the throttled function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.throttle` and `_.debounce`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to throttle.
		     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=true]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // Avoid excessively updating the position while scrolling.
		     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
		     *
		     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
		     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
		     * jQuery(element).on('click', throttled);
		     *
		     * // Cancel the trailing throttled invocation.
		     * jQuery(window).on('popstate', throttled.cancel);
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;
		
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      if (isObject(options)) {
		        leading = 'leading' in options ? !!options.leading : leading;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		      return debounce(func, wait, {
		        'leading': leading,
		        'maxWait': wait,
		        'trailing': trailing
		      });
		    }
		
		    /**
		     * Creates a function that accepts up to one argument, ignoring any
		     * additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.unary(parseInt));
		     * // => [6, 8, 10]
		     */
		    function unary(func) {
		      return ary(func, 1);
		    }
		
		    /**
		     * Creates a function that provides `value` to the wrapper function as its
		     * first argument. Any additional arguments provided to the function are
		     * appended to those provided to the wrapper function. The wrapper is invoked
		     * with the `this` binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {*} value The value to wrap.
		     * @param {Function} [wrapper=identity] The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('fred, barney, & pebbles');
		     * // => '<p>fred, barney, &amp; pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      wrapper = wrapper == null ? identity : wrapper;
		      return partial(wrapper, value);
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Casts `value` as an array if it's not one.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Lang
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast array.
		     * @example
		     *
		     * _.castArray(1);
		     * // => [1]
		     *
		     * _.castArray({ 'a': 1 });
		     * // => [{ 'a': 1 }]
		     *
		     * _.castArray('abc');
		     * // => ['abc']
		     *
		     * _.castArray(null);
		     * // => [null]
		     *
		     * _.castArray(undefined);
		     * // => [undefined]
		     *
		     * _.castArray();
		     * // => []
		     *
		     * var array = [1, 2, 3];
		     * console.log(_.castArray(array) === array);
		     * // => true
		     */
		    function castArray() {
		      if (!arguments.length) {
		        return [];
		      }
		      var value = arguments[0];
		      return isArray(value) ? value : [value];
		    }
		
		    /**
		     * Creates a shallow clone of `value`.
		     *
		     * **Note:** This method is loosely based on the
		     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
		     * and supports cloning arrays, array buffers, booleans, date objects, maps,
		     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
		     * arrays. The own enumerable properties of `arguments` objects are cloned
		     * as plain objects. An empty object is returned for uncloneable values such
		     * as error objects, functions, DOM nodes, and WeakMaps.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @returns {*} Returns the cloned value.
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var shallow = _.clone(objects);
		     * console.log(shallow[0] === objects[0]);
		     * // => true
		     */
		    function clone(value) {
		      return baseClone(value, false, true);
		    }
		
		    /**
		     * This method is like `_.clone` except that it accepts `customizer` which
		     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
		     * cloning is handled by the method instead. The `customizer` is invoked with
		     * up to four arguments; (value [, index|key, object, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the cloned value.
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(false);
		     *   }
		     * }
		     *
		     * var el = _.cloneWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 0
		     */
		    function cloneWith(value, customizer) {
		      return baseClone(value, false, true, customizer);
		    }
		
		    /**
		     * This method is like `_.clone` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @returns {*} Returns the deep cloned value.
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var deep = _.cloneDeep(objects);
		     * console.log(deep[0] === objects[0]);
		     * // => false
		     */
		    function cloneDeep(value) {
		      return baseClone(value, true, true);
		    }
		
		    /**
		     * This method is like `_.cloneWith` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the deep cloned value.
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(true);
		     *   }
		     * }
		     *
		     * var el = _.cloneDeepWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 20
		     */
		    function cloneDeepWith(value, customizer) {
		      return baseClone(value, true, true, customizer);
		    }
		
		    /**
		     * Performs a
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		     * comparison between two values to determine if they are equivalent.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'user': 'fred' };
		     * var other = { 'user': 'fred' };
		     *
		     * _.eq(object, object);
		     * // => true
		     *
		     * _.eq(object, other);
		     * // => false
		     *
		     * _.eq('a', 'a');
		     * // => true
		     *
		     * _.eq('a', Object('a'));
		     * // => false
		     *
		     * _.eq(NaN, NaN);
		     * // => true
		     */
		    function eq(value, other) {
		      return value === other || (value !== value && other !== other);
		    }
		
		    /**
		     * Checks if `value` is greater than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     * @example
		     *
		     * _.gt(3, 1);
		     * // => true
		     *
		     * _.gt(3, 3);
		     * // => false
		     *
		     * _.gt(1, 3);
		     * // => false
		     */
		    function gt(value, other) {
		      return value > other;
		    }
		
		    /**
		     * Checks if `value` is greater than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than or equal to
		     *  `other`, else `false`.
		     * @example
		     *
		     * _.gte(3, 1);
		     * // => true
		     *
		     * _.gte(3, 3);
		     * // => true
		     *
		     * _.gte(1, 3);
		     * // => false
		     */
		    function gte(value, other) {
		      return value >= other;
		    }
		
		    /**
		     * Checks if `value` is likely an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isArguments(function() { return arguments; }());
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    function isArguments(value) {
		      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
		      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
		        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
		    }
		
		    /**
		     * Checks if `value` is classified as an `Array` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @type {Function}
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     *
		     * _.isArray(document.body.children);
		     * // => false
		     *
		     * _.isArray('abc');
		     * // => false
		     *
		     * _.isArray(_.noop);
		     * // => false
		     */
		    var isArray = Array.isArray;
		
		    /**
		     * Checks if `value` is classified as an `ArrayBuffer` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayBuffer(new ArrayBuffer(2));
		     * // => true
		     *
		     * _.isArrayBuffer(new Array(2));
		     * // => false
		     */
		    function isArrayBuffer(value) {
		      return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
		    }
		
		    /**
		     * Checks if `value` is array-like. A value is considered array-like if it's
		     * not a function and has a `value.length` that's an integer greater than or
		     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		     * @example
		     *
		     * _.isArrayLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLike(document.body.children);
		     * // => true
		     *
		     * _.isArrayLike('abc');
		     * // => true
		     *
		     * _.isArrayLike(_.noop);
		     * // => false
		     */
		    function isArrayLike(value) {
		      return value != null && isLength(getLength(value)) && !isFunction(value);
		    }
		
		    /**
		     * This method is like `_.isArrayLike` except that it also checks if `value`
		     * is an object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array-like object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayLikeObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLikeObject(document.body.children);
		     * // => true
		     *
		     * _.isArrayLikeObject('abc');
		     * // => false
		     *
		     * _.isArrayLikeObject(_.noop);
		     * // => false
		     */
		    function isArrayLikeObject(value) {
		      return isObjectLike(value) && isArrayLike(value);
		    }
		
		    /**
		     * Checks if `value` is classified as a boolean primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isBoolean(false);
		     * // => true
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        (isObjectLike(value) && objectToString.call(value) == boolTag);
		    }
		
		    /**
		     * Checks if `value` is a buffer.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		     * @example
		     *
		     * _.isBuffer(new Buffer(2));
		     * // => true
		     *
		     * _.isBuffer(new Uint8Array(2));
		     * // => false
		     */
		    var isBuffer = !Buffer ? constant(false) : function(value) {
		      return value instanceof Buffer;
		    };
		
		    /**
		     * Checks if `value` is classified as a `Date` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     *
		     * _.isDate('Mon April 23 2012');
		     * // => false
		     */
		    function isDate(value) {
		      return isObjectLike(value) && objectToString.call(value) == dateTag;
		    }
		
		    /**
		     * Checks if `value` is likely a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a DOM element,
		     *  else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     *
		     * _.isElement('<body>');
		     * // => false
		     */
		    function isElement(value) {
		      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
		    }
		
		    /**
		     * Checks if `value` is an empty object, collection, map, or set.
		     *
		     * Objects are considered empty if they have no own enumerable string keyed
		     * properties.
		     *
		     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		     * jQuery-like collections are considered empty if they have a `length` of `0`.
		     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty(null);
		     * // => true
		     *
		     * _.isEmpty(true);
		     * // => true
		     *
		     * _.isEmpty(1);
		     * // => true
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({ 'a': 1 });
		     * // => false
		     */
		    function isEmpty(value) {
		      if (isArrayLike(value) &&
		          (isArray(value) || isString(value) || isFunction(value.splice) ||
		            isArguments(value) || isBuffer(value))) {
		        return !value.length;
		      }
		      if (isObjectLike(value)) {
		        var tag = getTag(value);
		        if (tag == mapTag || tag == setTag) {
		          return !value.size;
		        }
		      }
		      for (var key in value) {
		        if (hasOwnProperty.call(value, key)) {
		          return false;
		        }
		      }
		      return !(nonEnumShadows && keys(value).length);
		    }
		
		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent.
		     *
		     * **Note:** This method supports comparing arrays, array buffers, booleans,
		     * date objects, error objects, maps, numbers, `Object` objects, regexes,
		     * sets, strings, symbols, and typed arrays. `Object` objects are compared
		     * by their own, not inherited, enumerable properties. Functions and DOM
		     * nodes are **not** supported.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent,
		     *  else `false`.
		     * @example
		     *
		     * var object = { 'user': 'fred' };
		     * var other = { 'user': 'fred' };
		     *
		     * _.isEqual(object, other);
		     * // => true
		     *
		     * object === other;
		     * // => false
		     */
		    function isEqual(value, other) {
		      return baseIsEqual(value, other);
		    }
		
		    /**
		     * This method is like `_.isEqual` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with up to
		     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if the values are equivalent,
		     *  else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, othValue) {
		     *   if (isGreeting(objValue) && isGreeting(othValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var array = ['hello', 'goodbye'];
		     * var other = ['hi', 'goodbye'];
		     *
		     * _.isEqualWith(array, other, customizer);
		     * // => true
		     */
		    function isEqualWith(value, other, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined;
		      var result = customizer ? customizer(value, other) : undefined;
		      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
		    }
		
		    /**
		     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
		     * `SyntaxError`, `TypeError`, or `URIError` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an error object,
		     *  else `false`.
		     * @example
		     *
		     * _.isError(new Error);
		     * // => true
		     *
		     * _.isError(Error);
		     * // => false
		     */
		    function isError(value) {
		      if (!isObjectLike(value)) {
		        return false;
		      }
		      return (objectToString.call(value) == errorTag) ||
		        (typeof value.message == 'string' && typeof value.name == 'string');
		    }
		
		    /**
		     * Checks if `value` is a finite primitive number.
		     *
		     * **Note:** This method is based on
		     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a finite number,
		     *  else `false`.
		     * @example
		     *
		     * _.isFinite(3);
		     * // => true
		     *
		     * _.isFinite(Number.MAX_VALUE);
		     * // => true
		     *
		     * _.isFinite(3.14);
		     * // => true
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     */
		    function isFinite(value) {
		      return typeof value == 'number' && nativeIsFinite(value);
		    }
		
		    /**
		     * Checks if `value` is classified as a `Function` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     *
		     * _.isFunction(/abc/);
		     * // => false
		     */
		    function isFunction(value) {
		      // The use of `Object#toString` avoids issues with the `typeof` operator
		      // in Safari 8 which returns 'object' for typed array and weak map constructors,
		      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
		      var tag = isObject(value) ? objectToString.call(value) : '';
		      return tag == funcTag || tag == genTag;
		    }
		
		    /**
		     * Checks if `value` is an integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		     * @example
		     *
		     * _.isInteger(3);
		     * // => true
		     *
		     * _.isInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isInteger(Infinity);
		     * // => false
		     *
		     * _.isInteger('3');
		     * // => false
		     */
		    function isInteger(value) {
		      return typeof value == 'number' && value == toInteger(value);
		    }
		
		    /**
		     * Checks if `value` is a valid array-like length.
		     *
		     * **Note:** This function is loosely based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a valid length,
		     *  else `false`.
		     * @example
		     *
		     * _.isLength(3);
		     * // => true
		     *
		     * _.isLength(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isLength(Infinity);
		     * // => false
		     *
		     * _.isLength('3');
		     * // => false
		     */
		    function isLength(value) {
		      return typeof value == 'number' &&
		        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		    }
		
		    /**
		     * Checks if `value` is the
		     * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
		     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(_.noop);
		     * // => true
		     *
		     * _.isObject(null);
		     * // => false
		     */
		    function isObject(value) {
		      var type = typeof value;
		      return !!value && (type == 'object' || type == 'function');
		    }
		
		    /**
		     * Checks if `value` is object-like. A value is object-like if it's not `null`
		     * and has a `typeof` result of "object".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		     * @example
		     *
		     * _.isObjectLike({});
		     * // => true
		     *
		     * _.isObjectLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isObjectLike(_.noop);
		     * // => false
		     *
		     * _.isObjectLike(null);
		     * // => false
		     */
		    function isObjectLike(value) {
		      return !!value && typeof value == 'object';
		    }
		
		    /**
		     * Checks if `value` is classified as a `Map` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isMap(new Map);
		     * // => true
		     *
		     * _.isMap(new WeakMap);
		     * // => false
		     */
		    function isMap(value) {
		      return isObjectLike(value) && getTag(value) == mapTag;
		    }
		
		    /**
		     * Performs a partial deep comparison between `object` and `source` to
		     * determine if `object` contains equivalent property values. This method is
		     * equivalent to a `_.matches` function when `source` is partially applied.
		     *
		     * **Note:** This method supports comparing the same values as `_.isEqual`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * var object = { 'user': 'fred', 'age': 40 };
		     *
		     * _.isMatch(object, { 'age': 40 });
		     * // => true
		     *
		     * _.isMatch(object, { 'age': 36 });
		     * // => false
		     */
		    function isMatch(object, source) {
		      return object === source || baseIsMatch(object, source, getMatchData(source));
		    }
		
		    /**
		     * This method is like `_.isMatch` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with five
		     * arguments: (objValue, srcValue, index|key, object, source).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var object = { 'greeting': 'hello' };
		     * var source = { 'greeting': 'hi' };
		     *
		     * _.isMatchWith(object, source, customizer);
		     * // => true
		     */
		    function isMatchWith(object, source, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined;
		      return baseIsMatch(object, source, getMatchData(source), customizer);
		    }
		
		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * **Note:** This method is based on
		     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
		     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
		     * `undefined` and other non-number values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // An `NaN` primitive is the only value that is not equal to itself.
		      // Perform the `toStringTag` check first to avoid errors with some
		      // ActiveX objects in IE.
		      return isNumber(value) && value != +value;
		    }
		
		    /**
		     * Checks if `value` is a native function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     * @example
		     *
		     * _.isNative(Array.prototype.push);
		     * // => true
		     *
		     * _.isNative(_);
		     * // => false
		     */
		    function isNative(value) {
		      if (!isObject(value)) {
		        return false;
		      }
		      var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
		      return pattern.test(toSource(value));
		    }
		
		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(void 0);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }
		
		    /**
		     * Checks if `value` is `null` or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
		     * @example
		     *
		     * _.isNil(null);
		     * // => true
		     *
		     * _.isNil(void 0);
		     * // => true
		     *
		     * _.isNil(NaN);
		     * // => false
		     */
		    function isNil(value) {
		      return value == null;
		    }
		
		    /**
		     * Checks if `value` is classified as a `Number` primitive or object.
		     *
		     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		     * classified as numbers, use the `_.isFinite` method.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isNumber(3);
		     * // => true
		     *
		     * _.isNumber(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isNumber(Infinity);
		     * // => true
		     *
		     * _.isNumber('3');
		     * // => false
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        (isObjectLike(value) && objectToString.call(value) == numberTag);
		    }
		
		    /**
		     * Checks if `value` is a plain object, that is, an object created by the
		     * `Object` constructor or one with a `[[Prototype]]` of `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.8.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object,
		     *  else `false`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * _.isPlainObject(new Foo);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     *
		     * _.isPlainObject(Object.create(null));
		     * // => true
		     */
		    function isPlainObject(value) {
		      if (!isObjectLike(value) ||
		          objectToString.call(value) != objectTag || isHostObject(value)) {
		        return false;
		      }
		      var proto = getPrototype(value);
		      if (proto === null) {
		        return true;
		      }
		      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
		      return (typeof Ctor == 'function' &&
		        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
		    }
		
		    /**
		     * Checks if `value` is classified as a `RegExp` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isRegExp(/abc/);
		     * // => true
		     *
		     * _.isRegExp('/abc/');
		     * // => false
		     */
		    function isRegExp(value) {
		      return isObject(value) && objectToString.call(value) == regexpTag;
		    }
		
		    /**
		     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
		     * double precision number which isn't the result of a rounded unsafe integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a safe integer,
		     *  else `false`.
		     * @example
		     *
		     * _.isSafeInteger(3);
		     * // => true
		     *
		     * _.isSafeInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isSafeInteger(Infinity);
		     * // => false
		     *
		     * _.isSafeInteger('3');
		     * // => false
		     */
		    function isSafeInteger(value) {
		      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
		    }
		
		    /**
		     * Checks if `value` is classified as a `Set` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isSet(new Set);
		     * // => true
		     *
		     * _.isSet(new WeakSet);
		     * // => false
		     */
		    function isSet(value) {
		      return isObjectLike(value) && getTag(value) == setTag;
		    }
		
		    /**
		     * Checks if `value` is classified as a `String` primitive or object.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isString('abc');
		     * // => true
		     *
		     * _.isString(1);
		     * // => false
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
		    }
		
		    /**
		     * Checks if `value` is classified as a `Symbol` primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isSymbol(Symbol.iterator);
		     * // => true
		     *
		     * _.isSymbol('abc');
		     * // => false
		     */
		    function isSymbol(value) {
		      return typeof value == 'symbol' ||
		        (isObjectLike(value) && objectToString.call(value) == symbolTag);
		    }
		
		    /**
		     * Checks if `value` is classified as a typed array.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isTypedArray(new Uint8Array);
		     * // => true
		     *
		     * _.isTypedArray([]);
		     * // => false
		     */
		    function isTypedArray(value) {
		      return isObjectLike(value) &&
		        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
		    }
		
		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     *
		     * _.isUndefined(null);
		     * // => false
		     */
		    function isUndefined(value) {
		      return value === undefined;
		    }
		
		    /**
		     * Checks if `value` is classified as a `WeakMap` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isWeakMap(new WeakMap);
		     * // => true
		     *
		     * _.isWeakMap(new Map);
		     * // => false
		     */
		    function isWeakMap(value) {
		      return isObjectLike(value) && getTag(value) == weakMapTag;
		    }
		
		    /**
		     * Checks if `value` is classified as a `WeakSet` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is correctly classified,
		     *  else `false`.
		     * @example
		     *
		     * _.isWeakSet(new WeakSet);
		     * // => true
		     *
		     * _.isWeakSet(new Set);
		     * // => false
		     */
		    function isWeakSet(value) {
		      return isObjectLike(value) && objectToString.call(value) == weakSetTag;
		    }
		
		    /**
		     * Checks if `value` is less than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     * @example
		     *
		     * _.lt(1, 3);
		     * // => true
		     *
		     * _.lt(3, 3);
		     * // => false
		     *
		     * _.lt(3, 1);
		     * // => false
		     */
		    function lt(value, other) {
		      return value < other;
		    }
		
		    /**
		     * Checks if `value` is less than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than or equal to
		     *  `other`, else `false`.
		     * @example
		     *
		     * _.lte(1, 3);
		     * // => true
		     *
		     * _.lte(3, 3);
		     * // => true
		     *
		     * _.lte(3, 1);
		     * // => false
		     */
		    function lte(value, other) {
		      return value <= other;
		    }
		
		    /**
		     * Converts `value` to an array.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the converted array.
		     * @example
		     *
		     * _.toArray({ 'a': 1, 'b': 2 });
		     * // => [1, 2]
		     *
		     * _.toArray('abc');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toArray(1);
		     * // => []
		     *
		     * _.toArray(null);
		     * // => []
		     */
		    function toArray(value) {
		      if (!value) {
		        return [];
		      }
		      if (isArrayLike(value)) {
		        return isString(value) ? stringToArray(value) : copyArray(value);
		      }
		      if (iteratorSymbol && value[iteratorSymbol]) {
		        return iteratorToArray(value[iteratorSymbol]());
		      }
		      var tag = getTag(value),
		          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
		
		      return func(value);
		    }
		
		    /**
		     * Converts `value` to an integer.
		     *
		     * **Note:** This function is loosely based on
		     * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toInteger(3);
		     * // => 3
		     *
		     * _.toInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toInteger(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toInteger('3');
		     * // => 3
		     */
		    function toInteger(value) {
		      if (!value) {
		        return value === 0 ? value : 0;
		      }
		      value = toNumber(value);
		      if (value === INFINITY || value === -INFINITY) {
		        var sign = (value < 0 ? -1 : 1);
		        return sign * MAX_INTEGER;
		      }
		      var remainder = value % 1;
		      return value === value ? (remainder ? value - remainder : value) : 0;
		    }
		
		    /**
		     * Converts `value` to an integer suitable for use as the length of an
		     * array-like object.
		     *
		     * **Note:** This method is based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toLength(3);
		     * // => 3
		     *
		     * _.toLength(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toLength(Infinity);
		     * // => 4294967295
		     *
		     * _.toLength('3');
		     * // => 3
		     */
		    function toLength(value) {
		      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
		    }
		
		    /**
		     * Converts `value` to a number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     * @example
		     *
		     * _.toNumber(3);
		     * // => 3
		     *
		     * _.toNumber(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toNumber(Infinity);
		     * // => Infinity
		     *
		     * _.toNumber('3');
		     * // => 3
		     */
		    function toNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      if (isObject(value)) {
		        var other = isFunction(value.valueOf) ? value.valueOf() : value;
		        value = isObject(other) ? (other + '') : other;
		      }
		      if (typeof value != 'string') {
		        return value === 0 ? value : +value;
		      }
		      value = value.replace(reTrim, '');
		      var isBinary = reIsBinary.test(value);
		      return (isBinary || reIsOctal.test(value))
		        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		        : (reIsBadHex.test(value) ? NAN : +value);
		    }
		
		    /**
		     * Converts `value` to a plain object flattening inherited enumerable string
		     * keyed properties of `value` to own properties of the plain object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Object} Returns the converted plain object.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.assign({ 'a': 1 }, new Foo);
		     * // => { 'a': 1, 'b': 2 }
		     *
		     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
		     * // => { 'a': 1, 'b': 2, 'c': 3 }
		     */
		    function toPlainObject(value) {
		      return copyObject(value, keysIn(value));
		    }
		
		    /**
		     * Converts `value` to a safe integer. A safe integer can be compared and
		     * represented correctly.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toSafeInteger(3);
		     * // => 3
		     *
		     * _.toSafeInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toSafeInteger(Infinity);
		     * // => 9007199254740991
		     *
		     * _.toSafeInteger('3');
		     * // => 3
		     */
		    function toSafeInteger(value) {
		      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
		    }
		
		    /**
		     * Converts `value` to a string. An empty string is returned for `null`
		     * and `undefined` values. The sign of `-0` is preserved.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {string} Returns the string.
		     * @example
		     *
		     * _.toString(null);
		     * // => ''
		     *
		     * _.toString(-0);
		     * // => '-0'
		     *
		     * _.toString([1, 2, 3]);
		     * // => '1,2,3'
		     */
		    function toString(value) {
		      // Exit early for strings to avoid a performance hit in some environments.
		      if (typeof value == 'string') {
		        return value;
		      }
		      if (value == null) {
		        return '';
		      }
		      if (isSymbol(value)) {
		        return symbolToString ? symbolToString.call(value) : '';
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Assigns own enumerable string keyed properties of source objects to the
		     * destination object. Source objects are applied from left to right.
		     * Subsequent sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object` and is loosely based on
		     * [`Object.assign`](https://mdn.io/Object/assign).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Foo() {
		     *   this.c = 3;
		     * }
		     *
		     * function Bar() {
		     *   this.e = 5;
		     * }
		     *
		     * Foo.prototype.d = 4;
		     * Bar.prototype.f = 6;
		     *
		     * _.assign({ 'a': 1 }, new Foo, new Bar);
		     * // => { 'a': 1, 'c': 3, 'e': 5 }
		     */
		    var assign = createAssigner(function(object, source) {
		      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keys(source), object);
		        return;
		      }
		      for (var key in source) {
		        if (hasOwnProperty.call(source, key)) {
		          assignValue(object, key, source[key]);
		        }
		      }
		    });
		
		    /**
		     * This method is like `_.assign` except that it iterates over own and
		     * inherited source properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extend
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * function Bar() {
		     *   this.d = 4;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     * Bar.prototype.e = 5;
		     *
		     * _.assignIn({ 'a': 1 }, new Foo, new Bar);
		     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
		     */
		    var assignIn = createAssigner(function(object, source) {
		      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keysIn(source), object);
		        return;
		      }
		      for (var key in source) {
		        assignValue(object, key, source[key]);
		      }
		    });
		
		    /**
		     * This method is like `_.assignIn` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extendWith
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignInWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keysIn(source), object, customizer);
		    });
		
		    /**
		     * This method is like `_.assign` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keys(source), object, customizer);
		    });
		
		    /**
		     * Creates an array of values corresponding to `paths` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {...(string|string[])} [paths] The property paths of elements to pick.
		     * @returns {Array} Returns the new array of picked elements.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _.at(object, ['a[0].b.c', 'a[1]']);
		     * // => [3, 4]
		     *
		     * _.at(['a', 'b', 'c'], 0, 2);
		     * // => ['a', 'c']
		     */
		    var at = rest(function(object, paths) {
		      return baseAt(object, baseFlatten(paths, 1));
		    });
		
		    /**
		     * Creates an object that inherits from the `prototype` object. If a
		     * `properties` object is given, its own enumerable string keyed properties
		     * are assigned to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Object
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, {
		     *   'constructor': Circle
		     * });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties ? baseAssign(result, properties) : result;
		    }
		
		    /**
		     * Assigns own and inherited enumerable string keyed properties of source
		     * objects to the destination object for all destination properties that
		     * resolve to `undefined`. Source objects are applied from left to right.
		     * Once a property is set, additional values of the same property are ignored.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
		     * // => { 'user': 'barney', 'age': 36 }
		     */
		    var defaults = rest(function(args) {
		      args.push(undefined, assignInDefaults);
		      return apply(assignInWith, undefined, args);
		    });
		
		    /**
		     * This method is like `_.defaults` except that it recursively assigns
		     * default properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
		     * // => { 'user': { 'name': 'barney', 'age': 36 } }
		     *
		     */
		    var defaultsDeep = rest(function(args) {
		      args.push(undefined, mergeDefaults);
		      return apply(mergeWith, undefined, args);
		    });
		
		    /**
		     * This method is like `_.find` except that it returns the key of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Object
		     * @param {Object} object The object to search.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findKey(users, function(o) { return o.age < 40; });
		     * // => 'barney' (iteration order is not guaranteed)
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findKey(users, { 'age': 1, 'active': true });
		     * // => 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findKey(users, 'active');
		     * // => 'barney'
		     */
		    function findKey(object, predicate) {
		      return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
		    }
		
		    /**
		     * This method is like `_.findKey` except that it iterates over elements of
		     * a collection in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to search.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findLastKey(users, function(o) { return o.age < 40; });
		     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastKey(users, { 'age': 36, 'active': true });
		     * // => 'barney'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastKey(users, 'active');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, predicate) {
		      return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
		    }
		
		    /**
		     * Iterates over own and inherited enumerable string keyed properties of an
		     * object and invokes `iteratee` for each property. The iteratee is invoked
		     * with three arguments: (value, key, object). Iteratee functions may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forIn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
		     */
		    function forIn(object, iteratee) {
		      return object == null
		        ? object
		        : baseFor(object, getIteratee(iteratee), keysIn);
		    }
		
		    /**
		     * This method is like `_.forIn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forInRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
		     */
		    function forInRight(object, iteratee) {
		      return object == null
		        ? object
		        : baseForRight(object, getIteratee(iteratee), keysIn);
		    }
		
		    /**
		     * Iterates over own enumerable string keyed properties of an object and
		     * invokes `iteratee` for each property. The iteratee is invoked with three
		     * arguments: (value, key, object). Iteratee functions may exit iteration
		     * early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forOwn(object, iteratee) {
		      return object && baseForOwn(object, getIteratee(iteratee));
		    }
		
		    /**
		     * This method is like `_.forOwn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwnRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
		     */
		    function forOwnRight(object, iteratee) {
		      return object && baseForOwnRight(object, getIteratee(iteratee));
		    }
		
		    /**
		     * Creates an array of function property names from own enumerable properties
		     * of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the new array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functions(new Foo);
		     * // => ['a', 'b']
		     */
		    function functions(object) {
		      return object == null ? [] : baseFunctions(object, keys(object));
		    }
		
		    /**
		     * Creates an array of function property names from own and inherited
		     * enumerable properties of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the new array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functionsIn(new Foo);
		     * // => ['a', 'b', 'c']
		     */
		    function functionsIn(object) {
		      return object == null ? [] : baseFunctions(object, keysIn(object));
		    }
		
		    /**
		     * Gets the value at `path` of `object`. If the resolved value is
		     * `undefined`, the `defaultValue` is used in its place.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.get(object, 'a[0].b.c');
		     * // => 3
		     *
		     * _.get(object, ['a', '0', 'b', 'c']);
		     * // => 3
		     *
		     * _.get(object, 'a.b.c', 'default');
		     * // => 'default'
		     */
		    function get(object, path, defaultValue) {
		      var result = object == null ? undefined : baseGet(object, path);
		      return result === undefined ? defaultValue : result;
		    }
		
		    /**
		     * Checks if `path` is a direct property of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = { 'a': { 'b': 2 } };
		     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.has(object, 'a');
		     * // => true
		     *
		     * _.has(object, 'a.b');
		     * // => true
		     *
		     * _.has(object, ['a', 'b']);
		     * // => true
		     *
		     * _.has(other, 'a');
		     * // => false
		     */
		    function has(object, path) {
		      return object != null && hasPath(object, path, baseHas);
		    }
		
		    /**
		     * Checks if `path` is a direct or inherited property of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.hasIn(object, 'a');
		     * // => true
		     *
		     * _.hasIn(object, 'a.b');
		     * // => true
		     *
		     * _.hasIn(object, ['a', 'b']);
		     * // => true
		     *
		     * _.hasIn(object, 'b');
		     * // => false
		     */
		    function hasIn(object, path) {
		      return object != null && hasPath(object, path, baseHasIn);
		    }
		
		    /**
		     * Creates an object composed of the inverted keys and values of `object`.
		     * If `object` contains duplicate values, subsequent values overwrite
		     * property assignments of previous values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invert(object);
		     * // => { '1': 'c', '2': 'b' }
		     */
		    var invert = createInverter(function(result, value, key) {
		      result[value] = key;
		    }, constant(identity));
		
		    /**
		     * This method is like `_.invert` except that the inverted object is generated
		     * from the results of running each element of `object` thru `iteratee`. The
		     * corresponding inverted value of each inverted key is an array of keys
		     * responsible for generating the inverted value. The iteratee is invoked
		     * with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invertBy(object);
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     *
		     * _.invertBy(object, function(value) {
		     *   return 'group' + value;
		     * });
		     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
		     */
		    var invertBy = createInverter(function(result, value, key) {
		      if (hasOwnProperty.call(result, value)) {
		        result[value].push(key);
		      } else {
		        result[value] = [key];
		      }
		    }, getIteratee);
		
		    /**
		     * Invokes the method at `path` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
		     *
		     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
		     * // => [2, 3]
		     */
		    var invoke = rest(baseInvoke);
		
		    /**
		     * Creates an array of the own enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects. See the
		     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
		     * for more details.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keys(new Foo);
		     * // => ['a', 'b'] (iteration order is not guaranteed)
		     *
		     * _.keys('hi');
		     * // => ['0', '1']
		     */
		    function keys(object) {
		      var isProto = isPrototype(object);
		      if (!(isProto || isArrayLike(object))) {
		        return baseKeys(object);
		      }
		      var indexes = indexKeys(object),
		          skipIndexes = !!indexes,
		          result = indexes || [],
		          length = result.length;
		
		      for (var key in object) {
		        if (baseHas(object, key) &&
		            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
		            !(isProto && key == 'constructor')) {
		          result.push(key);
		        }
		      }
		      return result;
		    }
		
		    /**
		     * Creates an array of the own and inherited enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keysIn(new Foo);
		     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		     */
		    function keysIn(object) {
		      var index = -1,
		          isProto = isPrototype(object),
		          props = baseKeysIn(object),
		          propsLength = props.length,
		          indexes = indexKeys(object),
		          skipIndexes = !!indexes,
		          result = indexes || [],
		          length = result.length;
		
		      while (++index < propsLength) {
		        var key = props[index];
		        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
		            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }
		
		    /**
		     * The opposite of `_.mapValues`; this method creates an object with the
		     * same values as `object` and keys generated by running each own enumerable
		     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
		     * with three arguments: (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @example
		     *
		     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   return key + value;
		     * });
		     * // => { 'a1': 1, 'b2': 2 }
		     */
		    function mapKeys(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);
		
		      baseForOwn(object, function(value, key, object) {
		        result[iteratee(value, key, object)] = value;
		      });
		      return result;
		    }
		
		    /**
		     * Creates an object with the same keys as `object` and values generated
		     * by running each own enumerable string keyed property of `object` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @example
		     *
		     * var users = {
		     *   'fred':    { 'user': 'fred',    'age': 40 },
		     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		     * };
		     *
		     * _.mapValues(users, function(o) { return o.age; });
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.mapValues(users, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     */
		    function mapValues(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);
		
		      baseForOwn(object, function(value, key, object) {
		        result[key] = iteratee(value, key, object);
		      });
		      return result;
		    }
		
		    /**
		     * This method is like `_.assign` except that it recursively merges own and
		     * inherited enumerable string keyed properties of source objects into the
		     * destination object. Source properties that resolve to `undefined` are
		     * skipped if a destination value exists. Array and plain object properties
		     * are merged recursively.Other objects and value types are overridden by
		     * assignment. Source objects are applied from left to right. Subsequent
		     * sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var users = {
		     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
		     * };
		     *
		     * var ages = {
		     *   'data': [{ 'age': 36 }, { 'age': 40 }]
		     * };
		     *
		     * _.merge(users, ages);
		     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
		     */
		    var merge = createAssigner(function(object, source, srcIndex) {
		      baseMerge(object, source, srcIndex);
		    });
		
		    /**
		     * This method is like `_.merge` except that it accepts `customizer` which
		     * is invoked to produce the merged values of the destination and source
		     * properties. If `customizer` returns `undefined`, merging is handled by the
		     * method instead. The `customizer` is invoked with seven arguments:
		     * (objValue, srcValue, key, object, source, stack).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} customizer The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (_.isArray(objValue)) {
		     *     return objValue.concat(srcValue);
		     *   }
		     * }
		     *
		     * var object = {
		     *   'fruits': ['apple'],
		     *   'vegetables': ['beet']
		     * };
		     *
		     * var other = {
		     *   'fruits': ['banana'],
		     *   'vegetables': ['carrot']
		     * };
		     *
		     * _.mergeWith(object, other, customizer);
		     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
		     */
		    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
		      baseMerge(object, source, srcIndex, customizer);
		    });
		
		    /**
		     * The opposite of `_.pick`; this method creates an object composed of the
		     * own and inherited enumerable string keyed properties of `object` that are
		     * not omitted.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [props] The property identifiers to omit.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omit(object, ['a', 'c']);
		     * // => { 'b': '2' }
		     */
		    var omit = rest(function(object, props) {
		      if (object == null) {
		        return {};
		      }
		      props = arrayMap(baseFlatten(props, 1), toKey);
		      return basePick(object, baseDifference(getAllKeysIn(object), props));
		    });
		
		    /**
		     * The opposite of `_.pickBy`; this method creates an object composed of
		     * the own and inherited enumerable string keyed properties of `object` that
		     * `predicate` doesn't return truthy for. The predicate is invoked with two
		     * arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omitBy(object, _.isNumber);
		     * // => { 'b': '2' }
		     */
		    function omitBy(object, predicate) {
		      predicate = getIteratee(predicate);
		      return basePickBy(object, function(value, key) {
		        return !predicate(value, key);
		      });
		    }
		
		    /**
		     * Creates an object composed of the picked `object` properties.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [props] The property identifiers to pick.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pick(object, ['a', 'c']);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var pick = rest(function(object, props) {
		      return object == null ? {} : basePick(object, baseFlatten(props, 1));
		    });
		
		    /**
		     * Creates an object composed of the `object` properties `predicate` returns
		     * truthy for. The predicate is invoked with two arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Array|Function|Object|string} [predicate=_.identity]
		     *  The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pickBy(object, _.isNumber);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    function pickBy(object, predicate) {
		      return object == null ? {} : basePickBy(object, getIteratee(predicate));
		    }
		
		    /**
		     * This method is like `_.get` except that if the resolved value is a
		     * function it's invoked with the `this` binding of its parent object and
		     * its result is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to resolve.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
		     *
		     * _.result(object, 'a[0].b.c1');
		     * // => 3
		     *
		     * _.result(object, 'a[0].b.c2');
		     * // => 4
		     *
		     * _.result(object, 'a[0].b.c3', 'default');
		     * // => 'default'
		     *
		     * _.result(object, 'a[0].b.c3', _.constant('default'));
		     * // => 'default'
		     */
		    function result(object, path, defaultValue) {
		      path = isKey(path, object) ? [path] : castPath(path);
		
		      var index = -1,
		          length = path.length;
		
		      // Ensure the loop is entered when path is empty.
		      if (!length) {
		        object = undefined;
		        length = 1;
		      }
		      while (++index < length) {
		        var value = object == null ? undefined : object[path[index]];
		        if (value === undefined) {
		          index = length;
		          value = defaultValue;
		        }
		        object = isFunction(value) ? value.call(object) : value;
		      }
		      return object;
		    }
		
		    /**
		     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		     * it's created. Arrays are created for missing index properties while objects
		     * are created for all other missing properties. Use `_.setWith` to customize
		     * `path` creation.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.set(object, 'a[0].b.c', 4);
		     * console.log(object.a[0].b.c);
		     * // => 4
		     *
		     * _.set(object, ['x', '0', 'y', 'z'], 5);
		     * console.log(object.x[0].y.z);
		     * // => 5
		     */
		    function set(object, path, value) {
		      return object == null ? object : baseSet(object, path, value);
		    }
		
		    /**
		     * This method is like `_.set` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.setWith(object, '[0][1]', 'a', Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function setWith(object, path, value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined;
		      return object == null ? object : baseSet(object, path, value, customizer);
		    }
		
		    /**
		     * Creates an array of own enumerable string keyed-value pairs for `object`
		     * which can be consumed by `_.fromPairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entries
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the new array of key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairs(new Foo);
		     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		     */
		    function toPairs(object) {
		      return baseToPairs(object, keys(object));
		    }
		
		    /**
		     * Creates an array of own and inherited enumerable string keyed-value pairs
		     * for `object` which can be consumed by `_.fromPairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entriesIn
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the new array of key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairsIn(new Foo);
		     * // => [['a', 1], ['b', 2], ['c', 1]] (iteration order is not guaranteed)
		     */
		    function toPairsIn(object) {
		      return baseToPairs(object, keysIn(object));
		    }
		
		    /**
		     * An alternative to `_.reduce`; this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable string keyed properties thru `iteratee`, with each invocation
		     * potentially mutating the `accumulator` object. The iteratee is invoked
		     * with four arguments: (accumulator, value, key, object). Iteratee functions
		     * may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Object
		     * @param {Array|Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.transform([2, 3, 4], function(result, n) {
		     *   result.push(n *= n);
		     *   return n % 2 == 0;
		     * }, []);
		     * // => [4, 9]
		     *
		     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     */
		    function transform(object, iteratee, accumulator) {
		      var isArr = isArray(object) || isTypedArray(object);
		      iteratee = getIteratee(iteratee, 4);
		
		      if (accumulator == null) {
		        if (isArr || isObject(object)) {
		          var Ctor = object.constructor;
		          if (isArr) {
		            accumulator = isArray(object) ? new Ctor : [];
		          } else {
		            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		          }
		        } else {
		          accumulator = {};
		        }
		      }
		      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
		        return iteratee(accumulator, value, index, object);
		      });
		      return accumulator;
		    }
		
		    /**
		     * Removes the property at `path` of `object`.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
		     * _.unset(object, 'a[0].b.c');
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     *
		     * _.unset(object, ['a', '0', 'b', 'c']);
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     */
		    function unset(object, path) {
		      return object == null ? true : baseUnset(object, path);
		    }
		
		    /**
		     * This method is like `_.set` except that accepts `updater` to produce the
		     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
		     * is invoked with one argument: (value).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
		     * console.log(object.a[0].b.c);
		     * // => 9
		     *
		     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
		     * console.log(object.x[0].y.z);
		     * // => 0
		     */
		    function update(object, path, updater) {
		      return object == null ? object : baseUpdate(object, path, castFunction(updater));
		    }
		
		    /**
		     * This method is like `_.update` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function updateWith(object, path, updater, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined;
		      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
		    }
		
		    /**
		     * Creates an array of the own enumerable string keyed property values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.values(new Foo);
		     * // => [1, 2] (iteration order is not guaranteed)
		     *
		     * _.values('hi');
		     * // => ['h', 'i']
		     */
		    function values(object) {
		      return object ? baseValues(object, keys(object)) : [];
		    }
		
		    /**
		     * Creates an array of the own and inherited enumerable string keyed property
		     * values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.valuesIn(new Foo);
		     * // => [1, 2, 3] (iteration order is not guaranteed)
		     */
		    function valuesIn(object) {
		      return object == null ? [] : baseValues(object, keysIn(object));
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Clamps `number` within the inclusive `lower` and `upper` bounds.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Number
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     * @example
		     *
		     * _.clamp(-10, -5, 5);
		     * // => -5
		     *
		     * _.clamp(10, -5, 5);
		     * // => 5
		     */
		    function clamp(number, lower, upper) {
		      if (upper === undefined) {
		        upper = lower;
		        lower = undefined;
		      }
		      if (upper !== undefined) {
		        upper = toNumber(upper);
		        upper = upper === upper ? upper : 0;
		      }
		      if (lower !== undefined) {
		        lower = toNumber(lower);
		        lower = lower === lower ? lower : 0;
		      }
		      return baseClamp(toNumber(number), lower, upper);
		    }
		
		    /**
		     * Checks if `n` is between `start` and up to but not including, `end`. If
		     * `end` is not specified, it's set to `start` with `start` then set to `0`.
		     * If `start` is greater than `end` the params are swapped to support
		     * negative ranges.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.3.0
		     * @category Number
		     * @param {number} number The number to check.
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     * @example
		     *
		     * _.inRange(3, 2, 4);
		     * // => true
		     *
		     * _.inRange(4, 8);
		     * // => true
		     *
		     * _.inRange(4, 2);
		     * // => false
		     *
		     * _.inRange(2, 2);
		     * // => false
		     *
		     * _.inRange(1.2, 2);
		     * // => true
		     *
		     * _.inRange(5.2, 4);
		     * // => false
		     *
		     * _.inRange(-3, -2, -6);
		     * // => true
		     */
		    function inRange(number, start, end) {
		      start = toNumber(start) || 0;
		      if (end === undefined) {
		        end = start;
		        start = 0;
		      } else {
		        end = toNumber(end) || 0;
		      }
		      number = toNumber(number);
		      return baseInRange(number, start, end);
		    }
		
		    /**
		     * Produces a random number between the inclusive `lower` and `upper` bounds.
		     * If only one argument is provided a number between `0` and the given number
		     * is returned. If `floating` is `true`, or either `lower` or `upper` are
		     * floats, a floating-point number is returned instead of an integer.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Number
		     * @param {number} [lower=0] The lower bound.
		     * @param {number} [upper=1] The upper bound.
		     * @param {boolean} [floating] Specify returning a floating-point number.
		     * @returns {number} Returns the random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(lower, upper, floating) {
		      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		        upper = floating = undefined;
		      }
		      if (floating === undefined) {
		        if (typeof upper == 'boolean') {
		          floating = upper;
		          upper = undefined;
		        }
		        else if (typeof lower == 'boolean') {
		          floating = lower;
		          lower = undefined;
		        }
		      }
		      if (lower === undefined && upper === undefined) {
		        lower = 0;
		        upper = 1;
		      }
		      else {
		        lower = toNumber(lower) || 0;
		        if (upper === undefined) {
		          upper = lower;
		          lower = 0;
		        } else {
		          upper = toNumber(upper) || 0;
		        }
		      }
		      if (lower > upper) {
		        var temp = lower;
		        lower = upper;
		        upper = temp;
		      }
		      if (floating || lower % 1 || upper % 1) {
		        var rand = nativeRandom();
		        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
		      }
		      return baseRandom(lower, upper);
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the camel cased string.
		     * @example
		     *
		     * _.camelCase('Foo Bar');
		     * // => 'fooBar'
		     *
		     * _.camelCase('--foo-bar--');
		     * // => 'fooBar'
		     *
		     * _.camelCase('__FOO_BAR__');
		     * // => 'fooBar'
		     */
		    var camelCase = createCompounder(function(result, word, index) {
		      word = word.toLowerCase();
		      return result + (index ? capitalize(word) : word);
		    });
		
		    /**
		     * Converts the first character of `string` to upper case and the remaining
		     * to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to capitalize.
		     * @returns {string} Returns the capitalized string.
		     * @example
		     *
		     * _.capitalize('FRED');
		     * // => 'Fred'
		     */
		    function capitalize(string) {
		      return upperFirst(toString(string).toLowerCase());
		    }
		
		    /**
		     * Deburrs `string` by converting
		     * [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
		     * to basic latin letters and removing
		     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to deburr.
		     * @returns {string} Returns the deburred string.
		     * @example
		     *
		     * _.deburr('déjà vu');
		     * // => 'deja vu'
		     */
		    function deburr(string) {
		      string = toString(string);
		      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
		    }
		
		    /**
		     * Checks if `string` ends with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to search.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=string.length] The position to search from.
		     * @returns {boolean} Returns `true` if `string` ends with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.endsWith('abc', 'c');
		     * // => true
		     *
		     * _.endsWith('abc', 'b');
		     * // => false
		     *
		     * _.endsWith('abc', 'b', 2);
		     * // => true
		     */
		    function endsWith(string, target, position) {
		      string = toString(string);
		      target = typeof target == 'string' ? target : (target + '');
		
		      var length = string.length;
		      position = position === undefined
		        ? length
		        : baseClamp(toInteger(position), 0, length);
		
		      position -= target.length;
		      return position >= 0 && string.indexOf(target, position) == position;
		    }
		
		    /**
		     * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
		     * their corresponding HTML entities.
		     *
		     * **Note:** No other characters are escaped. To escape additional
		     * characters use a third-party library like [_he_](https://mths.be/he).
		     *
		     * Though the ">" character is escaped for symmetry, characters like
		     * ">" and "/" don't need escaping in HTML and have no special meaning
		     * unless they're part of a tag or unquoted attribute value. See
		     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
		     * (under "semi-related fun fact") for more details.
		     *
		     * Backticks are escaped because in IE < 9, they can break out of
		     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
		     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
		     * [#133](https://html5sec.org/#133) of the
		     * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
		     *
		     * When working with HTML you should always
		     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
		     * XSS vectors.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('fred, barney, & pebbles');
		     * // => 'fred, barney, &amp; pebbles'
		     */
		    function escape(string) {
		      string = toString(string);
		      return (string && reHasUnescapedHtml.test(string))
		        ? string.replace(reUnescapedHtml, escapeHtmlChar)
		        : string;
		    }
		
		    /**
		     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
		     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escapeRegExp('[lodash](https://lodash.com/)');
		     * // => '\[lodash\]\(https://lodash\.com/\)'
		     */
		    function escapeRegExp(string) {
		      string = toString(string);
		      return (string && reHasRegExpChar.test(string))
		        ? string.replace(reRegExpChar, '\\$&')
		        : string;
		    }
		
		    /**
		     * Converts `string` to
		     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the kebab cased string.
		     * @example
		     *
		     * _.kebabCase('Foo Bar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('fooBar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('__FOO_BAR__');
		     * // => 'foo-bar'
		     */
		    var kebabCase = createCompounder(function(result, word, index) {
		      return result + (index ? '-' : '') + word.toLowerCase();
		    });
		
		    /**
		     * Converts `string`, as space separated words, to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.lowerCase('--Foo-Bar--');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('fooBar');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('__FOO_BAR__');
		     * // => 'foo bar'
		     */
		    var lowerCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toLowerCase();
		    });
		
		    /**
		     * Converts the first character of `string` to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.lowerFirst('Fred');
		     * // => 'fred'
		     *
		     * _.lowerFirst('FRED');
		     * // => 'fRED'
		     */
		    var lowerFirst = createCaseFirst('toLowerCase');
		
		    /**
		     * Pads `string` on the left and right sides if it's shorter than `length`.
		     * Padding characters are truncated if they can't be evenly divided by `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.pad('abc', 8);
		     * // => '  abc   '
		     *
		     * _.pad('abc', 8, '_-');
		     * // => '_-abc_-_'
		     *
		     * _.pad('abc', 3);
		     * // => 'abc'
		     */
		    function pad(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);
		
		      var strLength = length ? stringSize(string) : 0;
		      if (!length || strLength >= length) {
		        return string;
		      }
		      var mid = (length - strLength) / 2;
		      return (
		        createPadding(nativeFloor(mid), chars) +
		        string +
		        createPadding(nativeCeil(mid), chars)
		      );
		    }
		
		    /**
		     * Pads `string` on the right side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padEnd('abc', 6);
		     * // => 'abc   '
		     *
		     * _.padEnd('abc', 6, '_-');
		     * // => 'abc_-_'
		     *
		     * _.padEnd('abc', 3);
		     * // => 'abc'
		     */
		    function padEnd(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);
		
		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (string + createPadding(length - strLength, chars))
		        : string;
		    }
		
		    /**
		     * Pads `string` on the left side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padStart('abc', 6);
		     * // => '   abc'
		     *
		     * _.padStart('abc', 6, '_-');
		     * // => '_-_abc'
		     *
		     * _.padStart('abc', 3);
		     * // => 'abc'
		     */
		    function padStart(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);
		
		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (createPadding(length - strLength, chars) + string)
		        : string;
		    }
		
		    /**
		     * Converts `string` to an integer of the specified radix. If `radix` is
		     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		     * hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * **Note:** This method aligns with the
		     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category String
		     * @param {string} string The string to convert.
		     * @param {number} [radix=10] The radix to interpret `value` by.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     *
		     * _.map(['6', '08', '10'], _.parseInt);
		     * // => [6, 8, 10]
		     */
		    function parseInt(string, radix, guard) {
		      // Chrome fails to trim leading <BOM> whitespace characters.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
		      if (guard || radix == null) {
		        radix = 0;
		      } else if (radix) {
		        radix = +radix;
		      }
		      string = toString(string).replace(reTrim, '');
		      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
		    }
		
		    /**
		     * Repeats the given string `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to repeat.
		     * @param {number} [n=1] The number of times to repeat the string.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the repeated string.
		     * @example
		     *
		     * _.repeat('*', 3);
		     * // => '***'
		     *
		     * _.repeat('abc', 2);
		     * // => 'abcabc'
		     *
		     * _.repeat('abc', 0);
		     * // => ''
		     */
		    function repeat(string, n, guard) {
		      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      return baseRepeat(toString(string), n);
		    }
		
		    /**
		     * Replaces matches for `pattern` in `string` with `replacement`.
		     *
		     * **Note:** This method is based on
		     * [`String#replace`](https://mdn.io/String/replace).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to modify.
		     * @param {RegExp|string} pattern The pattern to replace.
		     * @param {Function|string} replacement The match replacement.
		     * @returns {string} Returns the modified string.
		     * @example
		     *
		     * _.replace('Hi Fred', 'Fred', 'Barney');
		     * // => 'Hi Barney'
		     */
		    function replace() {
		      var args = arguments,
		          string = toString(args[0]);
		
		      return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
		    }
		
		    /**
		     * Converts `string` to
		     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the snake cased string.
		     * @example
		     *
		     * _.snakeCase('Foo Bar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('fooBar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('--FOO-BAR--');
		     * // => 'foo_bar'
		     */
		    var snakeCase = createCompounder(function(result, word, index) {
		      return result + (index ? '_' : '') + word.toLowerCase();
		    });
		
		    /**
		     * Splits `string` by `separator`.
		     *
		     * **Note:** This method is based on
		     * [`String#split`](https://mdn.io/String/split).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to split.
		     * @param {RegExp|string} separator The separator pattern to split by.
		     * @param {number} [limit] The length to truncate results to.
		     * @returns {Array} Returns the new array of string segments.
		     * @example
		     *
		     * _.split('a-b-c', '-', 2);
		     * // => ['a', 'b']
		     */
		    function split(string, separator, limit) {
		      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		        separator = limit = undefined;
		      }
		      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
		      if (!limit) {
		        return [];
		      }
		      string = toString(string);
		      if (string && (
		            typeof separator == 'string' ||
		            (separator != null && !isRegExp(separator))
		          )) {
		        separator += '';
		        if (separator == '' && reHasComplexSymbol.test(string)) {
		          return castSlice(stringToArray(string), 0, limit);
		        }
		      }
		      return nativeSplit.call(string, separator, limit);
		    }
		
		    /**
		     * Converts `string` to
		     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.1.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the start cased string.
		     * @example
		     *
		     * _.startCase('--foo-bar--');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('fooBar');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('__FOO_BAR__');
		     * // => 'FOO BAR'
		     */
		    var startCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + upperFirst(word);
		    });
		
		    /**
		     * Checks if `string` starts with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to search.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=0] The position to search from.
		     * @returns {boolean} Returns `true` if `string` starts with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.startsWith('abc', 'a');
		     * // => true
		     *
		     * _.startsWith('abc', 'b');
		     * // => false
		     *
		     * _.startsWith('abc', 'b', 1);
		     * // => true
		     */
		    function startsWith(string, target, position) {
		      string = toString(string);
		      position = baseClamp(toInteger(position), 0, string.length);
		      return string.lastIndexOf(target, position) == position;
		    }
		
		    /**
		     * Creates a compiled template function that can interpolate data properties
		     * in "interpolate" delimiters, HTML-escape interpolated data properties in
		     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
		     * properties may be accessed as free variables in the template. If a setting
		     * object is given, it takes precedence over `_.templateSettings` values.
		     *
		     * **Note:** In the development build `_.template` utilizes
		     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
		     * for easier debugging.
		     *
		     * For more information on precompiling templates see
		     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
		     *
		     * For more information on Chrome extension sandboxes see
		     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The template string.
		     * @param {Object} [options={}] The options object.
		     * @param {RegExp} [options.escape=_.templateSettings.escape]
		     *  The HTML "escape" delimiter.
		     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
		     *  The "evaluate" delimiter.
		     * @param {Object} [options.imports=_.templateSettings.imports]
		     *  An object to import into the template as free variables.
		     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
		     *  The "interpolate" delimiter.
		     * @param {string} [options.sourceURL='lodash.templateSources[n]']
		     *  The sourceURL of the compiled template.
		     * @param {string} [options.variable='obj']
		     *  The data object variable name.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the compiled template function.
		     * @example
		     *
		     * // Use the "interpolate" delimiter to create a compiled template.
		     * var compiled = _.template('hello <%= user %>!');
		     * compiled({ 'user': 'fred' });
		     * // => 'hello fred!'
		     *
		     * // Use the HTML "escape" delimiter to escape data property values.
		     * var compiled = _.template('<b><%- value %></b>');
		     * compiled({ 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
		     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the internal `print` function in "evaluate" delimiters.
		     * var compiled = _.template('<% print("hello " + user); %>!');
		     * compiled({ 'user': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
		     * var compiled = _.template('hello ${ user }!');
		     * compiled({ 'user': 'pebbles' });
		     * // => 'hello pebbles!'
		     *
		     * // Use custom template delimiters.
		     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
		     * var compiled = _.template('hello {{ user }}!');
		     * compiled({ 'user': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // Use backslashes to treat delimiters as plain text.
		     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
		     * compiled({ 'value': 'ignored' });
		     * // => '<%- value %>'
		     *
		     * // Use the `imports` option to import `jQuery` as `jq`.
		     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
		     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
		     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
		     *
		     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
		     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     * //   var __t, __p = '';
		     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
		     * //   return __p;
		     * // }
		     *
		     * // Use the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and stack traces.
		     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(string, options, guard) {
		      // Based on John Resig's `tmpl` implementation
		      // (http://ejohn.org/blog/javascript-micro-templating/)
		      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
		      var settings = lodash.templateSettings;
		
		      if (guard && isIterateeCall(string, options, guard)) {
		        options = undefined;
		      }
		      string = toString(string);
		      options = assignInWith({}, options, settings, assignInDefaults);
		
		      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
		          importsKeys = keys(imports),
		          importsValues = baseValues(imports, importsKeys);
		
		      var isEscaping,
		          isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";
		
		      // Compile the regexp to match each delimiter.
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');
		
		      // Use a sourceURL for easier debugging.
		      var sourceURL = '//# sourceURL=' +
		        ('sourceURL' in options
		          ? options.sourceURL
		          : ('lodash.templateSources[' + (++templateCounter) + ']')
		        ) + '\n';
		
		      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);
		
		        // Escape characters that can't be included in string literals.
		        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
		
		        // Replace delimiters with snippets.
		        if (escapeValue) {
		          isEscaping = true;
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;
		
		        // The JS engine embedded in Adobe products needs `match` returned in
		        // order to produce the correct `offset` value.
		        return match;
		      });
		
		      source += "';\n";
		
		      // If `variable` is not specified wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain.
		      var variable = options.variable;
		      if (!variable) {
		        source = 'with (obj) {\n' + source + '\n}\n';
		      }
		      // Cleanup code by stripping empty strings.
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');
		
		      // Frame code as the function body.
		      source = 'function(' + (variable || 'obj') + ') {\n' +
		        (variable
		          ? ''
		          : 'obj || (obj = {});\n'
		        ) +
		        "var __t, __p = ''" +
		        (isEscaping
		           ? ', __e = _.escape'
		           : ''
		        ) +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';
		
		      var result = attempt(function() {
		        return Function(importsKeys, sourceURL + 'return ' + source)
		          .apply(undefined, importsValues);
		      });
		
		      // Provide the compiled function's source by its `toString` method or
		      // the `source` property as a convenience for inlining compiled templates.
		      result.source = source;
		      if (isError(result)) {
		        throw result;
		      }
		      return result;
		    }
		
		    /**
		     * Converts `string`, as a whole, to lower case just like
		     * [String#toLowerCase](https://mdn.io/toLowerCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.toLower('--Foo-Bar--');
		     * // => '--foo-bar--'
		     *
		     * _.toLower('fooBar');
		     * // => 'foobar'
		     *
		     * _.toLower('__FOO_BAR__');
		     * // => '__foo_bar__'
		     */
		    function toLower(value) {
		      return toString(value).toLowerCase();
		    }
		
		    /**
		     * Converts `string`, as a whole, to upper case just like
		     * [String#toUpperCase](https://mdn.io/toUpperCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.toUpper('--foo-bar--');
		     * // => '--FOO-BAR--'
		     *
		     * _.toUpper('fooBar');
		     * // => 'FOOBAR'
		     *
		     * _.toUpper('__foo_bar__');
		     * // => '__FOO_BAR__'
		     */
		    function toUpper(value) {
		      return toString(value).toUpperCase();
		    }
		
		    /**
		     * Removes leading and trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trim('  abc  ');
		     * // => 'abc'
		     *
		     * _.trim('-_-abc-_-', '_-');
		     * // => 'abc'
		     *
		     * _.map(['  foo  ', '  bar  '], _.trim);
		     * // => ['foo', 'bar']
		     */
		    function trim(string, chars, guard) {
		      string = toString(string);
		      if (!string) {
		        return string;
		      }
		      if (guard || chars === undefined) {
		        return string.replace(reTrim, '');
		      }
		      if (!(chars += '')) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          chrSymbols = stringToArray(chars),
		          start = charsStartIndex(strSymbols, chrSymbols),
		          end = charsEndIndex(strSymbols, chrSymbols) + 1;
		
		      return castSlice(strSymbols, start, end).join('');
		    }
		
		    /**
		     * Removes trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimEnd('  abc  ');
		     * // => '  abc'
		     *
		     * _.trimEnd('-_-abc-_-', '_-');
		     * // => '-_-abc'
		     */
		    function trimEnd(string, chars, guard) {
		      string = toString(string);
		      if (!string) {
		        return string;
		      }
		      if (guard || chars === undefined) {
		        return string.replace(reTrimEnd, '');
		      }
		      if (!(chars += '')) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
		
		      return castSlice(strSymbols, 0, end).join('');
		    }
		
		    /**
		     * Removes leading whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimStart('  abc  ');
		     * // => 'abc  '
		     *
		     * _.trimStart('-_-abc-_-', '_-');
		     * // => 'abc-_-'
		     */
		    function trimStart(string, chars, guard) {
		      string = toString(string);
		      if (!string) {
		        return string;
		      }
		      if (guard || chars === undefined) {
		        return string.replace(reTrimStart, '');
		      }
		      if (!(chars += '')) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          start = charsStartIndex(strSymbols, stringToArray(chars));
		
		      return castSlice(strSymbols, start).join('');
		    }
		
		    /**
		     * Truncates `string` if it's longer than the given maximum string length.
		     * The last characters of the truncated string are replaced with the omission
		     * string which defaults to "...".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to truncate.
		     * @param {Object} [options={}] The options object.
		     * @param {number} [options.length=30] The maximum string length.
		     * @param {string} [options.omission='...'] The string to indicate text is omitted.
		     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
		     * @returns {string} Returns the truncated string.
		     * @example
		     *
		     * _.truncate('hi-diddly-ho there, neighborino');
		     * // => 'hi-diddly-ho there, neighbo...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': ' '
		     * });
		     * // => 'hi-diddly-ho there,...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': /,? +/
		     * });
		     * // => 'hi-diddly-ho there...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'omission': ' [...]'
		     * });
		     * // => 'hi-diddly-ho there, neig [...]'
		     */
		    function truncate(string, options) {
		      var length = DEFAULT_TRUNC_LENGTH,
		          omission = DEFAULT_TRUNC_OMISSION;
		
		      if (isObject(options)) {
		        var separator = 'separator' in options ? options.separator : separator;
		        length = 'length' in options ? toInteger(options.length) : length;
		        omission = 'omission' in options ? toString(options.omission) : omission;
		      }
		      string = toString(string);
		
		      var strLength = string.length;
		      if (reHasComplexSymbol.test(string)) {
		        var strSymbols = stringToArray(string);
		        strLength = strSymbols.length;
		      }
		      if (length >= strLength) {
		        return string;
		      }
		      var end = length - stringSize(omission);
		      if (end < 1) {
		        return omission;
		      }
		      var result = strSymbols
		        ? castSlice(strSymbols, 0, end).join('')
		        : string.slice(0, end);
		
		      if (separator === undefined) {
		        return result + omission;
		      }
		      if (strSymbols) {
		        end += (result.length - end);
		      }
		      if (isRegExp(separator)) {
		        if (string.slice(end).search(separator)) {
		          var match,
		              substring = result;
		
		          if (!separator.global) {
		            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
		          }
		          separator.lastIndex = 0;
		          while ((match = separator.exec(substring))) {
		            var newEnd = match.index;
		          }
		          result = result.slice(0, newEnd === undefined ? end : newEnd);
		        }
		      } else if (string.indexOf(separator, end) != end) {
		        var index = result.lastIndexOf(separator);
		        if (index > -1) {
		          result = result.slice(0, index);
		        }
		      }
		      return result + omission;
		    }
		
		    /**
		     * The inverse of `_.escape`; this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
		     * their corresponding characters.
		     *
		     * **Note:** No other HTML entities are unescaped. To unescape additional
		     * HTML entities use a third-party library like [_he_](https://mths.be/he).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.6.0
		     * @category String
		     * @param {string} [string=''] The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('fred, barney, &amp; pebbles');
		     * // => 'fred, barney, & pebbles'
		     */
		    function unescape(string) {
		      string = toString(string);
		      return (string && reHasEscapedHtml.test(string))
		        ? string.replace(reEscapedHtml, unescapeHtmlChar)
		        : string;
		    }
		
		    /**
		     * Converts `string`, as space separated words, to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.upperCase('--foo-bar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('fooBar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('__foo_bar__');
		     * // => 'FOO BAR'
		     */
		    var upperCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toUpperCase();
		    });
		
		    /**
		     * Converts the first character of `string` to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.upperFirst('fred');
		     * // => 'Fred'
		     *
		     * _.upperFirst('FRED');
		     * // => 'FRED'
		     */
		    var upperFirst = createCaseFirst('toUpperCase');
		
		    /**
		     * Splits `string` into an array of its words.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {RegExp|string} [pattern] The pattern to match words.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the words of `string`.
		     * @example
		     *
		     * _.words('fred, barney, & pebbles');
		     * // => ['fred', 'barney', 'pebbles']
		     *
		     * _.words('fred, barney, & pebbles', /[^, ]+/g);
		     * // => ['fred', 'barney', '&', 'pebbles']
		     */
		    function words(string, pattern, guard) {
		      string = toString(string);
		      pattern = guard ? undefined : pattern;
		
		      if (pattern === undefined) {
		        pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
		      }
		      return string.match(pattern) || [];
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Attempts to invoke `func`, returning either the result or the caught error
		     * object. Any additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Function} func The function to attempt.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {*} Returns the `func` result or error object.
		     * @example
		     *
		     * // Avoid throwing errors for invalid selectors.
		     * var elements = _.attempt(function(selector) {
		     *   return document.querySelectorAll(selector);
		     * }, '>_>');
		     *
		     * if (_.isError(elements)) {
		     *   elements = [];
		     * }
		     */
		    var attempt = rest(function(func, args) {
		      try {
		        return apply(func, undefined, args);
		      } catch (e) {
		        return isError(e) ? e : new Error(e);
		      }
		    });
		
		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method.
		     *
		     * **Note:** This method doesn't set the "length" property of bound functions.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...(string|string[])} methodNames The object method names to bind.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'onClick': function() {
		     *     console.log('clicked ' + this.label);
		     *   }
		     * };
		     *
		     * _.bindAll(view, 'onClick');
		     * jQuery(element).on('click', view.onClick);
		     * // => Logs 'clicked docs' when clicked.
		     */
		    var bindAll = rest(function(object, methodNames) {
		      arrayEach(baseFlatten(methodNames, 1), function(key) {
		        object[key] = bind(object[key], object);
		      });
		      return object;
		    });
		
		    /**
		     * Creates a function that iterates over `pairs` and invokes the corresponding
		     * function of the first predicate to return truthy. The predicate-function
		     * pairs are invoked with the `this` binding and arguments of the created
		     * function.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Array} pairs The predicate-function pairs.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.cond([
		     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
		     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
		     *   [_.constant(true),                _.constant('no match')]
		     * ]);
		     *
		     * func({ 'a': 1, 'b': 2 });
		     * // => 'matches A'
		     *
		     * func({ 'a': 0, 'b': 1 });
		     * // => 'matches B'
		     *
		     * func({ 'a': '1', 'b': '2' });
		     * // => 'no match'
		     */
		    function cond(pairs) {
		      var length = pairs ? pairs.length : 0,
		          toIteratee = getIteratee();
		
		      pairs = !length ? [] : arrayMap(pairs, function(pair) {
		        if (typeof pair[1] != 'function') {
		          throw new TypeError(FUNC_ERROR_TEXT);
		        }
		        return [toIteratee(pair[0]), pair[1]];
		      });
		
		      return rest(function(args) {
		        var index = -1;
		        while (++index < length) {
		          var pair = pairs[index];
		          if (apply(pair[0], this, args)) {
		            return apply(pair[1], this, args);
		          }
		        }
		      });
		    }
		
		    /**
		     * Creates a function that invokes the predicate properties of `source` with
		     * the corresponding property values of a given object, returning `true` if
		     * all predicates return truthy, else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     */
		    function conforms(source) {
		      return baseConforms(baseClone(source, true));
		    }
		
		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var object = { 'user': 'fred' };
		     * var getter = _.constant(object);
		     *
		     * getter() === object;
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }
		
		    /**
		     * Creates a function that returns the result of invoking the given functions
		     * with the `this` binding of the created function, where each successive
		     * invocation is supplied the return value of the previous.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] Functions to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flow(_.add, square);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flow = createFlow();
		
		    /**
		     * This method is like `_.flow` except that it creates a function that
		     * invokes the given functions from right to left.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] Functions to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flowRight(square, _.add);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flowRight = createFlow(true);
		
		    /**
		     * This method returns the first argument given to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * _.identity(object) === object;
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }
		
		    /**
		     * Creates a function that invokes `func` with the arguments of the created
		     * function. If `func` is a property name, the created function returns the
		     * property value for a given element. If `func` is an array or object, the
		     * created function returns `true` for elements that contain the equivalent
		     * source properties, otherwise it returns `false`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Util
		     * @param {*} [func=_.identity] The value to convert to a callback.
		     * @returns {Function} Returns the callback.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
		     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, _.iteratee(['user', 'fred']));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, _.iteratee('user'));
		     * // => ['barney', 'fred']
		     *
		     * // Create custom iteratee shorthands.
		     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
		     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
		     *     return func.test(string);
		     *   };
		     * });
		     *
		     * _.filter(['abc', 'def'], /ef/);
		     * // => ['def']
		     */
		    function iteratee(func) {
		      return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
		    }
		
		    /**
		     * Creates a function that performs a partial deep comparison between a given
		     * object and `source`, returning `true` if the given object has equivalent
		     * property values, else `false`. The created function is equivalent to
		     * `_.isMatch` with a `source` partially applied.
		     *
		     * **Note:** This method supports comparing the same values as `_.isEqual`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
		     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
		     */
		    function matches(source) {
		      return baseMatches(baseClone(source, true));
		    }
		
		    /**
		     * Creates a function that performs a partial deep comparison between the
		     * value at `path` of a given object to `srcValue`, returning `true` if the
		     * object value is equivalent, else `false`.
		     *
		     * **Note:** This method supports comparing the same values as `_.isEqual`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * _.find(users, _.matchesProperty('user', 'fred'));
		     * // => { 'user': 'fred' }
		     */
		    function matchesProperty(path, srcValue) {
		      return baseMatchesProperty(path, baseClone(srcValue, true));
		    }
		
		    /**
		     * Creates a function that invokes the method at `path` of a given object.
		     * Any additional arguments are provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': _.constant(2) } },
		     *   { 'a': { 'b': _.constant(1) } }
		     * ];
		     *
		     * _.map(objects, _.method('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(objects, _.method(['a', 'b']));
		     * // => [2, 1]
		     */
		    var method = rest(function(path, args) {
		      return function(object) {
		        return baseInvoke(object, path, args);
		      };
		    });
		
		    /**
		     * The opposite of `_.method`; this method creates a function that invokes
		     * the method at a given path of `object`. Any additional arguments are
		     * provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var array = _.times(3, _.constant),
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
		     * // => [2, 0]
		     */
		    var methodOf = rest(function(object, args) {
		      return function(path) {
		        return baseInvoke(object, path, args);
		      };
		    });
		
		    /**
		     * Adds all own enumerable string keyed function properties of a source
		     * object to the destination object. If `object` is a function, then methods
		     * are added to its prototype as well.
		     *
		     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
		     * avoid conflicts caused by modifying the original.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Function|Object} [object=lodash] The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
		     * @returns {Function|Object} Returns `object`.
		     * @example
		     *
		     * function vowels(string) {
		     *   return _.filter(string, function(v) {
		     *     return /[aeiou]/i.test(v);
		     *   });
		     * }
		     *
		     * _.mixin({ 'vowels': vowels });
		     * _.vowels('fred');
		     * // => ['e']
		     *
		     * _('fred').vowels().value();
		     * // => ['e']
		     *
		     * _.mixin({ 'vowels': vowels }, { 'chain': false });
		     * _('fred').vowels();
		     * // => ['e']
		     */
		    function mixin(object, source, options) {
		      var props = keys(source),
		          methodNames = baseFunctions(source, props);
		
		      if (options == null &&
		          !(isObject(source) && (methodNames.length || !props.length))) {
		        options = source;
		        source = object;
		        object = this;
		        methodNames = baseFunctions(source, keys(source));
		      }
		      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
		          isFunc = isFunction(object);
		
		      arrayEach(methodNames, function(methodName) {
		        var func = source[methodName];
		        object[methodName] = func;
		        if (isFunc) {
		          object.prototype[methodName] = function() {
		            var chainAll = this.__chain__;
		            if (chain || chainAll) {
		              var result = object(this.__wrapped__),
		                  actions = result.__actions__ = copyArray(this.__actions__);
		
		              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
		              result.__chain__ = chainAll;
		              return result;
		            }
		            return func.apply(object, arrayPush([this.value()], arguments));
		          };
		        }
		      });
		
		      return object;
		    }
		
		    /**
		     * Reverts the `_` variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      if (root._ === this) {
		        root._ = oldDash;
		      }
		      return this;
		    }
		
		    /**
		     * A no-operation function that returns `undefined` regardless of the
		     * arguments it receives.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Util
		     * @example
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * _.noop(object) === undefined;
		     * // => true
		     */
		    function noop() {
		      // No operation performed.
		    }
		
		    /**
		     * Creates a function that returns its nth argument. If `n` is negative,
		     * the nth argument from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [n=0] The index of the argument to return.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.nthArg(1);
		     * func('a', 'b', 'c', 'd');
		     * // => 'b'
		     *
		     * var func = _.nthArg(-2);
		     * func('a', 'b', 'c', 'd');
		     * // => 'c'
		     */
		    function nthArg(n) {
		      n = toInteger(n);
		      return rest(function(args) {
		        return baseNth(args, n);
		      });
		    }
		
		    /**
		     * Creates a function that invokes `iteratees` with the arguments it receives
		     * and returns their results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
		     *  [iteratees=[_.identity]] The iteratees to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.over(Math.max, Math.min);
		     *
		     * func(1, 2, 3, 4);
		     * // => [4, 1]
		     */
		    var over = createOver(arrayMap);
		
		    /**
		     * Creates a function that checks if **all** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
		     *  [predicates=[_.identity]] The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overEvery(Boolean, isFinite);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => false
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overEvery = createOver(arrayEvery);
		
		    /**
		     * Creates a function that checks if **any** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
		     *  [predicates=[_.identity]] The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overSome(Boolean, isFinite);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => true
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overSome = createOver(arraySome);
		
		    /**
		     * Creates a function that returns the value at `path` of a given object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': 2 } },
		     *   { 'a': { 'b': 1 } }
		     * ];
		     *
		     * _.map(objects, _.property('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		     * // => [1, 2]
		     */
		    function property(path) {
		      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
		    }
		
		    /**
		     * The opposite of `_.property`; this method creates a function that returns
		     * the value at a given path of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var array = [0, 1, 2],
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
		     * // => [2, 0]
		     */
		    function propertyOf(object) {
		      return function(path) {
		        return object == null ? undefined : baseGet(object, path);
		      };
		    }
		
		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
		     * `start` is specified without an `end` or `step`. If `end` is not specified,
		     * it's set to `start` with `start` then set to `0`.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the new array of numbers.
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(-4);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    var range = createRange();
		
		    /**
		     * This method is like `_.range` except that it populates values in
		     * descending order.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the new array of numbers.
		     * @example
		     *
		     * _.rangeRight(4);
		     * // => [3, 2, 1, 0]
		     *
		     * _.rangeRight(-4);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 5);
		     * // => [4, 3, 2, 1]
		     *
		     * _.rangeRight(0, 20, 5);
		     * // => [15, 10, 5, 0]
		     *
		     * _.rangeRight(0, -4, -1);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.rangeRight(0);
		     * // => []
		     */
		    var rangeRight = createRange(true);
		
		    /**
		     * Invokes the iteratee `n` times, returning an array of the results of
		     * each invocation. The iteratee is invoked with one argument; (index).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} n The number of times to invoke `iteratee`.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.times(3, String);
		     * // => ['0', '1', '2']
		     *
		     *  _.times(4, _.constant(true));
		     * // => [true, true, true, true]
		     */
		    function times(n, iteratee) {
		      n = toInteger(n);
		      if (n < 1 || n > MAX_SAFE_INTEGER) {
		        return [];
		      }
		      var index = MAX_ARRAY_LENGTH,
		          length = nativeMin(n, MAX_ARRAY_LENGTH);
		
		      iteratee = getIteratee(iteratee);
		      n -= MAX_ARRAY_LENGTH;
		
		      var result = baseTimes(length, iteratee);
		      while (++index < n) {
		        iteratee(index);
		      }
		      return result;
		    }
		
		    /**
		     * Converts `value` to a property path array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the new property path array.
		     * @example
		     *
		     * _.toPath('a.b.c');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toPath('a[0].b.c');
		     * // => ['a', '0', 'b', 'c']
		     *
		     * var path = ['a', 'b', 'c'],
		     *     newPath = _.toPath(path);
		     *
		     * console.log(newPath);
		     * // => ['a', 'b', 'c']
		     *
		     * console.log(path === newPath);
		     * // => false
		     */
		    function toPath(value) {
		      if (isArray(value)) {
		        return arrayMap(value, toKey);
		      }
		      return isSymbol(value) ? [value] : copyArray(stringToPath(value));
		    }
		
		    /**
		     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {string} [prefix=''] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return toString(prefix) + id;
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * Adds two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {number} augend The first number in an addition.
		     * @param {number} addend The second number in an addition.
		     * @returns {number} Returns the total.
		     * @example
		     *
		     * _.add(6, 4);
		     * // => 10
		     */
		    var add = createMathOperation(function(augend, addend) {
		      return augend + addend;
		    });
		
		    /**
		     * Computes `number` rounded up to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round up.
		     * @param {number} [precision=0] The precision to round up to.
		     * @returns {number} Returns the rounded up number.
		     * @example
		     *
		     * _.ceil(4.006);
		     * // => 5
		     *
		     * _.ceil(6.004, 2);
		     * // => 6.01
		     *
		     * _.ceil(6040, -2);
		     * // => 6100
		     */
		    var ceil = createRound('ceil');
		
		    /**
		     * Divide two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} dividend The first number in a division.
		     * @param {number} divisor The second number in a division.
		     * @returns {number} Returns the quotient.
		     * @example
		     *
		     * _.divide(6, 4);
		     * // => 1.5
		     */
		    var divide = createMathOperation(function(dividend, divisor) {
		      return dividend / divisor;
		    });
		
		    /**
		     * Computes `number` rounded down to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round down.
		     * @param {number} [precision=0] The precision to round down to.
		     * @returns {number} Returns the rounded down number.
		     * @example
		     *
		     * _.floor(4.006);
		     * // => 4
		     *
		     * _.floor(0.046, 2);
		     * // => 0.04
		     *
		     * _.floor(4060, -2);
		     * // => 4000
		     */
		    var floor = createRound('floor');
		
		    /**
		     * Computes the maximum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * _.max([]);
		     * // => undefined
		     */
		    function max(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, gt)
		        : undefined;
		    }
		
		    /**
		     * This method is like `_.max` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.maxBy(objects, function(o) { return o.n; });
		     * // => { 'n': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.maxBy(objects, 'n');
		     * // => { 'n': 2 }
		     */
		    function maxBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee), gt)
		        : undefined;
		    }
		
		    /**
		     * Computes the mean of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * _.mean([4, 2, 8, 6]);
		     * // => 5
		     */
		    function mean(array) {
		      return baseMean(array, identity);
		    }
		
		    /**
		     * This method is like `_.mean` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be averaged.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.meanBy(objects, function(o) { return o.n; });
		     * // => 5
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.meanBy(objects, 'n');
		     * // => 5
		     */
		    function meanBy(array, iteratee) {
		      return baseMean(array, getIteratee(iteratee));
		    }
		
		    /**
		     * Computes the minimum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * _.min([]);
		     * // => undefined
		     */
		    function min(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, lt)
		        : undefined;
		    }
		
		    /**
		     * This method is like `_.min` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.minBy(objects, function(o) { return o.n; });
		     * // => { 'n': 1 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.minBy(objects, 'n');
		     * // => { 'n': 1 }
		     */
		    function minBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee), lt)
		        : undefined;
		    }
		
		    /**
		     * Multiply two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} multiplier The first number in a multiplication.
		     * @param {number} multiplicand The second number in a multiplication.
		     * @returns {number} Returns the product.
		     * @example
		     *
		     * _.multiply(6, 4);
		     * // => 24
		     */
		    var multiply = createMathOperation(function(multiplier, multiplicand) {
		      return multiplier * multiplicand;
		    });
		
		    /**
		     * Computes `number` rounded to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round.
		     * @param {number} [precision=0] The precision to round to.
		     * @returns {number} Returns the rounded number.
		     * @example
		     *
		     * _.round(4.006);
		     * // => 4
		     *
		     * _.round(4.006, 2);
		     * // => 4.01
		     *
		     * _.round(4060, -2);
		     * // => 4100
		     */
		    var round = createRound('round');
		
		    /**
		     * Subtract two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {number} minuend The first number in a subtraction.
		     * @param {number} subtrahend The second number in a subtraction.
		     * @returns {number} Returns the difference.
		     * @example
		     *
		     * _.subtract(6, 4);
		     * // => 2
		     */
		    var subtract = createMathOperation(function(minuend, subtrahend) {
		      return minuend - subtrahend;
		    });
		
		    /**
		     * Computes the sum of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * _.sum([4, 2, 8, 6]);
		     * // => 20
		     */
		    function sum(array) {
		      return (array && array.length)
		        ? baseSum(array, identity)
		        : 0;
		    }
		
		    /**
		     * This method is like `_.sum` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be summed.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Array|Function|Object|string} [iteratee=_.identity]
		     *  The iteratee invoked per element.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.sumBy(objects, function(o) { return o.n; });
		     * // => 20
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sumBy(objects, 'n');
		     * // => 20
		     */
		    function sumBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSum(array, getIteratee(iteratee))
		        : 0;
		    }
		
		    /*------------------------------------------------------------------------*/
		
		    // Add methods that return wrapped values in chain sequences.
		    lodash.after = after;
		    lodash.ary = ary;
		    lodash.assign = assign;
		    lodash.assignIn = assignIn;
		    lodash.assignInWith = assignInWith;
		    lodash.assignWith = assignWith;
		    lodash.at = at;
		    lodash.before = before;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.castArray = castArray;
		    lodash.chain = chain;
		    lodash.chunk = chunk;
		    lodash.compact = compact;
		    lodash.concat = concat;
		    lodash.cond = cond;
		    lodash.conforms = conforms;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.curry = curry;
		    lodash.curryRight = curryRight;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defaultsDeep = defaultsDeep;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.differenceBy = differenceBy;
		    lodash.differenceWith = differenceWith;
		    lodash.drop = drop;
		    lodash.dropRight = dropRight;
		    lodash.dropRightWhile = dropRightWhile;
		    lodash.dropWhile = dropWhile;
		    lodash.fill = fill;
		    lodash.filter = filter;
		    lodash.flatMap = flatMap;
		    lodash.flatMapDeep = flatMapDeep;
		    lodash.flatMapDepth = flatMapDepth;
		    lodash.flatten = flatten;
		    lodash.flattenDeep = flattenDeep;
		    lodash.flattenDepth = flattenDepth;
		    lodash.flip = flip;
		    lodash.flow = flow;
		    lodash.flowRight = flowRight;
		    lodash.fromPairs = fromPairs;
		    lodash.functions = functions;
		    lodash.functionsIn = functionsIn;
		    lodash.groupBy = groupBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.intersectionBy = intersectionBy;
		    lodash.intersectionWith = intersectionWith;
		    lodash.invert = invert;
		    lodash.invertBy = invertBy;
		    lodash.invokeMap = invokeMap;
		    lodash.iteratee = iteratee;
		    lodash.keyBy = keyBy;
		    lodash.keys = keys;
		    lodash.keysIn = keysIn;
		    lodash.map = map;
		    lodash.mapKeys = mapKeys;
		    lodash.mapValues = mapValues;
		    lodash.matches = matches;
		    lodash.matchesProperty = matchesProperty;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.mergeWith = mergeWith;
		    lodash.method = method;
		    lodash.methodOf = methodOf;
		    lodash.mixin = mixin;
		    lodash.negate = negate;
		    lodash.nthArg = nthArg;
		    lodash.omit = omit;
		    lodash.omitBy = omitBy;
		    lodash.once = once;
		    lodash.orderBy = orderBy;
		    lodash.over = over;
		    lodash.overArgs = overArgs;
		    lodash.overEvery = overEvery;
		    lodash.overSome = overSome;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.partition = partition;
		    lodash.pick = pick;
		    lodash.pickBy = pickBy;
		    lodash.property = property;
		    lodash.propertyOf = propertyOf;
		    lodash.pull = pull;
		    lodash.pullAll = pullAll;
		    lodash.pullAllBy = pullAllBy;
		    lodash.pullAllWith = pullAllWith;
		    lodash.pullAt = pullAt;
		    lodash.range = range;
		    lodash.rangeRight = rangeRight;
		    lodash.rearg = rearg;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.reverse = reverse;
		    lodash.sampleSize = sampleSize;
		    lodash.set = set;
		    lodash.setWith = setWith;
		    lodash.shuffle = shuffle;
		    lodash.slice = slice;
		    lodash.sortBy = sortBy;
		    lodash.sortedUniq = sortedUniq;
		    lodash.sortedUniqBy = sortedUniqBy;
		    lodash.split = split;
		    lodash.spread = spread;
		    lodash.tail = tail;
		    lodash.take = take;
		    lodash.takeRight = takeRight;
		    lodash.takeRightWhile = takeRightWhile;
		    lodash.takeWhile = takeWhile;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.thru = thru;
		    lodash.toArray = toArray;
		    lodash.toPairs = toPairs;
		    lodash.toPairsIn = toPairsIn;
		    lodash.toPath = toPath;
		    lodash.toPlainObject = toPlainObject;
		    lodash.transform = transform;
		    lodash.unary = unary;
		    lodash.union = union;
		    lodash.unionBy = unionBy;
		    lodash.unionWith = unionWith;
		    lodash.uniq = uniq;
		    lodash.uniqBy = uniqBy;
		    lodash.uniqWith = uniqWith;
		    lodash.unset = unset;
		    lodash.unzip = unzip;
		    lodash.unzipWith = unzipWith;
		    lodash.update = update;
		    lodash.updateWith = updateWith;
		    lodash.values = values;
		    lodash.valuesIn = valuesIn;
		    lodash.without = without;
		    lodash.words = words;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.xorBy = xorBy;
		    lodash.xorWith = xorWith;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
		    lodash.zipObjectDeep = zipObjectDeep;
		    lodash.zipWith = zipWith;
		
		    // Add aliases.
		    lodash.entries = toPairs;
		    lodash.entriesIn = toPairsIn;
		    lodash.extend = assignIn;
		    lodash.extendWith = assignInWith;
		
		    // Add methods to `lodash.prototype`.
		    mixin(lodash, lodash);
		
		    /*------------------------------------------------------------------------*/
		
		    // Add methods that return unwrapped values in chain sequences.
		    lodash.add = add;
		    lodash.attempt = attempt;
		    lodash.camelCase = camelCase;
		    lodash.capitalize = capitalize;
		    lodash.ceil = ceil;
		    lodash.clamp = clamp;
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.cloneDeepWith = cloneDeepWith;
		    lodash.cloneWith = cloneWith;
		    lodash.deburr = deburr;
		    lodash.divide = divide;
		    lodash.endsWith = endsWith;
		    lodash.eq = eq;
		    lodash.escape = escape;
		    lodash.escapeRegExp = escapeRegExp;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.floor = floor;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.get = get;
		    lodash.gt = gt;
		    lodash.gte = gte;
		    lodash.has = has;
		    lodash.hasIn = hasIn;
		    lodash.head = head;
		    lodash.identity = identity;
		    lodash.includes = includes;
		    lodash.indexOf = indexOf;
		    lodash.inRange = inRange;
		    lodash.invoke = invoke;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isArrayBuffer = isArrayBuffer;
		    lodash.isArrayLike = isArrayLike;
		    lodash.isArrayLikeObject = isArrayLikeObject;
		    lodash.isBoolean = isBoolean;
		    lodash.isBuffer = isBuffer;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isEqualWith = isEqualWith;
		    lodash.isError = isError;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isInteger = isInteger;
		    lodash.isLength = isLength;
		    lodash.isMap = isMap;
		    lodash.isMatch = isMatch;
		    lodash.isMatchWith = isMatchWith;
		    lodash.isNaN = isNaN;
		    lodash.isNative = isNative;
		    lodash.isNil = isNil;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isObjectLike = isObjectLike;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isSafeInteger = isSafeInteger;
		    lodash.isSet = isSet;
		    lodash.isString = isString;
		    lodash.isSymbol = isSymbol;
		    lodash.isTypedArray = isTypedArray;
		    lodash.isUndefined = isUndefined;
		    lodash.isWeakMap = isWeakMap;
		    lodash.isWeakSet = isWeakSet;
		    lodash.join = join;
		    lodash.kebabCase = kebabCase;
		    lodash.last = last;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.lowerCase = lowerCase;
		    lodash.lowerFirst = lowerFirst;
		    lodash.lt = lt;
		    lodash.lte = lte;
		    lodash.max = max;
		    lodash.maxBy = maxBy;
		    lodash.mean = mean;
		    lodash.meanBy = meanBy;
		    lodash.min = min;
		    lodash.minBy = minBy;
		    lodash.multiply = multiply;
		    lodash.nth = nth;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.pad = pad;
		    lodash.padEnd = padEnd;
		    lodash.padStart = padStart;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.repeat = repeat;
		    lodash.replace = replace;
		    lodash.result = result;
		    lodash.round = round;
		    lodash.runInContext = runInContext;
		    lodash.sample = sample;
		    lodash.size = size;
		    lodash.snakeCase = snakeCase;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.sortedIndexBy = sortedIndexBy;
		    lodash.sortedIndexOf = sortedIndexOf;
		    lodash.sortedLastIndex = sortedLastIndex;
		    lodash.sortedLastIndexBy = sortedLastIndexBy;
		    lodash.sortedLastIndexOf = sortedLastIndexOf;
		    lodash.startCase = startCase;
		    lodash.startsWith = startsWith;
		    lodash.subtract = subtract;
		    lodash.sum = sum;
		    lodash.sumBy = sumBy;
		    lodash.template = template;
		    lodash.times = times;
		    lodash.toInteger = toInteger;
		    lodash.toLength = toLength;
		    lodash.toLower = toLower;
		    lodash.toNumber = toNumber;
		    lodash.toSafeInteger = toSafeInteger;
		    lodash.toString = toString;
		    lodash.toUpper = toUpper;
		    lodash.trim = trim;
		    lodash.trimEnd = trimEnd;
		    lodash.trimStart = trimStart;
		    lodash.truncate = truncate;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
		    lodash.upperCase = upperCase;
		    lodash.upperFirst = upperFirst;
		
		    // Add aliases.
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.first = head;
		
		    mixin(lodash, (function() {
		      var source = {};
		      baseForOwn(lodash, function(func, methodName) {
		        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }()), { 'chain': false });
		
		    /*------------------------------------------------------------------------*/
		
		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type {string}
		     */
		    lodash.VERSION = VERSION;
		
		    // Assign default placeholders.
		    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
		      lodash[methodName].placeholder = lodash;
		    });
		
		    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
		    arrayEach(['drop', 'take'], function(methodName, index) {
		      LazyWrapper.prototype[methodName] = function(n) {
		        var filtered = this.__filtered__;
		        if (filtered && !index) {
		          return new LazyWrapper(this);
		        }
		        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
		
		        var result = this.clone();
		        if (filtered) {
		          result.__takeCount__ = nativeMin(n, result.__takeCount__);
		        } else {
		          result.__views__.push({
		            'size': nativeMin(n, MAX_ARRAY_LENGTH),
		            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
		          });
		        }
		        return result;
		      };
		
		      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
		        return this.reverse()[methodName](n).reverse();
		      };
		    });
		
		    // Add `LazyWrapper` methods that accept an `iteratee` value.
		    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
		      var type = index + 1,
		          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
		
		      LazyWrapper.prototype[methodName] = function(iteratee) {
		        var result = this.clone();
		        result.__iteratees__.push({
		          'iteratee': getIteratee(iteratee, 3),
		          'type': type
		        });
		        result.__filtered__ = result.__filtered__ || isFilter;
		        return result;
		      };
		    });
		
		    // Add `LazyWrapper` methods for `_.head` and `_.last`.
		    arrayEach(['head', 'last'], function(methodName, index) {
		      var takeName = 'take' + (index ? 'Right' : '');
		
		      LazyWrapper.prototype[methodName] = function() {
		        return this[takeName](1).value()[0];
		      };
		    });
		
		    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
		    arrayEach(['initial', 'tail'], function(methodName, index) {
		      var dropName = 'drop' + (index ? '' : 'Right');
		
		      LazyWrapper.prototype[methodName] = function() {
		        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
		      };
		    });
		
		    LazyWrapper.prototype.compact = function() {
		      return this.filter(identity);
		    };
		
		    LazyWrapper.prototype.find = function(predicate) {
		      return this.filter(predicate).head();
		    };
		
		    LazyWrapper.prototype.findLast = function(predicate) {
		      return this.reverse().find(predicate);
		    };
		
		    LazyWrapper.prototype.invokeMap = rest(function(path, args) {
		      if (typeof path == 'function') {
		        return new LazyWrapper(this);
		      }
		      return this.map(function(value) {
		        return baseInvoke(value, path, args);
		      });
		    });
		
		    LazyWrapper.prototype.reject = function(predicate) {
		      predicate = getIteratee(predicate, 3);
		      return this.filter(function(value) {
		        return !predicate(value);
		      });
		    };
		
		    LazyWrapper.prototype.slice = function(start, end) {
		      start = toInteger(start);
		
		      var result = this;
		      if (result.__filtered__ && (start > 0 || end < 0)) {
		        return new LazyWrapper(result);
		      }
		      if (start < 0) {
		        result = result.takeRight(-start);
		      } else if (start) {
		        result = result.drop(start);
		      }
		      if (end !== undefined) {
		        end = toInteger(end);
		        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
		      }
		      return result;
		    };
		
		    LazyWrapper.prototype.takeRightWhile = function(predicate) {
		      return this.reverse().takeWhile(predicate).reverse();
		    };
		
		    LazyWrapper.prototype.toArray = function() {
		      return this.take(MAX_ARRAY_LENGTH);
		    };
		
		    // Add `LazyWrapper` methods to `lodash.prototype`.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
		          isTaker = /^(?:head|last)$/.test(methodName),
		          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
		          retUnwrapped = isTaker || /^find/.test(methodName);
		
		      if (!lodashFunc) {
		        return;
		      }
		      lodash.prototype[methodName] = function() {
		        var value = this.__wrapped__,
		            args = isTaker ? [1] : arguments,
		            isLazy = value instanceof LazyWrapper,
		            iteratee = args[0],
		            useLazy = isLazy || isArray(value);
		
		        var interceptor = function(value) {
		          var result = lodashFunc.apply(lodash, arrayPush([value], args));
		          return (isTaker && chainAll) ? result[0] : result;
		        };
		
		        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
		          // Avoid lazy use if the iteratee has a "length" value other than `1`.
		          isLazy = useLazy = false;
		        }
		        var chainAll = this.__chain__,
		            isHybrid = !!this.__actions__.length,
		            isUnwrapped = retUnwrapped && !chainAll,
		            onlyLazy = isLazy && !isHybrid;
		
		        if (!retUnwrapped && useLazy) {
		          value = onlyLazy ? value : new LazyWrapper(this);
		          var result = func.apply(value, args);
		          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
		          return new LodashWrapper(result, chainAll);
		        }
		        if (isUnwrapped && onlyLazy) {
		          return func.apply(this, args);
		        }
		        result = this.thru(interceptor);
		        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
		      };
		    });
		
		    // Add `Array` methods to `lodash.prototype`.
		    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
		      var func = arrayProto[methodName],
		          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
		          retUnwrapped = /^(?:pop|shift)$/.test(methodName);
		
		      lodash.prototype[methodName] = function() {
		        var args = arguments;
		        if (retUnwrapped && !this.__chain__) {
		          var value = this.value();
		          return func.apply(isArray(value) ? value : [], args);
		        }
		        return this[chainName](function(value) {
		          return func.apply(isArray(value) ? value : [], args);
		        });
		      };
		    });
		
		    // Map minified method names to their real names.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var lodashFunc = lodash[methodName];
		      if (lodashFunc) {
		        var key = (lodashFunc.name + ''),
		            names = realNames[key] || (realNames[key] = []);
		
		        names.push({ 'name': methodName, 'func': lodashFunc });
		      }
		    });
		
		    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
		      'name': 'wrapper',
		      'func': undefined
		    }];
		
		    // Add methods to `LazyWrapper`.
		    LazyWrapper.prototype.clone = lazyClone;
		    LazyWrapper.prototype.reverse = lazyReverse;
		    LazyWrapper.prototype.value = lazyValue;
		
		    // Add chain sequence methods to the `lodash` wrapper.
		    lodash.prototype.at = wrapperAt;
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.commit = wrapperCommit;
		    lodash.prototype.next = wrapperNext;
		    lodash.prototype.plant = wrapperPlant;
		    lodash.prototype.reverse = wrapperReverse;
		    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
		
		    if (iteratorSymbol) {
		      lodash.prototype[iteratorSymbol] = wrapperToIterator;
		    }
		    return lodash;
		  }
		
		  /*--------------------------------------------------------------------------*/
		
		  // Export lodash.
		  var _ = runInContext();
		
		  // Expose lodash on the free variable `window` or `self` when available. This
		  // prevents errors in cases where lodash is loaded by a script tag in the presence
		  // of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch for more details.
		  (freeWindow || freeSelf || {})._ = _;
		
		  // Some AMD build optimizers like r.js check for condition patterns like the following:
		  if (true) {
		    // Define as an anonymous module so, through path mapping, it can be
		    // referenced as the "underscore" module.
		    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
		      return _;
		    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  }
		  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
		  else if (freeExports && freeModule) {
		    // Export for Node.js.
		    if (moduleExports) {
		      (freeModule.exports = _)._ = _;
		    }
		    // Export for CommonJS support.
		    freeExports._ = _;
		  }
		  else {
		    // Export to the global object.
		    root._ = _;
		  }
		}.call(this));
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		module.exports = function(module) {
			if(!module.webpackPolyfill) {
				module.deprecate = function() {};
				module.paths = [];
				// module.parent = undefined by default
				module.children = [];
				module.webpackPolyfill = 1;
			}
			return module;
		}
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
		var map = {
			"./circle.js": 8,
			"./curtain.js": 27,
			"./frame-it.js": 28,
			"./jammed-blind.js": 29,
			"./lateral-swipe.js": 30,
			"./lazy-stretch.js": 31,
			"./origami.js": 32,
			"./parallelogram.js": 33,
			"./plugins/snap.svg-min.js": 34,
			"./plugins/snap.svg.js": 35,
			"./plugins/svgLoader.js": 12,
			"./spill.js": 36,
			"./tilted.js": 37,
			"./transitions.js": 9,
			"./tunnel-vision.js": 38,
			"./wave.js": 39,
			"./widescreen-wiper.js": 40
		};
		function webpackContext(req) {
			return __webpack_require__(webpackContextResolve(req));
		};
		function webpackContextResolve(req) {
			return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
		};
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = 7;
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'circle', { speedIn : 300, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Created by alex on 2/22/2016.
		 */
		var _ = __webpack_require__(5);
		
		var random_string = +new Date;
		var transition_class = 'pageload-overlay_' + random_string;
		
		var css = __webpack_require__(10);
		var style = document.createElement('style');
		document.head.appendChild(style);
		style.title = transition_class;
		style.innerText = _.template(css)({
		    class_name: transition_class
		});
		
		__webpack_require__(11);
		__webpack_require__(12);
		
		function getStyleSheet(unique_title) {
		    for(var i=0; i<document.styleSheets.length; i++) {
		        var sheet = document.styleSheets[i];
		        if(sheet.title == unique_title) {
		            return sheet;
		        }
		    }
		}
		
		var style = getStyleSheet(transition_class),
		    rules = style.rules;
		
		    var bgcolorrule;
		    for(var i = 0; i < rules.length; i++) {
		        if (rules[i].selectorText == '.' + transition_class + '.show') {
		            bgcolorrule = rules[i];
		            break;
		        }
		    }
		    var fgcolorrule;
		    for(var i = 0; i < rules.length; i++) {
		        if (rules[i].selectorText == '.' + transition_class + ' svg path') {
		            fgcolorrule = rules[i];
		            break;
		        }
		    }
		
		
		module.exports = function(parent_el, animation, params) {
		
		    var temp = document.createElement('div');
		    temp.innerHTML = _.template(__webpack_require__(13)("./" + animation + '.html'))({
		        class_name: transition_class
		    });
		
		    var container = temp.querySelector('div');
		
		    parent_el.appendChild(container);
		
		    //cleanup
		    temp = null;
		
		    return {
		        animation: new SVGLoader( container, params ),
		        setBackgroundColor: function(color) {
		            bgcolorrule.style.background = color;
		        },
		        setForegroundColor: function(color) {
		            fgcolorrule.style.fill = color;
		        }
		    }
		};
	
	/***/ },
	/* 10 */
	/***/ function(module, exports) {
	
		module.exports = ".<%= class_name %> {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  top: 0;\r\n  left: 0;\r\n  visibility: hidden;\r\n}\r\n\r\n.<%= class_name %>.show {\r\n  visibility: visible;\r\n  background: #000000; /*change to make color effect*/\r\n}\r\n\r\n.<%= class_name %> svg {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  pointer-events: none;\r\n}\r\n\r\n.<%= class_name %> svg path {\r\n  fill: #000; /*change to make color effect*/\r\n}\r\n\r\n.<%= class_name %>::after,\r\n.<%= class_name %>::before {\r\n  content: '';\r\n  position: absolute;\r\n  width: 20px;\r\n  height: 20px;\r\n  top: 50%;\r\n  left: 50%;\r\n  margin: -10px 0 0 -10px;\r\n  border-radius: 50%;\r\n  visibility: hidden;\r\n  opacity: 0;\r\n  z-index: 1000;\r\n  -webkit-transition: opacity 0.15s, visibility 0s 0.15s;\r\n  transition: opacity 0.15s, visibility 0s 0.15s;\r\n}\r\n\r\n.<%= class_name %>::after {\r\n  background: #6cc88a;\r\n  -webkit-transform: translateX(-20px);\r\n  transform: translateX(-20px);\r\n  -webkit-animation: moveRight 0.6s linear infinite alternate;\r\n  animation: moveRight 0.6s linear infinite alternate;\r\n}\r\n\r\n.<%= class_name %>::before {\r\n  background: #4fc3f7;\r\n  -webkit-transform: translateX(20px);\r\n  transform: translateX(20px);\r\n  -webkit-animation: moveLeft 0.6s linear infinite alternate;\r\n  animation: moveLeft 0.6s linear infinite alternate;\r\n}\r\n\r\n@-webkit-keyframes moveRight {\r\n  to { -webkit-transform: translateX(20px); }\r\n}\r\n\r\n@keyframes moveRight {\r\n  to { transform: translateX(20px); }\r\n}\r\n\r\n@-webkit-keyframes moveLeft {\r\n  to { -webkit-transform: translateX(-20px); }\r\n}\r\n\r\n@keyframes moveLeft {\r\n  to { transform: translateX(-20px); }\r\n}\r\n\r\n.pageload-loading.<%= class_name %>::after,\r\n.pageload-loading.<%= class_name %>::before {\r\n  opacity: 1;\r\n  visibility: visible;\r\n  -webkit-transition: opacity 0.3s;\r\n  transition: opacity 0.3s;\r\n}";
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
		(function() {
		var fix = module.exports=0;
		
		// Snap.svg 0.4.1
		//
		// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		// http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		//
		// build: 2015-04-13
		
		!function(a){var b,c,d="0.4.2",e="hasOwnProperty",f=/[\.\/]/,g=/\s*,\s*/,h="*",i=function(a,b){return a-b},j={n:{}},k=function(){for(var a=0,b=this.length;b>a;a++)if("undefined"!=typeof this[a])return this[a]},l=function(){for(var a=this.length;--a;)if("undefined"!=typeof this[a])return this[a]},m=function(a,d){a=String(a);var e,f=c,g=Array.prototype.slice.call(arguments,2),h=m.listeners(a),j=0,n=[],o={},p=[],q=b;p.firstDefined=k,p.lastDefined=l,b=a,c=0;for(var r=0,s=h.length;s>r;r++)"zIndex"in h[r]&&(n.push(h[r].zIndex),h[r].zIndex<0&&(o[h[r].zIndex]=h[r]));for(n.sort(i);n[j]<0;)if(e=o[n[j++]],p.push(e.apply(d,g)),c)return c=f,p;for(r=0;s>r;r++)if(e=h[r],"zIndex"in e)if(e.zIndex==n[j]){if(p.push(e.apply(d,g)),c)break;do if(j++,e=o[n[j]],e&&p.push(e.apply(d,g)),c)break;while(e)}else o[e.zIndex]=e;else if(p.push(e.apply(d,g)),c)break;return c=f,b=q,p};m._events=j,m.listeners=function(a){var b,c,d,e,g,i,k,l,m=a.split(f),n=j,o=[n],p=[];for(e=0,g=m.length;g>e;e++){for(l=[],i=0,k=o.length;k>i;i++)for(n=o[i].n,c=[n[m[e]],n[h]],d=2;d--;)b=c[d],b&&(l.push(b),p=p.concat(b.f||[]));o=l}return p},m.on=function(a,b){if(a=String(a),"function"!=typeof b)return function(){};for(var c=a.split(g),d=0,e=c.length;e>d;d++)!function(a){for(var c,d=a.split(f),e=j,g=0,h=d.length;h>g;g++)e=e.n,e=e.hasOwnProperty(d[g])&&e[d[g]]||(e[d[g]]={n:{}});for(e.f=e.f||[],g=0,h=e.f.length;h>g;g++)if(e.f[g]==b){c=!0;break}!c&&e.f.push(b)}(c[d]);return function(a){+a==+a&&(b.zIndex=+a)}},m.f=function(a){var b=[].slice.call(arguments,1);return function(){m.apply(null,[a,null].concat(b).concat([].slice.call(arguments,0)))}},m.stop=function(){c=1},m.nt=function(a){return a?new RegExp("(?:\\.|\\/|^)"+a+"(?:\\.|\\/|$)").test(b):b},m.nts=function(){return b.split(f)},m.off=m.unbind=function(a,b){if(!a)return void(m._events=j={n:{}});var c=a.split(g);if(c.length>1)for(var d=0,i=c.length;i>d;d++)m.off(c[d],b);else{c=a.split(f);var k,l,n,d,i,o,p,q=[j];for(d=0,i=c.length;i>d;d++)for(o=0;o<q.length;o+=n.length-2){if(n=[o,1],k=q[o].n,c[d]!=h)k[c[d]]&&n.push(k[c[d]]);else for(l in k)k[e](l)&&n.push(k[l]);q.splice.apply(q,n)}for(d=0,i=q.length;i>d;d++)for(k=q[d];k.n;){if(b){if(k.f){for(o=0,p=k.f.length;p>o;o++)if(k.f[o]==b){k.f.splice(o,1);break}!k.f.length&&delete k.f}for(l in k.n)if(k.n[e](l)&&k.n[l].f){var r=k.n[l].f;for(o=0,p=r.length;p>o;o++)if(r[o]==b){r.splice(o,1);break}!r.length&&delete k.n[l].f}}else{delete k.f;for(l in k.n)k.n[e](l)&&k.n[l].f&&delete k.n[l].f}k=k.n}}},m.once=function(a,b){var c=function(){return m.unbind(a,c),b.apply(this,arguments)};return m.on(a,c)},m.version=d,m.toString=function(){return"You are running Eve "+d},"undefined"!=typeof module&&module.exports?module.exports=m: true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function(){return m}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):a.eve=m}(this),function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function(c){return b(a,c)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if("undefined"!=typeof exports){var c=require("eve");module.exports=b(a,c)}else b(a,a.eve)}(window||this,function(a,b){var c=function(b){var c={},d=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.mozRequestAnimationFrame||a.oRequestAnimationFrame||a.msRequestAnimationFrame||function(a){setTimeout(a,16)},e=Array.isArray||function(a){return a instanceof Array||"[object Array]"==Object.prototype.toString.call(a)},f=0,g="M"+(+new Date).toString(36),h=function(){return g+(f++).toString(36)},i=Date.now||function(){return+new Date},j=function(a){var b=this;if(null==a)return b.s;var c=b.s-a;b.b+=b.dur*c,b.B+=b.dur*c,b.s=a},k=function(a){var b=this;return null==a?b.spd:void(b.spd=a)},l=function(a){var b=this;return null==a?b.dur:(b.s=b.s*a/b.dur,void(b.dur=a))},m=function(){var a=this;delete c[a.id],a.update(),b("mina.stop."+a.id,a)},n=function(){var a=this;a.pdif||(delete c[a.id],a.update(),a.pdif=a.get()-a.b)},o=function(){var a=this;a.pdif&&(a.b=a.get()-a.pdif,delete a.pdif,c[a.id]=a)},p=function(){var a,b=this;if(e(b.start)){a=[];for(var c=0,d=b.start.length;d>c;c++)a[c]=+b.start[c]+(b.end[c]-b.start[c])*b.easing(b.s)}else a=+b.start+(b.end-b.start)*b.easing(b.s);b.set(a)},q=function(){var a=0;for(var e in c)if(c.hasOwnProperty(e)){var f=c[e],g=f.get();a++,f.s=(g-f.b)/(f.dur/f.spd),f.s>=1&&(delete c[e],f.s=1,a--,function(a){setTimeout(function(){b("mina.finish."+a.id,a)})}(f)),f.update()}a&&d(q)},r=function(a,b,e,f,g,i,s){var t={id:h(),start:a,end:b,b:e,s:0,dur:f-e,spd:1,get:g,set:i,easing:s||r.linear,status:j,speed:k,duration:l,stop:m,pause:n,resume:o,update:p};c[t.id]=t;var u,v=0;for(u in c)if(c.hasOwnProperty(u)&&(v++,2==v))break;return 1==v&&d(q),t};return r.time=i,r.getById=function(a){return c[a]||null},r.linear=function(a){return a},r.easeout=function(a){return Math.pow(a,1.7)},r.easein=function(a){return Math.pow(a,.48)},r.easeinout=function(a){if(1==a)return 1;if(0==a)return 0;var b=.48-a/1.04,c=Math.sqrt(.1734+b*b),d=c-b,e=Math.pow(Math.abs(d),1/3)*(0>d?-1:1),f=-c-b,g=Math.pow(Math.abs(f),1/3)*(0>f?-1:1),h=e+g+.5;return 3*(1-h)*h*h+h*h*h},r.backin=function(a){if(1==a)return 1;var b=1.70158;return a*a*((b+1)*a-b)},r.backout=function(a){if(0==a)return 0;a-=1;var b=1.70158;return a*a*((b+1)*a+b)+1},r.elastic=function(a){return a==!!a?a:Math.pow(2,-10*a)*Math.sin(2*(a-.075)*Math.PI/.3)+1},r.bounce=function(a){var b,c=7.5625,d=2.75;return 1/d>a?b=c*a*a:2/d>a?(a-=1.5/d,b=c*a*a+.75):2.5/d>a?(a-=2.25/d,b=c*a*a+.9375):(a-=2.625/d,b=c*a*a+.984375),b},a.mina=r,r}("undefined"==typeof b?function(){}:b),d=function(a){function c(a,b){if(a){if(a.nodeType)return w(a);if(e(a,"array")&&c.set)return c.set.apply(c,a);if(a instanceof s)return a;if(null==b)return a=y.doc.querySelector(String(a)),w(a)}return a=null==a?"100%":a,b=null==b?"100%":b,new v(a,b)}function d(a,b){if(b){if("#text"==a&&(a=y.doc.createTextNode(b.text||b["#text"]||"")),"#comment"==a&&(a=y.doc.createComment(b.text||b["#text"]||"")),"string"==typeof a&&(a=d(a)),"string"==typeof b)return 1==a.nodeType?"xlink:"==b.substring(0,6)?a.getAttributeNS(T,b.substring(6)):"xml:"==b.substring(0,4)?a.getAttributeNS(U,b.substring(4)):a.getAttribute(b):"text"==b?a.nodeValue:null;if(1==a.nodeType){for(var c in b)if(b[z](c)){var e=A(b[c]);e?"xlink:"==c.substring(0,6)?a.setAttributeNS(T,c.substring(6),e):"xml:"==c.substring(0,4)?a.setAttributeNS(U,c.substring(4),e):a.setAttribute(c,e):a.removeAttribute(c)}}else"text"in b&&(a.nodeValue=b.text)}else a=y.doc.createElementNS(U,a);return a}function e(a,b){return b=A.prototype.toLowerCase.call(b),"finite"==b?isFinite(a):"array"==b&&(a instanceof Array||Array.isArray&&Array.isArray(a))?!0:"null"==b&&null===a||b==typeof a&&null!==a||"object"==b&&a===Object(a)||J.call(a).slice(8,-1).toLowerCase()==b}function f(a){if("function"==typeof a||Object(a)!==a)return a;var b=new a.constructor;for(var c in a)a[z](c)&&(b[c]=f(a[c]));return b}function h(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return a.push(a.splice(c,1)[0])}function i(a,b,c){function d(){var e=Array.prototype.slice.call(arguments,0),f=e.join("␀"),g=d.cache=d.cache||{},i=d.count=d.count||[];return g[z](f)?(h(i,f),c?c(g[f]):g[f]):(i.length>=1e3&&delete g[i.shift()],i.push(f),g[f]=a.apply(b,e),c?c(g[f]):g[f])}return d}function j(a,b,c,d,e,f){if(null==e){var g=a-c,h=b-d;return g||h?(180+180*D.atan2(-h,-g)/H+360)%360:0}return j(a,b,e,f)-j(c,d,e,f)}function k(a){return a%360*H/180}function l(a){return 180*a/H%360}function m(a){var b=[];return a=a.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g,function(a,c,d){return d=d.split(/\s*,\s*|\s+/),"rotate"==c&&1==d.length&&d.push(0,0),"scale"==c&&(d.length>2?d=d.slice(0,2):2==d.length&&d.push(0,0),1==d.length&&d.push(d[0],0,0)),b.push("skewX"==c?["m",1,0,D.tan(k(d[0])),1,0,0]:"skewY"==c?["m",1,D.tan(k(d[0])),0,1,0,0]:[c.charAt(0)].concat(d)),a}),b}function n(a,b){var d=ab(a),e=new c.Matrix;if(d)for(var f=0,g=d.length;g>f;f++){var h,i,j,k,l,m=d[f],n=m.length,o=A(m[0]).toLowerCase(),p=m[0]!=o,q=p?e.invert():0;"t"==o&&2==n?e.translate(m[1],0):"t"==o&&3==n?p?(h=q.x(0,0),i=q.y(0,0),j=q.x(m[1],m[2]),k=q.y(m[1],m[2]),e.translate(j-h,k-i)):e.translate(m[1],m[2]):"r"==o?2==n?(l=l||b,e.rotate(m[1],l.x+l.width/2,l.y+l.height/2)):4==n&&(p?(j=q.x(m[2],m[3]),k=q.y(m[2],m[3]),e.rotate(m[1],j,k)):e.rotate(m[1],m[2],m[3])):"s"==o?2==n||3==n?(l=l||b,e.scale(m[1],m[n-1],l.x+l.width/2,l.y+l.height/2)):4==n?p?(j=q.x(m[2],m[3]),k=q.y(m[2],m[3]),e.scale(m[1],m[1],j,k)):e.scale(m[1],m[1],m[2],m[3]):5==n&&(p?(j=q.x(m[3],m[4]),k=q.y(m[3],m[4]),e.scale(m[1],m[2],j,k)):e.scale(m[1],m[2],m[3],m[4])):"m"==o&&7==n&&e.add(m[1],m[2],m[3],m[4],m[5],m[6])}return e}function o(a){var b=a.node.ownerSVGElement&&w(a.node.ownerSVGElement)||a.node.parentNode&&w(a.node.parentNode)||c.select("svg")||c(0,0),d=b.select("defs"),e=null==d?!1:d.node;return e||(e=u("defs",b.node).node),e}function p(a){return a.node.ownerSVGElement&&w(a.node.ownerSVGElement)||c.select("svg")}function q(a,b,c){function e(a){if(null==a)return I;if(a==+a)return a;d(j,{width:a});try{return j.getBBox().width}catch(b){return 0}}function f(a){if(null==a)return I;if(a==+a)return a;d(j,{height:a});try{return j.getBBox().height}catch(b){return 0}}function g(d,e){null==b?i[d]=e(a.attr(d)||0):d==b&&(i=e(null==c?a.attr(d)||0:c))}var h=p(a).node,i={},j=h.querySelector(".svg---mgr");switch(j||(j=d("rect"),d(j,{x:-9e9,y:-9e9,width:10,height:10,"class":"svg---mgr",fill:"none"}),h.appendChild(j)),a.type){case"rect":g("rx",e),g("ry",f);case"image":g("width",e),g("height",f);case"text":g("x",e),g("y",f);break;case"circle":g("cx",e),g("cy",f),g("r",e);break;case"ellipse":g("cx",e),g("cy",f),g("rx",e),g("ry",f);break;case"line":g("x1",e),g("x2",e),g("y1",f),g("y2",f);break;case"marker":g("refX",e),g("markerWidth",e),g("refY",f),g("markerHeight",f);break;case"radialGradient":g("fx",e),g("fy",f);break;case"tspan":g("dx",e),g("dy",f);break;default:g(b,e)}return h.removeChild(j),i}function r(a){e(a,"array")||(a=Array.prototype.slice.call(arguments,0));for(var b=0,c=0,d=this.node;this[b];)delete this[b++];for(b=0;b<a.length;b++)"set"==a[b].type?a[b].forEach(function(a){d.appendChild(a.node)}):d.appendChild(a[b].node);var f=d.childNodes;for(b=0;b<f.length;b++)this[c++]=w(f[b]);return this}function s(a){if(a.snap in V)return V[a.snap];var b;try{b=a.ownerSVGElement}catch(c){}this.node=a,b&&(this.paper=new v(b)),this.type=a.tagName||a.nodeName;var d=this.id=S(this);if(this.anims={},this._={transform:[]},a.snap=d,V[d]=this,"g"==this.type&&(this.add=r),this.type in{g:1,mask:1,pattern:1,symbol:1})for(var e in v.prototype)v.prototype[z](e)&&(this[e]=v.prototype[e])}function t(a){this.node=a}function u(a,b){var c=d(a);b.appendChild(c);var e=w(c);return e}function v(a,b){var c,e,f,g=v.prototype;if(a&&"svg"==a.tagName){if(a.snap in V)return V[a.snap];var h=a.ownerDocument;c=new s(a),e=a.getElementsByTagName("desc")[0],f=a.getElementsByTagName("defs")[0],e||(e=d("desc"),e.appendChild(h.createTextNode("Created with Snap")),c.node.appendChild(e)),f||(f=d("defs"),c.node.appendChild(f)),c.defs=f;for(var i in g)g[z](i)&&(c[i]=g[i]);c.paper=c.root=c}else c=u("svg",y.doc.body),d(c.node,{height:b,version:1.1,width:a,xmlns:U});return c}function w(a){return a?a instanceof s||a instanceof t?a:a.tagName&&"svg"==a.tagName.toLowerCase()?new v(a):a.tagName&&"object"==a.tagName.toLowerCase()&&"image/svg+xml"==a.type?new v(a.contentDocument.getElementsByTagName("svg")[0]):new s(a):a}function x(a,b){for(var c=0,d=a.length;d>c;c++){var e={type:a[c].type,attr:a[c].attr()},f=a[c].children();b.push(e),f.length&&x(f,e.childNodes=[])}}c.version="0.4.0",c.toString=function(){return"Snap v"+this.version},c._={};var y={win:a.window,doc:a.window.document};c._.glob=y;{var z="hasOwnProperty",A=String,B=parseFloat,C=parseInt,D=Math,E=D.max,F=D.min,G=D.abs,H=(D.pow,D.PI),I=(D.round,""),J=Object.prototype.toString,K=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,L=(c._.separator=/[,\s]+/,/[\s]*,[\s]*/),M={hs:1,rg:1},N=/([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/gi,O=/([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/gi,P=/(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/gi,Q=0,R="S"+(+new Date).toString(36),S=function(a){return(a&&a.type?a.type:I)+R+(Q++).toString(36)},T="http://www.w3.org/1999/xlink",U="http://www.w3.org/2000/svg",V={};c.url=function(a){return"url('#"+a+"')"}}c._.$=d,c._.id=S,c.format=function(){var a=/\{([^\}]+)\}/g,b=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,c=function(a,c,d){var e=d;return c.replace(b,function(a,b,c,d,f){b=b||d,e&&(b in e&&(e=e[b]),"function"==typeof e&&f&&(e=e()))}),e=(null==e||e==d?a:e)+""};return function(b,d){return A(b).replace(a,function(a,b){return c(a,b,d)})}}(),c._.clone=f,c._.cacher=i,c.rad=k,c.deg=l,c.sin=function(a){return D.sin(c.rad(a))},c.tan=function(a){return D.tan(c.rad(a))},c.cos=function(a){return D.cos(c.rad(a))},c.asin=function(a){return c.deg(D.asin(a))},c.acos=function(a){return c.deg(D.acos(a))},c.atan=function(a){return c.deg(D.atan(a))},c.atan2=function(a){return c.deg(D.atan2(a))},c.angle=j,c.len=function(a,b,d,e){return Math.sqrt(c.len2(a,b,d,e))},c.len2=function(a,b,c,d){return(a-c)*(a-c)+(b-d)*(b-d)},c.closestPoint=function(a,b,c){function d(a){var d=a.x-b,e=a.y-c;return d*d+e*e}for(var e,f,g,h,i=a.node,j=i.getTotalLength(),k=j/i.pathSegList.numberOfItems*.125,l=1/0,m=0;j>=m;m+=k)(h=d(g=i.getPointAtLength(m)))<l&&(e=g,f=m,l=h);for(k*=.5;k>.5;){var n,o,p,q,r,s;(p=f-k)>=0&&(r=d(n=i.getPointAtLength(p)))<l?(e=n,f=p,l=r):(q=f+k)<=j&&(s=d(o=i.getPointAtLength(q)))<l?(e=o,f=q,l=s):k*=.5}return e={x:e.x,y:e.y,length:f,distance:Math.sqrt(l)}},c.is=e,c.snapTo=function(a,b,c){if(c=e(c,"finite")?c:10,e(a,"array")){for(var d=a.length;d--;)if(G(a[d]-b)<=c)return a[d]}else{a=+a;var f=b%a;if(c>f)return b-f;if(f>a-c)return b-f+a}return b},c.getRGB=i(function(a){if(!a||(a=A(a)).indexOf("-")+1)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z};if("none"==a)return{r:-1,g:-1,b:-1,hex:"none",toString:Z};if(!(M[z](a.toLowerCase().substring(0,2))||"#"==a.charAt())&&(a=W(a)),!a)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z};var b,d,f,g,h,i,j=a.match(K);return j?(j[2]&&(f=C(j[2].substring(5),16),d=C(j[2].substring(3,5),16),b=C(j[2].substring(1,3),16)),j[3]&&(f=C((h=j[3].charAt(3))+h,16),d=C((h=j[3].charAt(2))+h,16),b=C((h=j[3].charAt(1))+h,16)),j[4]&&(i=j[4].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),d=B(i[1]),"%"==i[1].slice(-1)&&(d*=2.55),f=B(i[2]),"%"==i[2].slice(-1)&&(f*=2.55),"rgba"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100)),j[5]?(i=j[5].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b/=100),d=B(i[1]),"%"==i[1].slice(-1)&&(d/=100),f=B(i[2]),"%"==i[2].slice(-1)&&(f/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsba"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),c.hsb2rgb(b,d,f,g)):j[6]?(i=j[6].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b/=100),d=B(i[1]),"%"==i[1].slice(-1)&&(d/=100),f=B(i[2]),"%"==i[2].slice(-1)&&(f/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsla"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),c.hsl2rgb(b,d,f,g)):(b=F(D.round(b),255),d=F(D.round(d),255),f=F(D.round(f),255),g=F(E(g,0),1),j={r:b,g:d,b:f,toString:Z},j.hex="#"+(16777216|f|d<<8|b<<16).toString(16).slice(1),j.opacity=e(g,"finite")?g:1,j)):{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z}},c),c.hsb=i(function(a,b,d){return c.hsb2rgb(a,b,d).hex}),c.hsl=i(function(a,b,d){return c.hsl2rgb(a,b,d).hex}),c.rgb=i(function(a,b,c,d){if(e(d,"finite")){var f=D.round;return"rgba("+[f(a),f(b),f(c),+d.toFixed(2)]+")"}return"#"+(16777216|c|b<<8|a<<16).toString(16).slice(1)});var W=function(a){var b=y.doc.getElementsByTagName("head")[0]||y.doc.getElementsByTagName("svg")[0],c="rgb(255, 0, 0)";return(W=i(function(a){if("red"==a.toLowerCase())return c;b.style.color=c,b.style.color=a;var d=y.doc.defaultView.getComputedStyle(b,I).getPropertyValue("color");return d==c?null:d}))(a)},X=function(){return"hsb("+[this.h,this.s,this.b]+")"},Y=function(){return"hsl("+[this.h,this.s,this.l]+")"},Z=function(){return 1==this.opacity||null==this.opacity?this.hex:"rgba("+[this.r,this.g,this.b,this.opacity]+")"},$=function(a,b,d){if(null==b&&e(a,"object")&&"r"in a&&"g"in a&&"b"in a&&(d=a.b,b=a.g,a=a.r),null==b&&e(a,string)){var f=c.getRGB(a);a=f.r,b=f.g,d=f.b}return(a>1||b>1||d>1)&&(a/=255,b/=255,d/=255),[a,b,d]},_=function(a,b,d,f){a=D.round(255*a),b=D.round(255*b),d=D.round(255*d);var g={r:a,g:b,b:d,opacity:e(f,"finite")?f:1,hex:c.rgb(a,b,d),toString:Z};return e(f,"finite")&&(g.opacity=f),g};c.color=function(a){var b;return e(a,"object")&&"h"in a&&"s"in a&&"b"in a?(b=c.hsb2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):e(a,"object")&&"h"in a&&"s"in a&&"l"in a?(b=c.hsl2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):(e(a,"string")&&(a=c.getRGB(a)),e(a,"object")&&"r"in a&&"g"in a&&"b"in a&&!("error"in a)?(b=c.rgb2hsl(a),a.h=b.h,a.s=b.s,a.l=b.l,b=c.rgb2hsb(a),a.v=b.b):(a={hex:"none"},a.r=a.g=a.b=a.h=a.s=a.v=a.l=-1,a.error=1)),a.toString=Z,a},c.hsb2rgb=function(a,b,c,d){e(a,"object")&&"h"in a&&"s"in a&&"b"in a&&(c=a.b,b=a.s,d=a.o,a=a.h),a*=360;var f,g,h,i,j;return a=a%360/60,j=c*b,i=j*(1-G(a%2-1)),f=g=h=c-j,a=~~a,f+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],_(f,g,h,d)},c.hsl2rgb=function(a,b,c,d){e(a,"object")&&"h"in a&&"s"in a&&"l"in a&&(c=a.l,b=a.s,a=a.h),(a>1||b>1||c>1)&&(a/=360,b/=100,c/=100),a*=360;var f,g,h,i,j;return a=a%360/60,j=2*b*(.5>c?c:1-c),i=j*(1-G(a%2-1)),f=g=h=c-j/2,a=~~a,f+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],_(f,g,h,d)},c.rgb2hsb=function(a,b,c){c=$(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g;return f=E(a,b,c),g=f-F(a,b,c),d=0==g?null:f==a?(b-c)/g:f==b?(c-a)/g+2:(a-b)/g+4,d=(d+360)%6*60/360,e=0==g?0:g/f,{h:d,s:e,b:f,toString:X}},c.rgb2hsl=function(a,b,c){c=$(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g,h,i;return g=E(a,b,c),h=F(a,b,c),i=g-h,d=0==i?null:g==a?(b-c)/i:g==b?(c-a)/i+2:(a-b)/i+4,d=(d+360)%6*60/360,f=(g+h)/2,e=0==i?0:.5>f?i/(2*f):i/(2-2*f),{h:d,s:e,l:f,toString:Y}},c.parsePathString=function(a){if(!a)return null;var b=c.path(a);if(b.arr)return c.path.clone(b.arr);var d={a:7,c:6,o:2,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,u:3,z:0},f=[];return e(a,"array")&&e(a[0],"array")&&(f=c.path.clone(a)),f.length||A(a).replace(N,function(a,b,c){var e=[],g=b.toLowerCase();if(c.replace(P,function(a,b){b&&e.push(+b)}),"m"==g&&e.length>2&&(f.push([b].concat(e.splice(0,2))),g="l",b="m"==b?"l":"L"),"o"==g&&1==e.length&&f.push([b,e[0]]),"r"==g)f.push([b].concat(e));else for(;e.length>=d[g]&&(f.push([b].concat(e.splice(0,d[g]))),d[g]););}),f.toString=c.path.toString,b.arr=c.path.clone(f),f};var ab=c.parseTransformString=function(a){if(!a)return null;var b=[];return e(a,"array")&&e(a[0],"array")&&(b=c.path.clone(a)),b.length||A(a).replace(O,function(a,c,d){{var e=[];c.toLowerCase()}d.replace(P,function(a,b){b&&e.push(+b)}),b.push([c].concat(e))}),b.toString=c.path.toString,b};c._.svgTransform2string=m,c._.rgTransform=/^[a-z][\s]*-?\.?\d/i,c._.transform2matrix=n,c._unit2px=q;y.doc.contains||y.doc.compareDocumentPosition?function(a,b){var c=9==a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a==d||!(!d||1!=d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)for(;b;)if(b=b.parentNode,b==a)return!0;return!1};c._.getSomeDefs=o,c._.getSomeSVG=p,c.select=function(a){return a=A(a).replace(/([^\\]):/g,"$1\\:"),w(y.doc.querySelector(a))},c.selectAll=function(a){for(var b=y.doc.querySelectorAll(a),d=(c.set||Array)(),e=0;e<b.length;e++)d.push(w(b[e]));return d},setInterval(function(){for(var a in V)if(V[z](a)){var b=V[a],c=b.node;("svg"!=b.type&&!c.ownerSVGElement||"svg"==b.type&&(!c.parentNode||"ownerSVGElement"in c.parentNode&&!c.ownerSVGElement))&&delete V[a]}},1e4),s.prototype.attr=function(a,c){var d=this,f=d.node;if(!a){if(1!=f.nodeType)return{text:f.nodeValue};for(var g=f.attributes,h={},i=0,j=g.length;j>i;i++)h[g[i].nodeName]=g[i].nodeValue;return h}if(e(a,"string")){if(!(arguments.length>1))return b("snap.util.getattr."+a,d).firstDefined();var k={};k[a]=c,a=k}for(var l in a)a[z](l)&&b("snap.util.attr."+l,d,a[l]);return d},c.parse=function(a){var b=y.doc.createDocumentFragment(),c=!0,d=y.doc.createElement("div");if(a=A(a),a.match(/^\s*<\s*svg(?:\s|>)/)||(a="<svg>"+a+"</svg>",c=!1),d.innerHTML=a,a=d.getElementsByTagName("svg")[0])if(c)b=a;else for(;a.firstChild;)b.appendChild(a.firstChild);return new t(b)},c.fragment=function(){for(var a=Array.prototype.slice.call(arguments,0),b=y.doc.createDocumentFragment(),d=0,e=a.length;e>d;d++){var f=a[d];f.node&&f.node.nodeType&&b.appendChild(f.node),f.nodeType&&b.appendChild(f),"string"==typeof f&&b.appendChild(c.parse(f).node)}return new t(b)},c._.make=u,c._.wrap=w,v.prototype.el=function(a,b){var c=u(a,this.node);return b&&c.attr(b),c},s.prototype.children=function(){for(var a=[],b=this.node.childNodes,d=0,e=b.length;e>d;d++)a[d]=c(b[d]);return a},s.prototype.toJSON=function(){var a=[];return x([this],a),a[0]},b.on("snap.util.getattr",function(){var a=b.nt();a=a.substring(a.lastIndexOf(".")+1);var c=a.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});return bb[z](c)?this.node.ownerDocument.defaultView.getComputedStyle(this.node,null).getPropertyValue(c):d(this.node,a)});var bb={"alignment-baseline":0,"baseline-shift":0,clip:0,"clip-path":0,"clip-rule":0,color:0,"color-interpolation":0,"color-interpolation-filters":0,"color-profile":0,"color-rendering":0,cursor:0,direction:0,display:0,"dominant-baseline":0,"enable-background":0,fill:0,"fill-opacity":0,"fill-rule":0,filter:0,"flood-color":0,"flood-opacity":0,font:0,"font-family":0,"font-size":0,"font-size-adjust":0,"font-stretch":0,"font-style":0,"font-variant":0,"font-weight":0,"glyph-orientation-horizontal":0,"glyph-orientation-vertical":0,"image-rendering":0,kerning:0,"letter-spacing":0,"lighting-color":0,marker:0,"marker-end":0,"marker-mid":0,"marker-start":0,mask:0,opacity:0,overflow:0,"pointer-events":0,"shape-rendering":0,"stop-color":0,"stop-opacity":0,stroke:0,"stroke-dasharray":0,"stroke-dashoffset":0,"stroke-linecap":0,"stroke-linejoin":0,"stroke-miterlimit":0,"stroke-opacity":0,"stroke-width":0,"text-anchor":0,"text-decoration":0,"text-rendering":0,"unicode-bidi":0,visibility:0,"word-spacing":0,"writing-mode":0};b.on("snap.util.attr",function(a){var c=b.nt(),e={};c=c.substring(c.lastIndexOf(".")+1),e[c]=a;var f=c.replace(/-(\w)/gi,function(a,b){return b.toUpperCase()}),g=c.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});bb[z](g)?this.node.style[f]=null==a?I:a:d(this.node,e)}),function(){}(v.prototype),c.ajax=function(a,c,d,f){var g=new XMLHttpRequest,h=S();if(g){if(e(c,"function"))f=d,d=c,c=null;else if(e(c,"object")){var i=[];for(var j in c)c.hasOwnProperty(j)&&i.push(encodeURIComponent(j)+"="+encodeURIComponent(c[j]));c=i.join("&")}return g.open(c?"POST":"GET",a,!0),c&&(g.setRequestHeader("X-Requested-With","XMLHttpRequest"),g.setRequestHeader("Content-type","application/x-www-form-urlencoded")),d&&(b.once("snap.ajax."+h+".0",d),b.once("snap.ajax."+h+".200",d),b.once("snap.ajax."+h+".304",d)),g.onreadystatechange=function(){4==g.readyState&&b("snap.ajax."+h+"."+g.status,f,g)},4==g.readyState?g:(g.send(c),g)}},c.load=function(a,b,d){c.ajax(a,function(a){var e=c.parse(a.responseText);d?b.call(d,e):b(e)})};var cb=function(a){var b=a.getBoundingClientRect(),c=a.ownerDocument,d=c.body,e=c.documentElement,f=e.clientTop||d.clientTop||0,h=e.clientLeft||d.clientLeft||0,i=b.top+(g.win.pageYOffset||e.scrollTop||d.scrollTop)-f,j=b.left+(g.win.pageXOffset||e.scrollLeft||d.scrollLeft)-h;return{y:i,x:j}};return c.getElementByPoint=function(a,b){var c=this,d=(c.canvas,y.doc.elementFromPoint(a,b));if(y.win.opera&&"svg"==d.tagName){var e=cb(d),f=d.createSVGRect();f.x=a-e.x,f.y=b-e.y,f.width=f.height=1;var g=d.getIntersectionList(f,null);g.length&&(d=g[g.length-1])}return d?w(d):null},c.plugin=function(a){a(c,s,v,y,t)},y.win.Snap=c,c}(a||this);return d.plugin(function(d,e,f,g,h){function i(a,b){if(null==b){var c=!0;if(b=a.node.getAttribute("linearGradient"==a.type||"radialGradient"==a.type?"gradientTransform":"pattern"==a.type?"patternTransform":"transform"),!b)return new d.Matrix;b=d._.svgTransform2string(b)}else b=d._.rgTransform.test(b)?o(b).replace(/\.{3}|\u2026/g,a._.transform||""):d._.svgTransform2string(b),n(b,"array")&&(b=d.path?d.path.toString.call(b):o(b)),a._.transform=b;var e=d._.transform2matrix(b,a.getBBox(1));return c?e:void(a.matrix=e)}function j(a){function b(a,b){var c=q(a.node,b);c=c&&c.match(f),c=c&&c[2],c&&"#"==c.charAt()&&(c=c.substring(1),c&&(h[c]=(h[c]||[]).concat(function(c){var d={};d[b]=URL(c),q(a.node,d)})))}function c(a){var b=q(a.node,"xlink:href");b&&"#"==b.charAt()&&(b=b.substring(1),b&&(h[b]=(h[b]||[]).concat(function(b){a.attr("xlink:href","#"+b)})))}for(var d,e=a.selectAll("*"),f=/^\s*url\(("|'|)(.*)\1\)\s*$/,g=[],h={},i=0,j=e.length;j>i;i++){d=e[i],b(d,"fill"),b(d,"stroke"),b(d,"filter"),b(d,"mask"),b(d,"clip-path"),c(d);var k=q(d.node,"id");k&&(q(d.node,{id:d.id}),g.push({old:k,id:d.id}))}for(i=0,j=g.length;j>i;i++){var l=h[g[i].old];if(l)for(var m=0,n=l.length;n>m;m++)l[m](g[i].id)}}function k(a,b,c){return function(d){var e=d.slice(a,b);return 1==e.length&&(e=e[0]),c?c(e):e}}function l(a){return function(){var b=a?"<"+this.type:"",c=this.node.attributes,d=this.node.childNodes;if(a)for(var e=0,f=c.length;f>e;e++)b+=" "+c[e].name+'="'+c[e].value.replace(/"/g,'\\"')+'"';if(d.length){for(a&&(b+=">"),e=0,f=d.length;f>e;e++)3==d[e].nodeType?b+=d[e].nodeValue:1==d[e].nodeType&&(b+=u(d[e]).toString());a&&(b+="</"+this.type+">")}else a&&(b+="/>");return b}}var m=e.prototype,n=d.is,o=String,p=d._unit2px,q=d._.$,r=d._.make,s=d._.getSomeDefs,t="hasOwnProperty",u=d._.wrap;m.getBBox=function(a){if(!d.Matrix||!d.path)return this.node.getBBox();var b=this,c=new d.Matrix;if(b.removed)return d._.box();for(;"use"==b.type;)if(a||(c=c.add(b.transform().localMatrix.translate(b.attr("x")||0,b.attr("y")||0))),b.original)b=b.original;else{var e=b.attr("xlink:href");b=b.original=b.node.ownerDocument.getElementById(e.substring(e.indexOf("#")+1))}var f=b._,g=d.path.get[b.type]||d.path.get.deflt;try{return a?(f.bboxwt=g?d.path.getBBox(b.realPath=g(b)):d._.box(b.node.getBBox()),d._.box(f.bboxwt)):(b.realPath=g(b),b.matrix=b.transform().localMatrix,f.bbox=d.path.getBBox(d.path.map(b.realPath,c.add(b.matrix))),d._.box(f.bbox))}catch(h){return d._.box()}};var v=function(){return this.string};m.transform=function(a){var b=this._;if(null==a){for(var c,e=this,f=new d.Matrix(this.node.getCTM()),g=i(this),h=[g],j=new d.Matrix,k=g.toTransformString(),l=o(g)==o(this.matrix)?o(b.transform):k;"svg"!=e.type&&(e=e.parent());)h.push(i(e));for(c=h.length;c--;)j.add(h[c]);return{string:l,globalMatrix:f,totalMatrix:j,localMatrix:g,diffMatrix:f.clone().add(g.invert()),global:f.toTransformString(),total:j.toTransformString(),local:k,toString:v}}return a instanceof d.Matrix?(this.matrix=a,this._.transform=a.toTransformString()):i(this,a),this.node&&("linearGradient"==this.type||"radialGradient"==this.type?q(this.node,{gradientTransform:this.matrix}):"pattern"==this.type?q(this.node,{patternTransform:this.matrix}):q(this.node,{transform:this.matrix})),this},m.parent=function(){return u(this.node.parentNode)},m.append=m.add=function(a){if(a){if("set"==a.type){var b=this;return a.forEach(function(a){b.add(a)}),this}a=u(a),this.node.appendChild(a.node),a.paper=this.paper}return this},m.appendTo=function(a){return a&&(a=u(a),a.append(this)),this},m.prepend=function(a){if(a){if("set"==a.type){var b,c=this;return a.forEach(function(a){b?b.after(a):c.prepend(a),b=a}),this}a=u(a);var d=a.parent();this.node.insertBefore(a.node,this.node.firstChild),this.add&&this.add(),a.paper=this.paper,this.parent()&&this.parent().add(),d&&d.add()}return this},m.prependTo=function(a){return a=u(a),a.prepend(this),this},m.before=function(a){if("set"==a.type){var b=this;return a.forEach(function(a){var c=a.parent();b.node.parentNode.insertBefore(a.node,b.node),c&&c.add()}),this.parent().add(),this}a=u(a);var c=a.parent();return this.node.parentNode.insertBefore(a.node,this.node),this.parent()&&this.parent().add(),c&&c.add(),a.paper=this.paper,this},m.after=function(a){a=u(a);var b=a.parent();return this.node.nextSibling?this.node.parentNode.insertBefore(a.node,this.node.nextSibling):this.node.parentNode.appendChild(a.node),this.parent()&&this.parent().add(),b&&b.add(),a.paper=this.paper,this},m.insertBefore=function(a){a=u(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},m.insertAfter=function(a){a=u(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node.nextSibling),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},m.remove=function(){var a=this.parent();return this.node.parentNode&&this.node.parentNode.removeChild(this.node),delete this.paper,this.removed=!0,a&&a.add(),this},m.select=function(a){return u(this.node.querySelector(a))},m.selectAll=function(a){for(var b=this.node.querySelectorAll(a),c=(d.set||Array)(),e=0;e<b.length;e++)c.push(u(b[e]));return c},m.asPX=function(a,b){return null==b&&(b=this.attr(a)),+p(this,a,b)},m.use=function(){var a,b=this.node.id;return b||(b=this.id,q(this.node,{id:b})),a="linearGradient"==this.type||"radialGradient"==this.type||"pattern"==this.type?r(this.type,this.node.parentNode):r("use",this.node.parentNode),q(a.node,{"xlink:href":"#"+b}),a.original=this,a},m.clone=function(){var a=u(this.node.cloneNode(!0));return q(a.node,"id")&&q(a.node,{id:a.id}),j(a),a.insertAfter(this),a},m.toDefs=function(){var a=s(this);return a.appendChild(this.node),this},m.pattern=m.toPattern=function(a,b,c,d){var e=r("pattern",s(this));return null==a&&(a=this.getBBox()),n(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,a=a.x),q(e.node,{x:a,y:b,width:c,height:d,patternUnits:"userSpaceOnUse",id:e.id,viewBox:[a,b,c,d].join(" ")}),e.node.appendChild(this.node),e},m.marker=function(a,b,c,d,e,f){var g=r("marker",s(this));return null==a&&(a=this.getBBox()),n(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,e=a.refX||a.cx,f=a.refY||a.cy,a=a.x),q(g.node,{viewBox:[a,b,c,d].join(" "),markerWidth:c,markerHeight:d,orient:"auto",refX:e||0,refY:f||0,id:g.id}),g.node.appendChild(this.node),g};var w=function(a,b,d,e){"function"!=typeof d||d.length||(e=d,d=c.linear),this.attr=a,this.dur=b,d&&(this.easing=d),e&&(this.callback=e)};d._.Animation=w,d.animation=function(a,b,c,d){return new w(a,b,c,d)},m.inAnim=function(){var a=this,b=[];for(var c in a.anims)a.anims[t](c)&&!function(a){b.push({anim:new w(a._attrs,a.dur,a.easing,a._callback),mina:a,curStatus:a.status(),status:function(b){return a.status(b)},stop:function(){a.stop()}})}(a.anims[c]);return b},d.animate=function(a,d,e,f,g,h){"function"!=typeof g||g.length||(h=g,g=c.linear);var i=c.time(),j=c(a,d,i,i+f,c.time,e,g);return h&&b.once("mina.finish."+j.id,h),j},m.stop=function(){for(var a=this.inAnim(),b=0,c=a.length;c>b;b++)a[b].stop();return this},m.animate=function(a,d,e,f){"function"!=typeof e||e.length||(f=e,e=c.linear),a instanceof w&&(f=a.callback,e=a.easing,d=a.dur,a=a.attr);var g,h,i,j,l=[],m=[],p={},q=this;for(var r in a)if(a[t](r)){q.equal?(j=q.equal(r,o(a[r])),g=j.from,h=j.to,i=j.f):(g=+q.attr(r),h=+a[r]);var s=n(g,"array")?g.length:1;p[r]=k(l.length,l.length+s,i),l=l.concat(g),m=m.concat(h)}var u=c.time(),v=c(l,m,u,u+d,c.time,function(a){var b={};for(var c in p)p[t](c)&&(b[c]=p[c](a));q.attr(b)},e);return q.anims[v.id]=v,v._attrs=a,v._callback=f,b("snap.animcreated."+q.id,v),b.once("mina.finish."+v.id,function(){delete q.anims[v.id],f&&f.call(q)}),b.once("mina.stop."+v.id,function(){delete q.anims[v.id]}),q};var x={};m.data=function(a,c){var e=x[this.id]=x[this.id]||{};if(0==arguments.length)return b("snap.data.get."+this.id,this,e,null),e;
		if(1==arguments.length){if(d.is(a,"object")){for(var f in a)a[t](f)&&this.data(f,a[f]);return this}return b("snap.data.get."+this.id,this,e[a],a),e[a]}return e[a]=c,b("snap.data.set."+this.id,this,c,a),this},m.removeData=function(a){return null==a?x[this.id]={}:x[this.id]&&delete x[this.id][a],this},m.outerSVG=m.toString=l(1),m.innerSVG=l(),m.toDataURL=function(){if(a&&a.btoa){var b=this.getBBox(),c=d.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>',{x:+b.x.toFixed(3),y:+b.y.toFixed(3),width:+b.width.toFixed(3),height:+b.height.toFixed(3),contents:this.outerSVG()});return"data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(c)))}},h.prototype.select=m.select,h.prototype.selectAll=m.selectAll}),d.plugin(function(a){function b(a,b,d,e,f,g){return null==b&&"[object SVGMatrix]"==c.call(a)?(this.a=a.a,this.b=a.b,this.c=a.c,this.d=a.d,this.e=a.e,void(this.f=a.f)):void(null!=a?(this.a=+a,this.b=+b,this.c=+d,this.d=+e,this.e=+f,this.f=+g):(this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0))}var c=Object.prototype.toString,d=String,e=Math,f="";!function(c){function g(a){return a[0]*a[0]+a[1]*a[1]}function h(a){var b=e.sqrt(g(a));a[0]&&(a[0]/=b),a[1]&&(a[1]/=b)}c.add=function(a,c,d,e,f,g){var h,i,j,k,l=[[],[],[]],m=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],n=[[a,d,f],[c,e,g],[0,0,1]];for(a&&a instanceof b&&(n=[[a.a,a.c,a.e],[a.b,a.d,a.f],[0,0,1]]),h=0;3>h;h++)for(i=0;3>i;i++){for(k=0,j=0;3>j;j++)k+=m[h][j]*n[j][i];l[h][i]=k}return this.a=l[0][0],this.b=l[1][0],this.c=l[0][1],this.d=l[1][1],this.e=l[0][2],this.f=l[1][2],this},c.invert=function(){var a=this,c=a.a*a.d-a.b*a.c;return new b(a.d/c,-a.b/c,-a.c/c,a.a/c,(a.c*a.f-a.d*a.e)/c,(a.b*a.e-a.a*a.f)/c)},c.clone=function(){return new b(this.a,this.b,this.c,this.d,this.e,this.f)},c.translate=function(a,b){return this.add(1,0,0,1,a,b)},c.scale=function(a,b,c,d){return null==b&&(b=a),(c||d)&&this.add(1,0,0,1,c,d),this.add(a,0,0,b,0,0),(c||d)&&this.add(1,0,0,1,-c,-d),this},c.rotate=function(b,c,d){b=a.rad(b),c=c||0,d=d||0;var f=+e.cos(b).toFixed(9),g=+e.sin(b).toFixed(9);return this.add(f,g,-g,f,c,d),this.add(1,0,0,1,-c,-d)},c.x=function(a,b){return a*this.a+b*this.c+this.e},c.y=function(a,b){return a*this.b+b*this.d+this.f},c.get=function(a){return+this[d.fromCharCode(97+a)].toFixed(4)},c.toString=function(){return"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")"},c.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]},c.determinant=function(){return this.a*this.d-this.b*this.c},c.split=function(){var b={};b.dx=this.e,b.dy=this.f;var c=[[this.a,this.c],[this.b,this.d]];b.scalex=e.sqrt(g(c[0])),h(c[0]),b.shear=c[0][0]*c[1][0]+c[0][1]*c[1][1],c[1]=[c[1][0]-c[0][0]*b.shear,c[1][1]-c[0][1]*b.shear],b.scaley=e.sqrt(g(c[1])),h(c[1]),b.shear/=b.scaley,this.determinant()<0&&(b.scalex=-b.scalex);var d=-c[0][1],f=c[1][1];return 0>f?(b.rotate=a.deg(e.acos(f)),0>d&&(b.rotate=360-b.rotate)):b.rotate=a.deg(e.asin(d)),b.isSimple=!(+b.shear.toFixed(9)||b.scalex.toFixed(9)!=b.scaley.toFixed(9)&&b.rotate),b.isSuperSimple=!+b.shear.toFixed(9)&&b.scalex.toFixed(9)==b.scaley.toFixed(9)&&!b.rotate,b.noRotation=!+b.shear.toFixed(9)&&!b.rotate,b},c.toTransformString=function(a){var b=a||this.split();return+b.shear.toFixed(9)?"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]:(b.scalex=+b.scalex.toFixed(4),b.scaley=+b.scaley.toFixed(4),b.rotate=+b.rotate.toFixed(4),(b.dx||b.dy?"t"+[+b.dx.toFixed(4),+b.dy.toFixed(4)]:f)+(1!=b.scalex||1!=b.scaley?"s"+[b.scalex,b.scaley,0,0]:f)+(b.rotate?"r"+[+b.rotate.toFixed(4),0,0]:f))}}(b.prototype),a.Matrix=b,a.matrix=function(a,c,d,e,f,g){return new b(a,c,d,e,f,g)}}),d.plugin(function(a,c,d,e,f){function g(d){return function(e){if(b.stop(),e instanceof f&&1==e.node.childNodes.length&&("radialGradient"==e.node.firstChild.tagName||"linearGradient"==e.node.firstChild.tagName||"pattern"==e.node.firstChild.tagName)&&(e=e.node.firstChild,n(this).appendChild(e),e=l(e)),e instanceof c)if("radialGradient"==e.type||"linearGradient"==e.type||"pattern"==e.type){e.node.id||p(e.node,{id:e.id});var g=q(e.node.id)}else g=e.attr(d);else if(g=a.color(e),g.error){var h=a(n(this).ownerSVGElement).gradient(e);h?(h.node.id||p(h.node,{id:h.id}),g=q(h.node.id)):g=e}else g=r(g);var i={};i[d]=g,p(this.node,i),this.node.style[d]=t}}function h(a){b.stop(),a==+a&&(a+="px"),this.node.style.fontSize=a}function i(a){for(var b=[],c=a.childNodes,d=0,e=c.length;e>d;d++){var f=c[d];3==f.nodeType&&b.push(f.nodeValue),"tspan"==f.tagName&&b.push(1==f.childNodes.length&&3==f.firstChild.nodeType?f.firstChild.nodeValue:i(f))}return b}function j(){return b.stop(),this.node.style.fontSize}var k=a._.make,l=a._.wrap,m=a.is,n=a._.getSomeDefs,o=/^url\(#?([^)]+)\)$/,p=a._.$,q=a.url,r=String,s=a._.separator,t="";b.on("snap.util.attr.mask",function(a){if(a instanceof c||a instanceof f){if(b.stop(),a instanceof f&&1==a.node.childNodes.length&&(a=a.node.firstChild,n(this).appendChild(a),a=l(a)),"mask"==a.type)var d=a;else d=k("mask",n(this)),d.node.appendChild(a.node);!d.node.id&&p(d.node,{id:d.id}),p(this.node,{mask:q(d.id)})}}),function(a){b.on("snap.util.attr.clip",a),b.on("snap.util.attr.clip-path",a),b.on("snap.util.attr.clipPath",a)}(function(a){if(a instanceof c||a instanceof f){if(b.stop(),"clipPath"==a.type)var d=a;else d=k("clipPath",n(this)),d.node.appendChild(a.node),!d.node.id&&p(d.node,{id:d.id});p(this.node,{"clip-path":q(d.node.id||d.id)})}}),b.on("snap.util.attr.fill",g("fill")),b.on("snap.util.attr.stroke",g("stroke"));var u=/^([lr])(?:\(([^)]*)\))?(.*)$/i;b.on("snap.util.grad.parse",function(a){a=r(a);var b=a.match(u);if(!b)return null;var c=b[1],d=b[2],e=b[3];return d=d.split(/\s*,\s*/).map(function(a){return+a==a?+a:a}),1==d.length&&0==d[0]&&(d=[]),e=e.split("-"),e=e.map(function(a){a=a.split(":");var b={color:a[0]};return a[1]&&(b.offset=parseFloat(a[1])),b}),{type:c,params:d,stops:e}}),b.on("snap.util.attr.d",function(c){b.stop(),m(c,"array")&&m(c[0],"array")&&(c=a.path.toString.call(c)),c=r(c),c.match(/[ruo]/i)&&(c=a.path.toAbsolute(c)),p(this.node,{d:c})})(-1),b.on("snap.util.attr.#text",function(a){b.stop(),a=r(a);for(var c=e.doc.createTextNode(a);this.node.firstChild;)this.node.removeChild(this.node.firstChild);this.node.appendChild(c)})(-1),b.on("snap.util.attr.path",function(a){b.stop(),this.attr({d:a})})(-1),b.on("snap.util.attr.class",function(a){b.stop(),this.node.className.baseVal=a})(-1),b.on("snap.util.attr.viewBox",function(a){var c;c=m(a,"object")&&"x"in a?[a.x,a.y,a.width,a.height].join(" "):m(a,"array")?a.join(" "):a,p(this.node,{viewBox:c}),b.stop()})(-1),b.on("snap.util.attr.transform",function(a){this.transform(a),b.stop()})(-1),b.on("snap.util.attr.r",function(a){"rect"==this.type&&(b.stop(),p(this.node,{rx:a,ry:a}))})(-1),b.on("snap.util.attr.textpath",function(a){if(b.stop(),"text"==this.type){var d,e,f;if(!a&&this.textPath){for(e=this.textPath;e.node.firstChild;)this.node.appendChild(e.node.firstChild);return e.remove(),void delete this.textPath}if(m(a,"string")){var g=n(this),h=l(g.parentNode).path(a);g.appendChild(h.node),d=h.id,h.attr({id:d})}else a=l(a),a instanceof c&&(d=a.attr("id"),d||(d=a.id,a.attr({id:d})));if(d)if(e=this.textPath,f=this.node,e)e.attr({"xlink:href":"#"+d});else{for(e=p("textPath",{"xlink:href":"#"+d});f.firstChild;)e.appendChild(f.firstChild);f.appendChild(e),this.textPath=l(e)}}})(-1),b.on("snap.util.attr.text",function(a){if("text"==this.type){for(var c=this.node,d=function(a){var b=p("tspan");if(m(a,"array"))for(var c=0;c<a.length;c++)b.appendChild(d(a[c]));else b.appendChild(e.doc.createTextNode(a));return b.normalize&&b.normalize(),b};c.firstChild;)c.removeChild(c.firstChild);for(var f=d(a);f.firstChild;)c.appendChild(f.firstChild)}b.stop()})(-1),b.on("snap.util.attr.fontSize",h)(-1),b.on("snap.util.attr.font-size",h)(-1),b.on("snap.util.getattr.transform",function(){return b.stop(),this.transform()})(-1),b.on("snap.util.getattr.textpath",function(){return b.stop(),this.textPath})(-1),function(){function c(c){return function(){b.stop();var d=e.doc.defaultView.getComputedStyle(this.node,null).getPropertyValue("marker-"+c);return"none"==d?d:a(e.doc.getElementById(d.match(o)[1]))}}function d(a){return function(c){b.stop();var d="marker"+a.charAt(0).toUpperCase()+a.substring(1);if(""==c||!c)return void(this.node.style[d]="none");if("marker"==c.type){var e=c.node.id;return e||p(c.node,{id:c.id}),void(this.node.style[d]=q(e))}}}b.on("snap.util.getattr.marker-end",c("end"))(-1),b.on("snap.util.getattr.markerEnd",c("end"))(-1),b.on("snap.util.getattr.marker-start",c("start"))(-1),b.on("snap.util.getattr.markerStart",c("start"))(-1),b.on("snap.util.getattr.marker-mid",c("mid"))(-1),b.on("snap.util.getattr.markerMid",c("mid"))(-1),b.on("snap.util.attr.marker-end",d("end"))(-1),b.on("snap.util.attr.markerEnd",d("end"))(-1),b.on("snap.util.attr.marker-start",d("start"))(-1),b.on("snap.util.attr.markerStart",d("start"))(-1),b.on("snap.util.attr.marker-mid",d("mid"))(-1),b.on("snap.util.attr.markerMid",d("mid"))(-1)}(),b.on("snap.util.getattr.r",function(){return"rect"==this.type&&p(this.node,"rx")==p(this.node,"ry")?(b.stop(),p(this.node,"rx")):void 0})(-1),b.on("snap.util.getattr.text",function(){if("text"==this.type||"tspan"==this.type){b.stop();var a=i(this.node);return 1==a.length?a[0]:a}})(-1),b.on("snap.util.getattr.#text",function(){return this.node.textContent})(-1),b.on("snap.util.getattr.viewBox",function(){b.stop();var c=p(this.node,"viewBox");return c?(c=c.split(s),a._.box(+c[0],+c[1],+c[2],+c[3])):void 0})(-1),b.on("snap.util.getattr.points",function(){var a=p(this.node,"points");return b.stop(),a?a.split(s):void 0})(-1),b.on("snap.util.getattr.path",function(){var a=p(this.node,"d");return b.stop(),a})(-1),b.on("snap.util.getattr.class",function(){return this.node.className.baseVal})(-1),b.on("snap.util.getattr.fontSize",j)(-1),b.on("snap.util.getattr.font-size",j)(-1)}),d.plugin(function(a,b){var c=/\S+/g,d=String,e=b.prototype;e.addClass=function(a){var b,e,f,g,h=d(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];if(h.length){for(b=0;f=h[b++];)e=k.indexOf(f),~e||k.push(f);g=k.join(" "),j!=g&&(i.className.baseVal=g)}return this},e.removeClass=function(a){var b,e,f,g,h=d(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];if(k.length){for(b=0;f=h[b++];)e=k.indexOf(f),~e&&k.splice(e,1);g=k.join(" "),j!=g&&(i.className.baseVal=g)}return this},e.hasClass=function(a){var b=this.node,d=b.className.baseVal,e=d.match(c)||[];return!!~e.indexOf(a)},e.toggleClass=function(a,b){if(null!=b)return b?this.addClass(a):this.removeClass(a);var d,e,f,g,h=(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];for(d=0;f=h[d++];)e=k.indexOf(f),~e?k.splice(e,1):k.push(f);return g=k.join(" "),j!=g&&(i.className.baseVal=g),this}}),d.plugin(function(){function a(a){return a}function c(a){return function(b){return+b.toFixed(3)+a}}var d={"+":function(a,b){return a+b},"-":function(a,b){return a-b},"/":function(a,b){return a/b},"*":function(a,b){return a*b}},e=String,f=/[a-z]+$/i,g=/^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;b.on("snap.util.attr",function(a){var c=e(a).match(g);if(c){var h=b.nt(),i=h.substring(h.lastIndexOf(".")+1),j=this.attr(i),k={};b.stop();var l=c[3]||"",m=j.match(f),n=d[c[1]];if(m&&m==l?a=n(parseFloat(j),+c[2]):(j=this.asPX(i),a=n(this.asPX(i),this.asPX(i,c[2]+l))),isNaN(j)||isNaN(a))return;k[i]=a,this.attr(k)}})(-10),b.on("snap.util.equal",function(h,i){var j=e(this.attr(h)||""),k=e(i).match(g);if(k){b.stop();var l=k[3]||"",m=j.match(f),n=d[k[1]];return m&&m==l?{from:parseFloat(j),to:n(parseFloat(j),+k[2]),f:c(m)}:(j=this.asPX(h),{from:j,to:n(j,this.asPX(h,k[2]+l)),f:a})}})(-10)}),d.plugin(function(c,d,e,f){var g=e.prototype,h=c.is;g.rect=function(a,b,c,d,e,f){var g;return null==f&&(f=e),h(a,"object")&&"[object Object]"==a?g=a:null!=a&&(g={x:a,y:b,width:c,height:d},null!=e&&(g.rx=e,g.ry=f)),this.el("rect",g)},g.circle=function(a,b,c){var d;return h(a,"object")&&"[object Object]"==a?d=a:null!=a&&(d={cx:a,cy:b,r:c}),this.el("circle",d)};var i=function(){function a(){this.parentNode.removeChild(this)}return function(b,c){var d=f.doc.createElement("img"),e=f.doc.body;d.style.cssText="position:absolute;left:-9999em;top:-9999em",d.onload=function(){c.call(d),d.onload=d.onerror=null,e.removeChild(d)},d.onerror=a,e.appendChild(d),d.src=b}}();g.image=function(a,b,d,e,f){var g=this.el("image");if(h(a,"object")&&"src"in a)g.attr(a);else if(null!=a){var j={"xlink:href":a,preserveAspectRatio:"none"};null!=b&&null!=d&&(j.x=b,j.y=d),null!=e&&null!=f?(j.width=e,j.height=f):i(a,function(){c._.$(g.node,{width:this.offsetWidth,height:this.offsetHeight})}),c._.$(g.node,j)}return g},g.ellipse=function(a,b,c,d){var e;return h(a,"object")&&"[object Object]"==a?e=a:null!=a&&(e={cx:a,cy:b,rx:c,ry:d}),this.el("ellipse",e)},g.path=function(a){var b;return h(a,"object")&&!h(a,"array")?b=a:a&&(b={d:a}),this.el("path",b)},g.group=g.g=function(a){var b=this.el("g");return 1==arguments.length&&a&&!a.type?b.attr(a):arguments.length&&b.add(Array.prototype.slice.call(arguments,0)),b},g.svg=function(a,b,c,d,e,f,g,i){var j={};return h(a,"object")&&null==b?j=a:(null!=a&&(j.x=a),null!=b&&(j.y=b),null!=c&&(j.width=c),null!=d&&(j.height=d),null!=e&&null!=f&&null!=g&&null!=i&&(j.viewBox=[e,f,g,i])),this.el("svg",j)},g.mask=function(a){var b=this.el("mask");return 1==arguments.length&&a&&!a.type?b.attr(a):arguments.length&&b.add(Array.prototype.slice.call(arguments,0)),b},g.ptrn=function(a,b,c,d,e,f,g,i){if(h(a,"object"))var j=a;else j={patternUnits:"userSpaceOnUse"},a&&(j.x=a),b&&(j.y=b),null!=c&&(j.width=c),null!=d&&(j.height=d),j.viewBox=null!=e&&null!=f&&null!=g&&null!=i?[e,f,g,i]:[a||0,b||0,c||0,d||0];return this.el("pattern",j)},g.use=function(a){return null!=a?(a instanceof d&&(a.attr("id")||a.attr({id:c._.id(a)}),a=a.attr("id")),"#"==String(a).charAt()&&(a=a.substring(1)),this.el("use",{"xlink:href":"#"+a})):d.prototype.use.call(this)},g.symbol=function(a,b,c,d){var e={};return null!=a&&null!=b&&null!=c&&null!=d&&(e.viewBox=[a,b,c,d]),this.el("symbol",e)},g.text=function(a,b,c){var d={};return h(a,"object")?d=a:null!=a&&(d={x:a,y:b,text:c||""}),this.el("text",d)},g.line=function(a,b,c,d){var e={};return h(a,"object")?e=a:null!=a&&(e={x1:a,x2:c,y1:b,y2:d}),this.el("line",e)},g.polyline=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b={};return h(a,"object")&&!h(a,"array")?b=a:null!=a&&(b={points:a}),this.el("polyline",b)},g.polygon=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b={};return h(a,"object")&&!h(a,"array")?b=a:null!=a&&(b={points:a}),this.el("polygon",b)},function(){function d(){return this.selectAll("stop")}function e(a,b){var d=k("stop"),e={offset:+b+"%"};return a=c.color(a),e["stop-color"]=a.hex,a.opacity<1&&(e["stop-opacity"]=a.opacity),k(d,e),this.node.appendChild(d),this}function f(){if("linearGradient"==this.type){var a=k(this.node,"x1")||0,b=k(this.node,"x2")||1,d=k(this.node,"y1")||0,e=k(this.node,"y2")||0;return c._.box(a,d,math.abs(b-a),math.abs(e-d))}var f=this.node.cx||.5,g=this.node.cy||.5,h=this.node.r||0;return c._.box(f-h,g-h,2*h,2*h)}function h(a,c){function d(a,b){for(var c=(b-l)/(a-m),d=m;a>d;d++)g[d].offset=+(+l+c*(d-m)).toFixed(2);m=a,l=b}var e,f=b("snap.util.grad.parse",null,c).firstDefined();if(!f)return null;f.params.unshift(a),e="l"==f.type.toLowerCase()?i.apply(0,f.params):j.apply(0,f.params),f.type!=f.type.toLowerCase()&&k(e.node,{gradientUnits:"userSpaceOnUse"});var g=f.stops,h=g.length,l=0,m=0;h--;for(var n=0;h>n;n++)"offset"in g[n]&&d(n,g[n].offset);for(g[h].offset=g[h].offset||100,d(h,g[h].offset),n=0;h>=n;n++){var o=g[n];e.addStop(o.color,o.offset)}return e}function i(a,b,g,h,i){var j=c._.make("linearGradient",a);return j.stops=d,j.addStop=e,j.getBBox=f,null!=b&&k(j.node,{x1:b,y1:g,x2:h,y2:i}),j}function j(a,b,g,h,i,j){var l=c._.make("radialGradient",a);return l.stops=d,l.addStop=e,l.getBBox=f,null!=b&&k(l.node,{cx:b,cy:g,r:h}),null!=i&&null!=j&&k(l.node,{fx:i,fy:j}),l}var k=c._.$;g.gradient=function(a){return h(this.defs,a)},g.gradientLinear=function(a,b,c,d){return i(this.defs,a,b,c,d)},g.gradientRadial=function(a,b,c,d,e){return j(this.defs,a,b,c,d,e)},g.toString=function(){var a,b=this.node.ownerDocument,d=b.createDocumentFragment(),e=b.createElement("div"),f=this.node.cloneNode(!0);return d.appendChild(e),e.appendChild(f),c._.$(f,{xmlns:"http://www.w3.org/2000/svg"}),a=e.innerHTML,d.removeChild(d.firstChild),a},g.toDataURL=function(){return a&&a.btoa?"data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(this))):void 0},g.clear=function(){for(var a,b=this.node.firstChild;b;)a=b.nextSibling,"defs"!=b.tagName?b.parentNode.removeChild(b):g.clear.call({node:b}),b=a}}()}),d.plugin(function(a,b){function c(a){var b=c.ps=c.ps||{};return b[a]?b[a].sleep=100:b[a]={sleep:100},setTimeout(function(){for(var c in b)b[K](c)&&c!=a&&(b[c].sleep--,!b[c].sleep&&delete b[c])}),b[a]}function d(a,b,c,d){return null==a&&(a=b=c=d=0),null==b&&(b=a.y,c=a.width,d=a.height,a=a.x),{x:a,y:b,width:c,w:c,height:d,h:d,x2:a+c,y2:b+d,cx:a+c/2,cy:b+d/2,r1:N.min(c,d)/2,r2:N.max(c,d)/2,r0:N.sqrt(c*c+d*d)/2,path:w(a,b,c,d),vb:[a,b,c,d].join(" ")}}function e(){return this.join(",").replace(L,"$1")}function f(a){var b=J(a);return b.toString=e,b}function g(a,b,c,d,e,f,g,h,j){return null==j?n(a,b,c,d,e,f,g,h):i(a,b,c,d,e,f,g,h,o(a,b,c,d,e,f,g,h,j))}function h(c,d){function e(a){return+(+a).toFixed(3)}return a._.cacher(function(a,f,h){a instanceof b&&(a=a.attr("d")),a=E(a);for(var j,k,l,m,n,o="",p={},q=0,r=0,s=a.length;s>r;r++){if(l=a[r],"M"==l[0])j=+l[1],k=+l[2];else{if(m=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6]),q+m>f){if(d&&!p.start){if(n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q),o+=["C"+e(n.start.x),e(n.start.y),e(n.m.x),e(n.m.y),e(n.x),e(n.y)],h)return o;p.start=o,o=["M"+e(n.x),e(n.y)+"C"+e(n.n.x),e(n.n.y),e(n.end.x),e(n.end.y),e(l[5]),e(l[6])].join(),q+=m,j=+l[5],k=+l[6];continue}if(!c&&!d)return n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q)}q+=m,j=+l[5],k=+l[6]}o+=l.shift()+l}return p.end=o,n=c?q:d?p:i(j,k,l[0],l[1],l[2],l[3],l[4],l[5],1)},null,a._.clone)}function i(a,b,c,d,e,f,g,h,i){var j=1-i,k=R(j,3),l=R(j,2),m=i*i,n=m*i,o=k*a+3*l*i*c+3*j*i*i*e+n*g,p=k*b+3*l*i*d+3*j*i*i*f+n*h,q=a+2*i*(c-a)+m*(e-2*c+a),r=b+2*i*(d-b)+m*(f-2*d+b),s=c+2*i*(e-c)+m*(g-2*e+c),t=d+2*i*(f-d)+m*(h-2*f+d),u=j*a+i*c,v=j*b+i*d,w=j*e+i*g,x=j*f+i*h,y=90-180*N.atan2(q-s,r-t)/O;return{x:o,y:p,m:{x:q,y:r},n:{x:s,y:t},start:{x:u,y:v},end:{x:w,y:x},alpha:y}}function j(b,c,e,f,g,h,i,j){a.is(b,"array")||(b=[b,c,e,f,g,h,i,j]);var k=D.apply(null,b);return d(k.min.x,k.min.y,k.max.x-k.min.x,k.max.y-k.min.y)}function k(a,b,c){return b>=a.x&&b<=a.x+a.width&&c>=a.y&&c<=a.y+a.height}function l(a,b){return a=d(a),b=d(b),k(b,a.x,a.y)||k(b,a.x2,a.y)||k(b,a.x,a.y2)||k(b,a.x2,a.y2)||k(a,b.x,b.y)||k(a,b.x2,b.y)||k(a,b.x,b.y2)||k(a,b.x2,b.y2)||(a.x<b.x2&&a.x>b.x||b.x<a.x2&&b.x>a.x)&&(a.y<b.y2&&a.y>b.y||b.y<a.y2&&b.y>a.y)}function m(a,b,c,d,e){var f=-3*b+9*c-9*d+3*e,g=a*f+6*b-12*c+6*d;return a*g-3*b+3*c}function n(a,b,c,d,e,f,g,h,i){null==i&&(i=1),i=i>1?1:0>i?0:i;for(var j=i/2,k=12,l=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],n=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],o=0,p=0;k>p;p++){var q=j*l[p]+j,r=m(q,a,c,e,g),s=m(q,b,d,f,h),t=r*r+s*s;o+=n[p]*N.sqrt(t)}return j*o}function o(a,b,c,d,e,f,g,h,i){if(!(0>i||n(a,b,c,d,e,f,g,h)<i)){var j,k=1,l=k/2,m=k-l,o=.01;for(j=n(a,b,c,d,e,f,g,h,m);S(j-i)>o;)l/=2,m+=(i>j?1:-1)*l,j=n(a,b,c,d,e,f,g,h,m);return m}}function p(a,b,c,d,e,f,g,h){if(!(Q(a,c)<P(e,g)||P(a,c)>Q(e,g)||Q(b,d)<P(f,h)||P(b,d)>Q(f,h))){var i=(a*d-b*c)*(e-g)-(a-c)*(e*h-f*g),j=(a*d-b*c)*(f-h)-(b-d)*(e*h-f*g),k=(a-c)*(f-h)-(b-d)*(e-g);if(k){var l=i/k,m=j/k,n=+l.toFixed(2),o=+m.toFixed(2);if(!(n<+P(a,c).toFixed(2)||n>+Q(a,c).toFixed(2)||n<+P(e,g).toFixed(2)||n>+Q(e,g).toFixed(2)||o<+P(b,d).toFixed(2)||o>+Q(b,d).toFixed(2)||o<+P(f,h).toFixed(2)||o>+Q(f,h).toFixed(2)))return{x:l,y:m}}}}function q(a,b,c){var d=j(a),e=j(b);if(!l(d,e))return c?0:[];for(var f=n.apply(0,a),g=n.apply(0,b),h=~~(f/8),k=~~(g/8),m=[],o=[],q={},r=c?0:[],s=0;h+1>s;s++){var t=i.apply(0,a.concat(s/h));m.push({x:t.x,y:t.y,t:s/h})}for(s=0;k+1>s;s++)t=i.apply(0,b.concat(s/k)),o.push({x:t.x,y:t.y,t:s/k});for(s=0;h>s;s++)for(var u=0;k>u;u++){var v=m[s],w=m[s+1],x=o[u],y=o[u+1],z=S(w.x-v.x)<.001?"y":"x",A=S(y.x-x.x)<.001?"y":"x",B=p(v.x,v.y,w.x,w.y,x.x,x.y,y.x,y.y);if(B){if(q[B.x.toFixed(4)]==B.y.toFixed(4))continue;q[B.x.toFixed(4)]=B.y.toFixed(4);var C=v.t+S((B[z]-v[z])/(w[z]-v[z]))*(w.t-v.t),D=x.t+S((B[A]-x[A])/(y[A]-x[A]))*(y.t-x.t);C>=0&&1>=C&&D>=0&&1>=D&&(c?r++:r.push({x:B.x,y:B.y,t1:C,t2:D}))}}return r}function r(a,b){return t(a,b)}function s(a,b){return t(a,b,1)}function t(a,b,c){a=E(a),b=E(b);for(var d,e,f,g,h,i,j,k,l,m,n=c?0:[],o=0,p=a.length;p>o;o++){var r=a[o];if("M"==r[0])d=h=r[1],e=i=r[2];else{"C"==r[0]?(l=[d,e].concat(r.slice(1)),d=l[6],e=l[7]):(l=[d,e,d,e,h,i,h,i],d=h,e=i);for(var s=0,t=b.length;t>s;s++){var u=b[s];if("M"==u[0])f=j=u[1],g=k=u[2];else{"C"==u[0]?(m=[f,g].concat(u.slice(1)),f=m[6],g=m[7]):(m=[f,g,f,g,j,k,j,k],f=j,g=k);var v=q(l,m,c);if(c)n+=v;else{for(var w=0,x=v.length;x>w;w++)v[w].segment1=o,v[w].segment2=s,v[w].bez1=l,v[w].bez2=m;n=n.concat(v)}}}}}return n}function u(a,b,c){var d=v(a);return k(d,b,c)&&t(a,[["M",b,c],["H",d.x2+10]],1)%2==1}function v(a){var b=c(a);if(b.bbox)return J(b.bbox);if(!a)return d();a=E(a);for(var e,f=0,g=0,h=[],i=[],j=0,k=a.length;k>j;j++)if(e=a[j],"M"==e[0])f=e[1],g=e[2],h.push(f),i.push(g);else{var l=D(f,g,e[1],e[2],e[3],e[4],e[5],e[6]);h=h.concat(l.min.x,l.max.x),i=i.concat(l.min.y,l.max.y),f=e[5],g=e[6]}var m=P.apply(0,h),n=P.apply(0,i),o=Q.apply(0,h),p=Q.apply(0,i),q=d(m,n,o-m,p-n);return b.bbox=J(q),q}function w(a,b,c,d,f){if(f)return[["M",+a+ +f,b],["l",c-2*f,0],["a",f,f,0,0,1,f,f],["l",0,d-2*f],["a",f,f,0,0,1,-f,f],["l",2*f-c,0],["a",f,f,0,0,1,-f,-f],["l",0,2*f-d],["a",f,f,0,0,1,f,-f],["z"]];var g=[["M",a,b],["l",c,0],["l",0,d],["l",-c,0],["z"]];return g.toString=e,g}function x(a,b,c,d,f){if(null==f&&null==d&&(d=c),a=+a,b=+b,c=+c,d=+d,null!=f)var g=Math.PI/180,h=a+c*Math.cos(-d*g),i=a+c*Math.cos(-f*g),j=b+c*Math.sin(-d*g),k=b+c*Math.sin(-f*g),l=[["M",h,j],["A",c,c,0,+(f-d>180),0,i,k]];else l=[["M",a,b],["m",0,-d],["a",c,d,0,1,1,0,2*d],["a",c,d,0,1,1,0,-2*d],["z"]];return l.toString=e,l}function y(b){var d=c(b),g=String.prototype.toLowerCase;if(d.rel)return f(d.rel);a.is(b,"array")&&a.is(b&&b[0],"array")||(b=a.parsePathString(b));var h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=b[0][1],j=b[0][2],k=i,l=j,m++,h.push(["M",i,j]));for(var n=m,o=b.length;o>n;n++){var p=h[n]=[],q=b[n];if(q[0]!=g.call(q[0]))switch(p[0]=g.call(q[0]),p[0]){case"a":p[1]=q[1],p[2]=q[2],p[3]=q[3],p[4]=q[4],p[5]=q[5],p[6]=+(q[6]-i).toFixed(3),p[7]=+(q[7]-j).toFixed(3);break;case"v":p[1]=+(q[1]-j).toFixed(3);break;case"m":k=q[1],l=q[2];default:for(var r=1,s=q.length;s>r;r++)p[r]=+(q[r]-(r%2?i:j)).toFixed(3)}else{p=h[n]=[],"m"==q[0]&&(k=q[1]+i,l=q[2]+j);for(var t=0,u=q.length;u>t;t++)h[n][t]=q[t]}var v=h[n].length;switch(h[n][0]){case"z":i=k,j=l;break;case"h":i+=+h[n][v-1];break;case"v":j+=+h[n][v-1];break;default:i+=+h[n][v-2],j+=+h[n][v-1]}}return h.toString=e,d.rel=f(h),h}function z(b){var d=c(b);if(d.abs)return f(d.abs);if(I(b,"array")&&I(b&&b[0],"array")||(b=a.parsePathString(b)),!b||!b.length)return[["M",0,0]];var g,h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=+b[0][1],j=+b[0][2],k=i,l=j,m++,h[0]=["M",i,j]);for(var n,o,p=3==b.length&&"M"==b[0][0]&&"R"==b[1][0].toUpperCase()&&"Z"==b[2][0].toUpperCase(),q=m,r=b.length;r>q;q++){if(h.push(n=[]),o=b[q],g=o[0],g!=g.toUpperCase())switch(n[0]=g.toUpperCase(),n[0]){case"A":n[1]=o[1],n[2]=o[2],n[3]=o[3],n[4]=o[4],n[5]=o[5],n[6]=+o[6]+i,n[7]=+o[7]+j;break;case"V":n[1]=+o[1]+j;break;case"H":n[1]=+o[1]+i;break;case"R":for(var s=[i,j].concat(o.slice(1)),t=2,u=s.length;u>t;t++)s[t]=+s[t]+i,s[++t]=+s[t]+j;h.pop(),h=h.concat(G(s,p));break;case"O":h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);break;case"U":h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));break;case"M":k=+o[1]+i,l=+o[2]+j;default:for(t=1,u=o.length;u>t;t++)n[t]=+o[t]+(t%2?i:j)}else if("R"==g)s=[i,j].concat(o.slice(1)),h.pop(),h=h.concat(G(s,p)),n=["R"].concat(o.slice(-2));else if("O"==g)h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);else if("U"==g)h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));else for(var v=0,w=o.length;w>v;v++)n[v]=o[v];if(g=g.toUpperCase(),"O"!=g)switch(n[0]){case"Z":i=+k,j=+l;break;case"H":i=n[1];break;case"V":j=n[1];break;case"M":k=n[n.length-2],l=n[n.length-1];default:i=n[n.length-2],j=n[n.length-1]}}return h.toString=e,d.abs=f(h),h}function A(a,b,c,d){return[a,b,c,d,c,d]}function B(a,b,c,d,e,f){var g=1/3,h=2/3;return[g*a+h*c,g*b+h*d,g*e+h*c,g*f+h*d,e,f]}function C(b,c,d,e,f,g,h,i,j,k){var l,m=120*O/180,n=O/180*(+f||0),o=[],p=a._.cacher(function(a,b,c){var d=a*N.cos(c)-b*N.sin(c),e=a*N.sin(c)+b*N.cos(c);return{x:d,y:e}});if(k)y=k[0],z=k[1],w=k[2],x=k[3];else{l=p(b,c,-n),b=l.x,c=l.y,l=p(i,j,-n),i=l.x,j=l.y;var q=(N.cos(O/180*f),N.sin(O/180*f),(b-i)/2),r=(c-j)/2,s=q*q/(d*d)+r*r/(e*e);s>1&&(s=N.sqrt(s),d=s*d,e=s*e);var t=d*d,u=e*e,v=(g==h?-1:1)*N.sqrt(S((t*u-t*r*r-u*q*q)/(t*r*r+u*q*q))),w=v*d*r/e+(b+i)/2,x=v*-e*q/d+(c+j)/2,y=N.asin(((c-x)/e).toFixed(9)),z=N.asin(((j-x)/e).toFixed(9));y=w>b?O-y:y,z=w>i?O-z:z,0>y&&(y=2*O+y),0>z&&(z=2*O+z),h&&y>z&&(y-=2*O),!h&&z>y&&(z-=2*O)}var A=z-y;if(S(A)>m){var B=z,D=i,E=j;z=y+m*(h&&z>y?1:-1),i=w+d*N.cos(z),j=x+e*N.sin(z),o=C(i,j,d,e,f,0,h,D,E,[z,B,w,x])}A=z-y;var F=N.cos(y),G=N.sin(y),H=N.cos(z),I=N.sin(z),J=N.tan(A/4),K=4/3*d*J,L=4/3*e*J,M=[b,c],P=[b+K*G,c-L*F],Q=[i+K*I,j-L*H],R=[i,j];if(P[0]=2*M[0]-P[0],P[1]=2*M[1]-P[1],k)return[P,Q,R].concat(o);o=[P,Q,R].concat(o).join().split(",");for(var T=[],U=0,V=o.length;V>U;U++)T[U]=U%2?p(o[U-1],o[U],n).y:p(o[U],o[U+1],n).x;return T}function D(a,b,c,d,e,f,g,h){for(var i,j,k,l,m,n,o,p,q=[],r=[[],[]],s=0;2>s;++s)if(0==s?(j=6*a-12*c+6*e,i=-3*a+9*c-9*e+3*g,k=3*c-3*a):(j=6*b-12*d+6*f,i=-3*b+9*d-9*f+3*h,k=3*d-3*b),S(i)<1e-12){if(S(j)<1e-12)continue;l=-k/j,l>0&&1>l&&q.push(l)}else o=j*j-4*k*i,p=N.sqrt(o),0>o||(m=(-j+p)/(2*i),m>0&&1>m&&q.push(m),n=(-j-p)/(2*i),n>0&&1>n&&q.push(n));for(var t,u=q.length,v=u;u--;)l=q[u],t=1-l,r[0][u]=t*t*t*a+3*t*t*l*c+3*t*l*l*e+l*l*l*g,r[1][u]=t*t*t*b+3*t*t*l*d+3*t*l*l*f+l*l*l*h;return r[0][v]=a,r[1][v]=b,r[0][v+1]=g,r[1][v+1]=h,r[0].length=r[1].length=v+2,{min:{x:P.apply(0,r[0]),y:P.apply(0,r[1])},max:{x:Q.apply(0,r[0]),y:Q.apply(0,r[1])}}}function E(a,b){var d=!b&&c(a);if(!b&&d.curve)return f(d.curve);for(var e=z(a),g=b&&z(b),h={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},i={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},j=(function(a,b,c){var d,e;if(!a)return["C",b.x,b.y,b.x,b.y,b.x,b.y];switch(!(a[0]in{T:1,Q:1})&&(b.qx=b.qy=null),a[0]){case"M":b.X=a[1],b.Y=a[2];break;case"A":a=["C"].concat(C.apply(0,[b.x,b.y].concat(a.slice(1))));break;case"S":"C"==c||"S"==c?(d=2*b.x-b.bx,e=2*b.y-b.by):(d=b.x,e=b.y),a=["C",d,e].concat(a.slice(1));break;case"T":"Q"==c||"T"==c?(b.qx=2*b.x-b.qx,b.qy=2*b.y-b.qy):(b.qx=b.x,b.qy=b.y),a=["C"].concat(B(b.x,b.y,b.qx,b.qy,a[1],a[2]));break;case"Q":b.qx=a[1],b.qy=a[2],a=["C"].concat(B(b.x,b.y,a[1],a[2],a[3],a[4]));break;case"L":a=["C"].concat(A(b.x,b.y,a[1],a[2]));break;case"H":a=["C"].concat(A(b.x,b.y,a[1],b.y));break;case"V":a=["C"].concat(A(b.x,b.y,b.x,a[1]));break;case"Z":a=["C"].concat(A(b.x,b.y,b.X,b.Y))}return a}),k=function(a,b){if(a[b].length>7){a[b].shift();for(var c=a[b];c.length;)m[b]="A",g&&(n[b]="A"),a.splice(b++,0,["C"].concat(c.splice(0,6)));a.splice(b,1),r=Q(e.length,g&&g.length||0)}},l=function(a,b,c,d,f){a&&b&&"M"==a[f][0]&&"M"!=b[f][0]&&(b.splice(f,0,["M",d.x,d.y]),c.bx=0,c.by=0,c.x=a[f][1],c.y=a[f][2],r=Q(e.length,g&&g.length||0))},m=[],n=[],o="",p="",q=0,r=Q(e.length,g&&g.length||0);r>q;q++){e[q]&&(o=e[q][0]),"C"!=o&&(m[q]=o,q&&(p=m[q-1])),e[q]=j(e[q],h,p),"A"!=m[q]&&"C"==o&&(m[q]="C"),k(e,q),g&&(g[q]&&(o=g[q][0]),"C"!=o&&(n[q]=o,q&&(p=n[q-1])),g[q]=j(g[q],i,p),"A"!=n[q]&&"C"==o&&(n[q]="C"),k(g,q)),l(e,g,h,i,q),l(g,e,i,h,q);var s=e[q],t=g&&g[q],u=s.length,v=g&&t.length;h.x=s[u-2],h.y=s[u-1],h.bx=M(s[u-4])||h.x,h.by=M(s[u-3])||h.y,i.bx=g&&(M(t[v-4])||i.x),i.by=g&&(M(t[v-3])||i.y),i.x=g&&t[v-2],i.y=g&&t[v-1]}return g||(d.curve=f(e)),g?[e,g]:e}function F(a,b){if(!b)return a;var c,d,e,f,g,h,i;for(a=E(a),e=0,g=a.length;g>e;e++)for(i=a[e],f=1,h=i.length;h>f;f+=2)c=b.x(i[f],i[f+1]),d=b.y(i[f],i[f+1]),i[f]=c,i[f+1]=d;return a}function G(a,b){for(var c=[],d=0,e=a.length;e-2*!b>d;d+=2){var f=[{x:+a[d-2],y:+a[d-1]},{x:+a[d],y:+a[d+1]},{x:+a[d+2],y:+a[d+3]},{x:+a[d+4],y:+a[d+5]}];b?d?e-4==d?f[3]={x:+a[0],y:+a[1]}:e-2==d&&(f[2]={x:+a[0],y:+a[1]},f[3]={x:+a[2],y:+a[3]}):f[0]={x:+a[e-2],y:+a[e-1]}:e-4==d?f[3]=f[2]:d||(f[0]={x:+a[d],y:+a[d+1]}),c.push(["C",(-f[0].x+6*f[1].x+f[2].x)/6,(-f[0].y+6*f[1].y+f[2].y)/6,(f[1].x+6*f[2].x-f[3].x)/6,(f[1].y+6*f[2].y-f[3].y)/6,f[2].x,f[2].y])}return c}var H=b.prototype,I=a.is,J=a._.clone,K="hasOwnProperty",L=/,?([a-z]),?/gi,M=parseFloat,N=Math,O=N.PI,P=N.min,Q=N.max,R=N.pow,S=N.abs,T=h(1),U=h(),V=h(0,1),W=a._unit2px,X={path:function(a){return a.attr("path")},circle:function(a){var b=W(a);return x(b.cx,b.cy,b.r)},ellipse:function(a){var b=W(a);return x(b.cx||0,b.cy||0,b.rx,b.ry)},rect:function(a){var b=W(a);return w(b.x||0,b.y||0,b.width,b.height,b.rx,b.ry)},image:function(a){var b=W(a);return w(b.x||0,b.y||0,b.width,b.height)},line:function(a){return"M"+[a.attr("x1")||0,a.attr("y1")||0,a.attr("x2"),a.attr("y2")]},polyline:function(a){return"M"+a.attr("points")},polygon:function(a){return"M"+a.attr("points")+"z"},deflt:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)}};a.path=c,a.path.getTotalLength=T,a.path.getPointAtLength=U,a.path.getSubpath=function(a,b,c){if(this.getTotalLength(a)-c<1e-6)return V(a,b).end;var d=V(a,c,1);return b?V(d,b).end:d},H.getTotalLength=function(){return this.node.getTotalLength?this.node.getTotalLength():void 0},H.getPointAtLength=function(a){return U(this.attr("d"),a)},H.getSubpath=function(b,c){return a.path.getSubpath(this.attr("d"),b,c)},a._.box=d,a.path.findDotsAtSegment=i,a.path.bezierBBox=j,a.path.isPointInsideBBox=k,a.closest=function(b,c,e,f){for(var g=100,h=d(b-g/2,c-g/2,g,g),i=[],j=e[0].hasOwnProperty("x")?function(a){return{x:e[a].x,y:e[a].y}}:function(a){return{x:e[a],y:f[a]}},l=0;1e6>=g&&!l;){for(var m=0,n=e.length;n>m;m++){var o=j(m);if(k(h,o.x,o.y)){l++,i.push(o);break}}l||(g*=2,h=d(b-g/2,c-g/2,g,g))}if(1e6!=g){var p,q=1/0;for(m=0,n=i.length;n>m;m++){var r=a.len(b,c,i[m].x,i[m].y);q>r&&(q=r,i[m].len=r,p=i[m])}return p}},a.path.isBBoxIntersect=l,a.path.intersection=r,a.path.intersectionNumber=s,a.path.isPointInside=u,a.path.getBBox=v,a.path.get=X,a.path.toRelative=y,a.path.toAbsolute=z,a.path.toCubic=E,a.path.map=F,a.path.toString=e,a.path.clone=f}),d.plugin(function(a){var d=Math.max,e=Math.min,f=function(a){if(this.items=[],this.bindings={},this.length=0,this.type="set",a)for(var b=0,c=a.length;c>b;b++)a[b]&&(this[this.items.length]=this.items[this.items.length]=a[b],this.length++)},g=f.prototype;g.push=function(){for(var a,b,c=0,d=arguments.length;d>c;c++)a=arguments[c],a&&(b=this.items.length,this[b]=this.items[b]=a,this.length++);return this},g.pop=function(){return this.length&&delete this[this.length--],this.items.pop()},g.forEach=function(a,b){for(var c=0,d=this.items.length;d>c;c++)if(a.call(b,this.items[c],c)===!1)return this;return this},g.animate=function(d,e,f,g){"function"!=typeof f||f.length||(g=f,f=c.linear),d instanceof a._.Animation&&(g=d.callback,f=d.easing,e=f.dur,d=d.attr);var h=arguments;if(a.is(d,"array")&&a.is(h[h.length-1],"array"))var i=!0;var j,k=function(){j?this.b=j:j=this.b},l=0,m=this,n=g&&function(){++l==m.length&&g.call(this)
		};return this.forEach(function(a,c){b.once("snap.animcreated."+a.id,k),i?h[c]&&a.animate.apply(a,h[c]):a.animate(d,e,f,n)})},g.remove=function(){for(;this.length;)this.pop().remove();return this},g.bind=function(a,b,c){var d={};if("function"==typeof b)this.bindings[a]=b;else{var e=c||a;this.bindings[a]=function(a){d[e]=a,b.attr(d)}}return this},g.attr=function(a){var b={};for(var c in a)this.bindings[c]?this.bindings[c](a[c]):b[c]=a[c];for(var d=0,e=this.items.length;e>d;d++)this.items[d].attr(b);return this},g.clear=function(){for(;this.length;)this.pop()},g.splice=function(a,b){a=0>a?d(this.length+a,0):a,b=d(0,e(this.length-a,b));var c,g=[],h=[],i=[];for(c=2;c<arguments.length;c++)i.push(arguments[c]);for(c=0;b>c;c++)h.push(this[a+c]);for(;c<this.length-a;c++)g.push(this[a+c]);var j=i.length;for(c=0;c<j+g.length;c++)this.items[a+c]=this[a+c]=j>c?i[c]:g[c-j];for(c=this.items.length=this.length-=b-j;this[c];)delete this[c++];return new f(h)},g.exclude=function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]==a)return this.splice(b,1),!0;return!1},g.insertAfter=function(a){for(var b=this.items.length;b--;)this.items[b].insertAfter(a);return this},g.getBBox=function(){for(var a=[],b=[],c=[],f=[],g=this.items.length;g--;)if(!this.items[g].removed){var h=this.items[g].getBBox();a.push(h.x),b.push(h.y),c.push(h.x+h.width),f.push(h.y+h.height)}return a=e.apply(0,a),b=e.apply(0,b),c=d.apply(0,c),f=d.apply(0,f),{x:a,y:b,x2:c,y2:f,width:c-a,height:f-b,cx:a+(c-a)/2,cy:b+(f-b)/2}},g.clone=function(a){a=new f;for(var b=0,c=this.items.length;c>b;b++)a.push(this.items[b].clone());return a},g.toString=function(){return"Snap‘s set"},g.type="set",a.Set=f,a.set=function(){var a=new f;return arguments.length&&a.push.apply(a,Array.prototype.slice.call(arguments,0)),a}}),d.plugin(function(a,c){function d(a){var b=a[0];switch(b.toLowerCase()){case"t":return[b,0,0];case"m":return[b,1,0,0,1,0,0];case"r":return 4==a.length?[b,0,a[2],a[3]]:[b,0];case"s":return 5==a.length?[b,1,1,a[3],a[4]]:3==a.length?[b,1,1]:[b,1]}}function e(b,c,e){c=p(c).replace(/\.{3}|\u2026/g,b),b=a.parseTransformString(b)||[],c=a.parseTransformString(c)||[];for(var f,g,h,i,l=Math.max(b.length,c.length),m=[],n=[],o=0;l>o;o++){if(h=b[o]||d(c[o]),i=c[o]||d(h),h[0]!=i[0]||"r"==h[0].toLowerCase()&&(h[2]!=i[2]||h[3]!=i[3])||"s"==h[0].toLowerCase()&&(h[3]!=i[3]||h[4]!=i[4])){b=a._.transform2matrix(b,e()),c=a._.transform2matrix(c,e()),m=[["m",b.a,b.b,b.c,b.d,b.e,b.f]],n=[["m",c.a,c.b,c.c,c.d,c.e,c.f]];break}for(m[o]=[],n[o]=[],f=0,g=Math.max(h.length,i.length);g>f;f++)f in h&&(m[o][f]=h[f]),f in i&&(n[o][f]=i[f])}return{from:k(m),to:k(n),f:j(m)}}function f(a){return a}function g(a){return function(b){return+b.toFixed(3)+a}}function h(a){return a.join(" ")}function i(b){return a.rgb(b[0],b[1],b[2])}function j(a){var b,c,d,e,f,g,h=0,i=[];for(b=0,c=a.length;c>b;b++){for(f="[",g=['"'+a[b][0]+'"'],d=1,e=a[b].length;e>d;d++)g[d]="val["+h++ +"]";f+=g+"]",i[b]=f}return Function("val","return Snap.path.toString.call(["+i+"])")}function k(a){for(var b=[],c=0,d=a.length;d>c;c++)for(var e=1,f=a[c].length;f>e;e++)b.push(a[c][e]);return b}function l(a){return isFinite(parseFloat(a))}function m(b,c){return a.is(b,"array")&&a.is(c,"array")?b.toString()==c.toString():!1}var n={},o=/[a-z]+$/i,p=String;n.stroke=n.fill="colour",c.prototype.equal=function(a,c){return b("snap.util.equal",this,a,c).firstDefined()},b.on("snap.util.equal",function(b,c){var d,q,r=p(this.attr(b)||""),s=this;if(l(r)&&l(c))return{from:parseFloat(r),to:parseFloat(c),f:f};if("colour"==n[b])return d=a.color(r),q=a.color(c),{from:[d.r,d.g,d.b,d.opacity],to:[q.r,q.g,q.b,q.opacity],f:i};if("viewBox"==b)return d=this.attr(b).vb.split(" ").map(Number),q=c.split(" ").map(Number),{from:d,to:q,f:h};if("transform"==b||"gradientTransform"==b||"patternTransform"==b)return c instanceof a.Matrix&&(c=c.toTransformString()),a._.rgTransform.test(c)||(c=a._.svgTransform2string(c)),e(r,c,function(){return s.getBBox(1)});if("d"==b||"path"==b)return d=a.path.toCubic(r,c),{from:k(d[0]),to:k(d[1]),f:j(d[0])};if("points"==b)return d=p(r).split(a._.separator),q=p(c).split(a._.separator),{from:d,to:q,f:function(a){return a}};var t=r.match(o),u=p(c).match(o);return t&&m(t,u)?{from:parseFloat(r),to:parseFloat(c),f:g(t)}:{from:this.asPX(b),to:this.asPX(b,c),f:f}})}),d.plugin(function(a,c,d,e){for(var f=c.prototype,g="hasOwnProperty",h=("createTouch"in e.doc),i=["click","dblclick","mousedown","mousemove","mouseout","mouseover","mouseup","touchstart","touchmove","touchend","touchcancel"],j={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},k=(function(a,b){var c="y"==a?"scrollTop":"scrollLeft",d=b&&b.node?b.node.ownerDocument:e.doc;return d[c in d.documentElement?"documentElement":"body"][c]}),l=function(){return this.originalEvent.preventDefault()},m=function(){return this.originalEvent.stopPropagation()},n=function(a,b,c,d){var e=h&&j[b]?j[b]:b,f=function(e){var f=k("y",d),i=k("x",d);if(h&&j[g](b))for(var n=0,o=e.targetTouches&&e.targetTouches.length;o>n;n++)if(e.targetTouches[n].target==a||a.contains(e.targetTouches[n].target)){var p=e;e=e.targetTouches[n],e.originalEvent=p,e.preventDefault=l,e.stopPropagation=m;break}var q=e.clientX+i,r=e.clientY+f;return c.call(d,e,q,r)};return b!==e&&a.addEventListener(b,f,!1),a.addEventListener(e,f,!1),function(){return b!==e&&a.removeEventListener(b,f,!1),a.removeEventListener(e,f,!1),!0}},o=[],p=function(a){for(var c,d=a.clientX,e=a.clientY,f=k("y"),g=k("x"),i=o.length;i--;){if(c=o[i],h){for(var j,l=a.touches&&a.touches.length;l--;)if(j=a.touches[l],j.identifier==c.el._drag.id||c.el.node.contains(j.target)){d=j.clientX,e=j.clientY,(a.originalEvent?a.originalEvent:a).preventDefault();break}}else a.preventDefault();{var m=c.el.node;m.nextSibling,m.parentNode,m.style.display}d+=g,e+=f,b("snap.drag.move."+c.el.id,c.move_scope||c.el,d-c.el._drag.x,e-c.el._drag.y,d,e,a)}},q=function(c){a.unmousemove(p).unmouseup(q);for(var d,e=o.length;e--;)d=o[e],d.el._drag={},b("snap.drag.end."+d.el.id,d.end_scope||d.start_scope||d.move_scope||d.el,c),b.off("snap.drag.*."+d.el.id);o=[]},r=i.length;r--;)!function(b){a[b]=f[b]=function(c,d){if(a.is(c,"function"))this.events=this.events||[],this.events.push({name:b,f:c,unbind:n(this.node||document,b,c,d||this)});else for(var e=0,f=this.events.length;f>e;e++)if(this.events[e].name==b)try{this.events[e].f.call(this)}catch(g){}return this},a["un"+b]=f["un"+b]=function(a){for(var c=this.events||[],d=c.length;d--;)if(c[d].name==b&&(c[d].f==a||!a))return c[d].unbind(),c.splice(d,1),!c.length&&delete this.events,this;return this}}(i[r]);f.hover=function(a,b,c,d){return this.mouseover(a,c).mouseout(b,d||c)},f.unhover=function(a,b){return this.unmouseover(a).unmouseout(b)};var s=[];f.drag=function(c,d,e,f,g,h){function i(i,j,l){(i.originalEvent||i).preventDefault(),k._drag.x=j,k._drag.y=l,k._drag.id=i.identifier,!o.length&&a.mousemove(p).mouseup(q),o.push({el:k,move_scope:f,start_scope:g,end_scope:h}),d&&b.on("snap.drag.start."+k.id,d),c&&b.on("snap.drag.move."+k.id,c),e&&b.on("snap.drag.end."+k.id,e),b("snap.drag.start."+k.id,g||f||k,j,l,i)}function j(a,c,d){b("snap.draginit."+k.id,k,a,c,d)}var k=this;if(!arguments.length){var l;return k.drag(function(a,b){this.attr({transform:l+(l?"T":"t")+[a,b]})},function(){l=this.transform().local})}return b.on("snap.draginit."+k.id,i),k._drag={},s.push({el:k,start:i,init:j}),k.mousedown(j),k},f.undrag=function(){for(var c=s.length;c--;)s[c].el==this&&(this.unmousedown(s[c].init),s.splice(c,1),b.unbind("snap.drag.*."+this.id),b.unbind("snap.draginit."+this.id));return!s.length&&a.unmousemove(p).unmouseup(q),this}}),d.plugin(function(a,c,d){var e=(c.prototype,d.prototype),f=/^\s*url\((.+)\)/,g=String,h=a._.$;a.filter={},e.filter=function(b){var d=this;"svg"!=d.type&&(d=d.paper);var e=a.parse(g(b)),f=a._.id(),i=(d.node.offsetWidth,d.node.offsetHeight,h("filter"));return h(i,{id:f,filterUnits:"userSpaceOnUse"}),i.appendChild(e.node),d.defs.appendChild(i),new c(i)},b.on("snap.util.getattr.filter",function(){b.stop();var c=h(this.node,"filter");if(c){var d=g(c).match(f);return d&&a.select(d[1])}}),b.on("snap.util.attr.filter",function(d){if(d instanceof c&&"filter"==d.type){b.stop();var e=d.node.id;e||(h(d.node,{id:d.id}),e=d.id),h(this.node,{filter:a.url(e)})}d&&"none"!=d||(b.stop(),this.node.removeAttribute("filter"))}),a.filter.blur=function(b,c){null==b&&(b=2);var d=null==c?b:[b,c];return a.format('<feGaussianBlur stdDeviation="{def}"/>',{def:d})},a.filter.blur.toString=function(){return this()},a.filter.shadow=function(b,c,d,e,f){return"string"==typeof d&&(e=d,f=e,d=4),"string"!=typeof e&&(f=e,e="#000"),e=e||"#000",null==d&&(d=4),null==f&&(f=1),null==b&&(b=0,c=2),null==c&&(c=b),e=a.color(e),a.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>',{color:e,dx:b,dy:c,blur:d,opacity:f})},a.filter.shadow.toString=function(){return this()},a.filter.grayscale=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>',{a:.2126+.7874*(1-b),b:.7152-.7152*(1-b),c:.0722-.0722*(1-b),d:.2126-.2126*(1-b),e:.7152+.2848*(1-b),f:.0722-.0722*(1-b),g:.2126-.2126*(1-b),h:.0722+.9278*(1-b)})},a.filter.grayscale.toString=function(){return this()},a.filter.sepia=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>',{a:.393+.607*(1-b),b:.769-.769*(1-b),c:.189-.189*(1-b),d:.349-.349*(1-b),e:.686+.314*(1-b),f:.168-.168*(1-b),g:.272-.272*(1-b),h:.534-.534*(1-b),i:.131+.869*(1-b)})},a.filter.sepia.toString=function(){return this()},a.filter.saturate=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="saturate" values="{amount}"/>',{amount:1-b})},a.filter.saturate.toString=function(){return this()},a.filter.hueRotate=function(b){return b=b||0,a.format('<feColorMatrix type="hueRotate" values="{angle}"/>',{angle:b})},a.filter.hueRotate.toString=function(){return this()},a.filter.invert=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>',{amount:b,amount2:1-b})},a.filter.invert.toString=function(){return this()},a.filter.brightness=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>',{amount:b})},a.filter.brightness.toString=function(){return this()},a.filter.contrast=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>',{amount:b,amount2:.5-b/2})},a.filter.contrast.toString=function(){return this()}}),d.plugin(function(a,b){var c=a._.box,d=a.is,e=/^[^a-z]*([tbmlrc])/i,f=function(){return"T"+this.dx+","+this.dy};b.prototype.getAlign=function(a,b){null==b&&d(a,"string")&&(b=a,a=null),a=a||this.paper;var g=a.getBBox?a.getBBox():c(a),h=this.getBBox(),i={};switch(b=b&&b.match(e),b=b?b[1].toLowerCase():"c"){case"t":i.dx=0,i.dy=g.y-h.y;break;case"b":i.dx=0,i.dy=g.y2-h.y2;break;case"m":i.dx=0,i.dy=g.cy-h.cy;break;case"l":i.dx=g.x-h.x,i.dy=0;break;case"r":i.dx=g.x2-h.x2,i.dy=0;break;default:i.dx=g.cx-h.cx,i.dy=0}return i.toString=f,i},b.prototype.align=function(a,b){return this.transform("..."+this.getAlign(a,b))}}),d});
		
		}.call(window));
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * svgLoader.js v1.0.0
		 * http://www.codrops.com
		 *
		 * Licensed under the MIT license.
		 * http://www.opensource.org/licenses/mit-license.php
		 * 
		 * Copyright 2014, Codrops
		 * http://www.codrops.com
		 */
		;( function( window ) {
			
			'use strict';
		
			var Q = __webpack_require__(2);
		
			function extend( a, b ) {
				for( var key in b ) { 
					if( b.hasOwnProperty( key ) ) {
						a[key] = b[key];
					}
				}
				return a;
			}
		
			function SVGLoader( el, options ) {
				this.el = el;
				this.options = extend( {}, this.options );
				extend( this.options, options );
				this._init();
			}
		
			SVGLoader.prototype.options = {
				speedIn : 500,
				easingIn : mina.linear
			};
		
			SVGLoader.prototype._init = function() {
				var s = Snap( this.el.querySelector( 'svg' ) );
				this.path = s.select( 'path' );
				this.initialPath = this.path.attr('d');
				
				var openingStepsStr = this.el.getAttribute( 'data-opening' );
				this.openingSteps = openingStepsStr ? openingStepsStr.split(';') : '';
				this.openingStepsTotal = openingStepsStr ? this.openingSteps.length : 0;
				if( this.openingStepsTotal === 0 ) return;
		
				// if data-closing is not defined then the path will animate to its original shape
				var closingStepsStr = this.el.getAttribute( 'data-closing' ) ? this.el.getAttribute( 'data-closing' ) : this.initialPath;
				this.closingSteps = closingStepsStr ? closingStepsStr.split(';') : '';
				this.closingStepsTotal = closingStepsStr ? this.closingSteps.length : 0;
				
				this.isAnimating = false;
		
				if( !this.options.speedOut ) {
					this.options.speedOut = this.options.speedIn;
				}
				if( !this.options.easingOut ) {
					this.options.easingOut = this.options.easingIn;
				}
			};
		
			SVGLoader.prototype.show = function() {
				if( this.isAnimating ) return false;
				this.isAnimating = true;
				// animate svg
				var dfd = Q.defer();
		
				var self = this,
					onEndAnimation = function() {
						dfd.resolve();
					};
				this._animateSVG( 'in', onEndAnimation );
				this.el.classList.add('show');
				return dfd.promise;
			};
		
			SVGLoader.prototype.hide = function(immediate) {
				var dfd = Q.defer(),
					onEndAnimation = function() {
						// reset path
						this.path.attr( 'd', this.initialPath );
						this.el.classList.remove('show');
						this.isAnimating = false;
						dfd.resolve();
					}.bind(this);
		
		
				if (immediate)
					onEndAnimation();
				else
					this._animateSVG( 'out', onEndAnimation);
		
				return dfd.promise;
			};
		
			SVGLoader.prototype._animateSVG = function( dir, callback ) {
				var self = this,
					pos = 0,
					steps = dir === 'out' ? this.closingSteps : this.openingSteps,
					stepsTotal = dir === 'out' ? this.closingStepsTotal : this.openingStepsTotal,
					speed = dir === 'out' ? self.options.speedOut : self.options.speedIn,
					easing = dir === 'out' ? self.options.easingOut : self.options.easingIn,
					nextStep = function( pos ) {
						if( pos > stepsTotal - 1 ) {
							if( callback && typeof callback == 'function' ) {
								callback();
							}
							return;
						}
						self.path.animate( { 'path' : steps[pos] }, speed, easing, function() { nextStep(pos); } );
						pos++;
					};
		
				nextStep(pos);
			};
		
			// add to global namespace
			window.SVGLoader = SVGLoader;
		
		})( window );
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		var map = {
			"./circle.html": 14,
			"./curtain.html": 15,
			"./frame-it.html": 16,
			"./jammed-blind.html": 17,
			"./lateral-swipe.html": 18,
			"./lazy-stretch.html": 19,
			"./origami.html": 20,
			"./parallelogram.html": 21,
			"./spill.html": 22,
			"./tilted.html": 23,
			"./tunnel-vision.html": 24,
			"./wave.html": 25,
			"./widescreen-wiper.html": 26
		};
		function webpackContext(req) {
			return __webpack_require__(webpackContextResolve(req));
		};
		function webpackContextResolve(req) {
			return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
		};
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = 13;
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 40 -21.875 C 11.356078 -21.875 -11.875 1.3560784 -11.875 30 C -11.875 58.643922 11.356078 81.875 40 81.875 C 68.643922 81.875 91.875 58.643922 91.875 30 C 91.875 1.3560784 68.643922 -21.875 40 -21.875 Z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"xMidYMid slice\">\r\n        <path d=\"M40,30 c 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 Z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 15 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"m 40,-80 190,0 -305,290 C -100,140 0,0 40,-80 z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\" >\r\n        <path d=\"m 75,-80 155,0 0,225 C 90,85 100,30 75,-80 z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 16 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 0,0 0,60 80,60 80,0 Z M 40,30 40,30 40,30 40,30 Z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M 0,0 0,60 80,60 80,0 Z M 80,0 80,60 0,60 0,0 Z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 17 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 0,60 80,60 80,50 0,40 0,60;M 0,60 80,60 80,25 0,40 0,60;M 0,60 80,60 80,25 0,10 0,60;M 0,60 80,60 80,0 0,0 0,60\" data-closing=\"M 0,60 80,60 80,20 0,0 0,60;M 0,60 80,60 80,20 0,40 0,60;m 0,60 80,0 0,0 -80,0\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"m 0,60 80,0 0,0 -80,0\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 18 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 40,-65 145,80 -65,80 40,-65\" data-closing=\"m 40,-65 0,0 L -65,80 40,-65\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M 40,-65 145,80 40,-65\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 19 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M20,15 50,30 50,30 30,30 Z;M0,0 80,0 50,30 20,45 Z;M0,0 80,0 60,45 0,60 Z;M0,0 80,0 80,60 0,60 Z\" data-closing=\"M0,0 80,0 60,45 0,60 Z;M0,0 80,0 50,30 20,45 Z;M20,15 50,30 50,30 30,30 Z;M30,30 50,30 50,30 30,30 Z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M30,30 50,30 50,30 30,30 Z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 20 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"m -10,-10 0,80 100,0 0,-80 z m 50,-30.5 0,70.5 0,70 0,-70 z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\" >\r\n        <path d=\"m -10,-10 0,80 100,0 0,-80 z M 40,-40.5 120,30 40,100 -40,30 z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 21 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 0,0 0,60 80,60 80,0 z M 80,0 40,30 0,60 40,30 z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M 0,0 0,60 80,60 80,0 Z M 80,0 80,60 0,60 0,0 Z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 22 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 0,0 c 0,0 63.5,-16.5 80,0 16.5,16.5 0,60 0,60 L 0,60 Z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M 0,0 c 0,0 -16.5,43.5 0,60 16.5,16.5 80,0 80,0 L 0,60 Z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 23 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 0,0 80,-10 80,60 0,70 0,0\" data-closing=\"M 0,-10 80,-20 80,-10 0,0 0,-10\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M 0,70 80,60 80,80 0,80 0,70\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 24 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M -18 -26.90625 L -18 86.90625 L 98 86.90625 L 98 -26.90625 L -18 -26.90625 Z M 40 29.96875 C 40.01804 29.96875 40.03125 29.98196 40.03125 30 C 40.03125 30.01804 40.01804 30.03125 40 30.03125 C 39.98196 30.03125 39.96875 30.01804 39.96875 30 C 39.96875 29.98196 39.98196 29.96875 40 29.96875 Z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"xMidYMid slice\">\r\n        <path d=\"M -18 -26.90625 L -18 86.90625 L 98 86.90625 L 98 -26.90625 L -18 -26.90625 Z M 40 -25.6875 C 70.750092 -25.6875 95.6875 -0.7500919 95.6875 30 C 95.6875 60.750092 70.750092 85.6875 40 85.6875 C 9.2499078 85.6875 -15.6875 60.750092 -15.6875 30 C -15.6875 -0.7500919 9.2499078 -25.6875 40 -25.6875 Z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 25 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"m -5,-5 0,70 90,0 0,-70 z m 5,35 c 0,0 15,20 40,0 25,-20 40,0 40,0 l 0,0 C 80,30 65,10 40,30 15,50 0,30 0,30 z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\" >\r\n        <path d=\"m -5,-5 0,70 90,0 0,-70 z m 5,5 c 0,0 7.9843788,0 40,0 35,0 40,0 40,0 l 0,60 c 0,0 -3.944487,0 -40,0 -30,0 -40,0 -40,0 z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 26 */
	/***/ function(module, exports) {
	
		module.exports = "<div class=\"<%= class_name %>\" data-opening=\"M 40,100 150,0 -65,0 z\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80 60\" preserveAspectRatio=\"none\">\r\n        <path d=\"M 40,100 150,0 l 0,0 z\"/>\r\n    </svg>\r\n</div>";
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'curtain', { speedIn : 700, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'frame-it', { speedIn : 300, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'jammed-blind', { speedIn : 200, easingIn : mina.linear });
		};
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'lateral-swipe', { speedIn : 500, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'lazy-stretch', { speedIn : 100 });
		};
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'origami', { speedIn : 400, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'parallelogram', { speedIn : 300, speedOut : 600, easingIn : mina.easeinout, easingOut : mina.bounce });
		};
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Snap.svg 0.4.1
		//
		// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		// http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		//
		// build: 2015-04-13
		
		!function(a){var b,c,d="0.4.2",e="hasOwnProperty",f=/[\.\/]/,g=/\s*,\s*/,h="*",i=function(a,b){return a-b},j={n:{}},k=function(){for(var a=0,b=this.length;b>a;a++)if("undefined"!=typeof this[a])return this[a]},l=function(){for(var a=this.length;--a;)if("undefined"!=typeof this[a])return this[a]},m=function(a,d){a=String(a);var e,f=c,g=Array.prototype.slice.call(arguments,2),h=m.listeners(a),j=0,n=[],o={},p=[],q=b;p.firstDefined=k,p.lastDefined=l,b=a,c=0;for(var r=0,s=h.length;s>r;r++)"zIndex"in h[r]&&(n.push(h[r].zIndex),h[r].zIndex<0&&(o[h[r].zIndex]=h[r]));for(n.sort(i);n[j]<0;)if(e=o[n[j++]],p.push(e.apply(d,g)),c)return c=f,p;for(r=0;s>r;r++)if(e=h[r],"zIndex"in e)if(e.zIndex==n[j]){if(p.push(e.apply(d,g)),c)break;do if(j++,e=o[n[j]],e&&p.push(e.apply(d,g)),c)break;while(e)}else o[e.zIndex]=e;else if(p.push(e.apply(d,g)),c)break;return c=f,b=q,p};m._events=j,m.listeners=function(a){var b,c,d,e,g,i,k,l,m=a.split(f),n=j,o=[n],p=[];for(e=0,g=m.length;g>e;e++){for(l=[],i=0,k=o.length;k>i;i++)for(n=o[i].n,c=[n[m[e]],n[h]],d=2;d--;)b=c[d],b&&(l.push(b),p=p.concat(b.f||[]));o=l}return p},m.on=function(a,b){if(a=String(a),"function"!=typeof b)return function(){};for(var c=a.split(g),d=0,e=c.length;e>d;d++)!function(a){for(var c,d=a.split(f),e=j,g=0,h=d.length;h>g;g++)e=e.n,e=e.hasOwnProperty(d[g])&&e[d[g]]||(e[d[g]]={n:{}});for(e.f=e.f||[],g=0,h=e.f.length;h>g;g++)if(e.f[g]==b){c=!0;break}!c&&e.f.push(b)}(c[d]);return function(a){+a==+a&&(b.zIndex=+a)}},m.f=function(a){var b=[].slice.call(arguments,1);return function(){m.apply(null,[a,null].concat(b).concat([].slice.call(arguments,0)))}},m.stop=function(){c=1},m.nt=function(a){return a?new RegExp("(?:\\.|\\/|^)"+a+"(?:\\.|\\/|$)").test(b):b},m.nts=function(){return b.split(f)},m.off=m.unbind=function(a,b){if(!a)return void(m._events=j={n:{}});var c=a.split(g);if(c.length>1)for(var d=0,i=c.length;i>d;d++)m.off(c[d],b);else{c=a.split(f);var k,l,n,d,i,o,p,q=[j];for(d=0,i=c.length;i>d;d++)for(o=0;o<q.length;o+=n.length-2){if(n=[o,1],k=q[o].n,c[d]!=h)k[c[d]]&&n.push(k[c[d]]);else for(l in k)k[e](l)&&n.push(k[l]);q.splice.apply(q,n)}for(d=0,i=q.length;i>d;d++)for(k=q[d];k.n;){if(b){if(k.f){for(o=0,p=k.f.length;p>o;o++)if(k.f[o]==b){k.f.splice(o,1);break}!k.f.length&&delete k.f}for(l in k.n)if(k.n[e](l)&&k.n[l].f){var r=k.n[l].f;for(o=0,p=r.length;p>o;o++)if(r[o]==b){r.splice(o,1);break}!r.length&&delete k.n[l].f}}else{delete k.f;for(l in k.n)k.n[e](l)&&k.n[l].f&&delete k.n[l].f}k=k.n}}},m.once=function(a,b){var c=function(){return m.unbind(a,c),b.apply(this,arguments)};return m.on(a,c)},m.version=d,m.toString=function(){return"You are running Eve "+d},"undefined"!=typeof module&&module.exports?module.exports=m: true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function(){return m}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):a.eve=m}(this),function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function(c){return b(a,c)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if("undefined"!=typeof exports){var c=require("eve");module.exports=b(a,c)}else b(a,a.eve)}(window||this,function(a,b){var c=function(b){var c={},d=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.mozRequestAnimationFrame||a.oRequestAnimationFrame||a.msRequestAnimationFrame||function(a){setTimeout(a,16)},e=Array.isArray||function(a){return a instanceof Array||"[object Array]"==Object.prototype.toString.call(a)},f=0,g="M"+(+new Date).toString(36),h=function(){return g+(f++).toString(36)},i=Date.now||function(){return+new Date},j=function(a){var b=this;if(null==a)return b.s;var c=b.s-a;b.b+=b.dur*c,b.B+=b.dur*c,b.s=a},k=function(a){var b=this;return null==a?b.spd:void(b.spd=a)},l=function(a){var b=this;return null==a?b.dur:(b.s=b.s*a/b.dur,void(b.dur=a))},m=function(){var a=this;delete c[a.id],a.update(),b("mina.stop."+a.id,a)},n=function(){var a=this;a.pdif||(delete c[a.id],a.update(),a.pdif=a.get()-a.b)},o=function(){var a=this;a.pdif&&(a.b=a.get()-a.pdif,delete a.pdif,c[a.id]=a)},p=function(){var a,b=this;if(e(b.start)){a=[];for(var c=0,d=b.start.length;d>c;c++)a[c]=+b.start[c]+(b.end[c]-b.start[c])*b.easing(b.s)}else a=+b.start+(b.end-b.start)*b.easing(b.s);b.set(a)},q=function(){var a=0;for(var e in c)if(c.hasOwnProperty(e)){var f=c[e],g=f.get();a++,f.s=(g-f.b)/(f.dur/f.spd),f.s>=1&&(delete c[e],f.s=1,a--,function(a){setTimeout(function(){b("mina.finish."+a.id,a)})}(f)),f.update()}a&&d(q)},r=function(a,b,e,f,g,i,s){var t={id:h(),start:a,end:b,b:e,s:0,dur:f-e,spd:1,get:g,set:i,easing:s||r.linear,status:j,speed:k,duration:l,stop:m,pause:n,resume:o,update:p};c[t.id]=t;var u,v=0;for(u in c)if(c.hasOwnProperty(u)&&(v++,2==v))break;return 1==v&&d(q),t};return r.time=i,r.getById=function(a){return c[a]||null},r.linear=function(a){return a},r.easeout=function(a){return Math.pow(a,1.7)},r.easein=function(a){return Math.pow(a,.48)},r.easeinout=function(a){if(1==a)return 1;if(0==a)return 0;var b=.48-a/1.04,c=Math.sqrt(.1734+b*b),d=c-b,e=Math.pow(Math.abs(d),1/3)*(0>d?-1:1),f=-c-b,g=Math.pow(Math.abs(f),1/3)*(0>f?-1:1),h=e+g+.5;return 3*(1-h)*h*h+h*h*h},r.backin=function(a){if(1==a)return 1;var b=1.70158;return a*a*((b+1)*a-b)},r.backout=function(a){if(0==a)return 0;a-=1;var b=1.70158;return a*a*((b+1)*a+b)+1},r.elastic=function(a){return a==!!a?a:Math.pow(2,-10*a)*Math.sin(2*(a-.075)*Math.PI/.3)+1},r.bounce=function(a){var b,c=7.5625,d=2.75;return 1/d>a?b=c*a*a:2/d>a?(a-=1.5/d,b=c*a*a+.75):2.5/d>a?(a-=2.25/d,b=c*a*a+.9375):(a-=2.625/d,b=c*a*a+.984375),b},a.mina=r,r}("undefined"==typeof b?function(){}:b),d=function(a){function c(a,b){if(a){if(a.nodeType)return w(a);if(e(a,"array")&&c.set)return c.set.apply(c,a);if(a instanceof s)return a;if(null==b)return a=y.doc.querySelector(String(a)),w(a)}return a=null==a?"100%":a,b=null==b?"100%":b,new v(a,b)}function d(a,b){if(b){if("#text"==a&&(a=y.doc.createTextNode(b.text||b["#text"]||"")),"#comment"==a&&(a=y.doc.createComment(b.text||b["#text"]||"")),"string"==typeof a&&(a=d(a)),"string"==typeof b)return 1==a.nodeType?"xlink:"==b.substring(0,6)?a.getAttributeNS(T,b.substring(6)):"xml:"==b.substring(0,4)?a.getAttributeNS(U,b.substring(4)):a.getAttribute(b):"text"==b?a.nodeValue:null;if(1==a.nodeType){for(var c in b)if(b[z](c)){var e=A(b[c]);e?"xlink:"==c.substring(0,6)?a.setAttributeNS(T,c.substring(6),e):"xml:"==c.substring(0,4)?a.setAttributeNS(U,c.substring(4),e):a.setAttribute(c,e):a.removeAttribute(c)}}else"text"in b&&(a.nodeValue=b.text)}else a=y.doc.createElementNS(U,a);return a}function e(a,b){return b=A.prototype.toLowerCase.call(b),"finite"==b?isFinite(a):"array"==b&&(a instanceof Array||Array.isArray&&Array.isArray(a))?!0:"null"==b&&null===a||b==typeof a&&null!==a||"object"==b&&a===Object(a)||J.call(a).slice(8,-1).toLowerCase()==b}function f(a){if("function"==typeof a||Object(a)!==a)return a;var b=new a.constructor;for(var c in a)a[z](c)&&(b[c]=f(a[c]));return b}function h(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return a.push(a.splice(c,1)[0])}function i(a,b,c){function d(){var e=Array.prototype.slice.call(arguments,0),f=e.join("␀"),g=d.cache=d.cache||{},i=d.count=d.count||[];return g[z](f)?(h(i,f),c?c(g[f]):g[f]):(i.length>=1e3&&delete g[i.shift()],i.push(f),g[f]=a.apply(b,e),c?c(g[f]):g[f])}return d}function j(a,b,c,d,e,f){if(null==e){var g=a-c,h=b-d;return g||h?(180+180*D.atan2(-h,-g)/H+360)%360:0}return j(a,b,e,f)-j(c,d,e,f)}function k(a){return a%360*H/180}function l(a){return 180*a/H%360}function m(a){var b=[];return a=a.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g,function(a,c,d){return d=d.split(/\s*,\s*|\s+/),"rotate"==c&&1==d.length&&d.push(0,0),"scale"==c&&(d.length>2?d=d.slice(0,2):2==d.length&&d.push(0,0),1==d.length&&d.push(d[0],0,0)),b.push("skewX"==c?["m",1,0,D.tan(k(d[0])),1,0,0]:"skewY"==c?["m",1,D.tan(k(d[0])),0,1,0,0]:[c.charAt(0)].concat(d)),a}),b}function n(a,b){var d=ab(a),e=new c.Matrix;if(d)for(var f=0,g=d.length;g>f;f++){var h,i,j,k,l,m=d[f],n=m.length,o=A(m[0]).toLowerCase(),p=m[0]!=o,q=p?e.invert():0;"t"==o&&2==n?e.translate(m[1],0):"t"==o&&3==n?p?(h=q.x(0,0),i=q.y(0,0),j=q.x(m[1],m[2]),k=q.y(m[1],m[2]),e.translate(j-h,k-i)):e.translate(m[1],m[2]):"r"==o?2==n?(l=l||b,e.rotate(m[1],l.x+l.width/2,l.y+l.height/2)):4==n&&(p?(j=q.x(m[2],m[3]),k=q.y(m[2],m[3]),e.rotate(m[1],j,k)):e.rotate(m[1],m[2],m[3])):"s"==o?2==n||3==n?(l=l||b,e.scale(m[1],m[n-1],l.x+l.width/2,l.y+l.height/2)):4==n?p?(j=q.x(m[2],m[3]),k=q.y(m[2],m[3]),e.scale(m[1],m[1],j,k)):e.scale(m[1],m[1],m[2],m[3]):5==n&&(p?(j=q.x(m[3],m[4]),k=q.y(m[3],m[4]),e.scale(m[1],m[2],j,k)):e.scale(m[1],m[2],m[3],m[4])):"m"==o&&7==n&&e.add(m[1],m[2],m[3],m[4],m[5],m[6])}return e}function o(a){var b=a.node.ownerSVGElement&&w(a.node.ownerSVGElement)||a.node.parentNode&&w(a.node.parentNode)||c.select("svg")||c(0,0),d=b.select("defs"),e=null==d?!1:d.node;return e||(e=u("defs",b.node).node),e}function p(a){return a.node.ownerSVGElement&&w(a.node.ownerSVGElement)||c.select("svg")}function q(a,b,c){function e(a){if(null==a)return I;if(a==+a)return a;d(j,{width:a});try{return j.getBBox().width}catch(b){return 0}}function f(a){if(null==a)return I;if(a==+a)return a;d(j,{height:a});try{return j.getBBox().height}catch(b){return 0}}function g(d,e){null==b?i[d]=e(a.attr(d)||0):d==b&&(i=e(null==c?a.attr(d)||0:c))}var h=p(a).node,i={},j=h.querySelector(".svg---mgr");switch(j||(j=d("rect"),d(j,{x:-9e9,y:-9e9,width:10,height:10,"class":"svg---mgr",fill:"none"}),h.appendChild(j)),a.type){case"rect":g("rx",e),g("ry",f);case"image":g("width",e),g("height",f);case"text":g("x",e),g("y",f);break;case"circle":g("cx",e),g("cy",f),g("r",e);break;case"ellipse":g("cx",e),g("cy",f),g("rx",e),g("ry",f);break;case"line":g("x1",e),g("x2",e),g("y1",f),g("y2",f);break;case"marker":g("refX",e),g("markerWidth",e),g("refY",f),g("markerHeight",f);break;case"radialGradient":g("fx",e),g("fy",f);break;case"tspan":g("dx",e),g("dy",f);break;default:g(b,e)}return h.removeChild(j),i}function r(a){e(a,"array")||(a=Array.prototype.slice.call(arguments,0));for(var b=0,c=0,d=this.node;this[b];)delete this[b++];for(b=0;b<a.length;b++)"set"==a[b].type?a[b].forEach(function(a){d.appendChild(a.node)}):d.appendChild(a[b].node);var f=d.childNodes;for(b=0;b<f.length;b++)this[c++]=w(f[b]);return this}function s(a){if(a.snap in V)return V[a.snap];var b;try{b=a.ownerSVGElement}catch(c){}this.node=a,b&&(this.paper=new v(b)),this.type=a.tagName||a.nodeName;var d=this.id=S(this);if(this.anims={},this._={transform:[]},a.snap=d,V[d]=this,"g"==this.type&&(this.add=r),this.type in{g:1,mask:1,pattern:1,symbol:1})for(var e in v.prototype)v.prototype[z](e)&&(this[e]=v.prototype[e])}function t(a){this.node=a}function u(a,b){var c=d(a);b.appendChild(c);var e=w(c);return e}function v(a,b){var c,e,f,g=v.prototype;if(a&&"svg"==a.tagName){if(a.snap in V)return V[a.snap];var h=a.ownerDocument;c=new s(a),e=a.getElementsByTagName("desc")[0],f=a.getElementsByTagName("defs")[0],e||(e=d("desc"),e.appendChild(h.createTextNode("Created with Snap")),c.node.appendChild(e)),f||(f=d("defs"),c.node.appendChild(f)),c.defs=f;for(var i in g)g[z](i)&&(c[i]=g[i]);c.paper=c.root=c}else c=u("svg",y.doc.body),d(c.node,{height:b,version:1.1,width:a,xmlns:U});return c}function w(a){return a?a instanceof s||a instanceof t?a:a.tagName&&"svg"==a.tagName.toLowerCase()?new v(a):a.tagName&&"object"==a.tagName.toLowerCase()&&"image/svg+xml"==a.type?new v(a.contentDocument.getElementsByTagName("svg")[0]):new s(a):a}function x(a,b){for(var c=0,d=a.length;d>c;c++){var e={type:a[c].type,attr:a[c].attr()},f=a[c].children();b.push(e),f.length&&x(f,e.childNodes=[])}}c.version="0.4.0",c.toString=function(){return"Snap v"+this.version},c._={};var y={win:a.window,doc:a.window.document};c._.glob=y;{var z="hasOwnProperty",A=String,B=parseFloat,C=parseInt,D=Math,E=D.max,F=D.min,G=D.abs,H=(D.pow,D.PI),I=(D.round,""),J=Object.prototype.toString,K=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,L=(c._.separator=/[,\s]+/,/[\s]*,[\s]*/),M={hs:1,rg:1},N=/([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/gi,O=/([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/gi,P=/(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/gi,Q=0,R="S"+(+new Date).toString(36),S=function(a){return(a&&a.type?a.type:I)+R+(Q++).toString(36)},T="http://www.w3.org/1999/xlink",U="http://www.w3.org/2000/svg",V={};c.url=function(a){return"url('#"+a+"')"}}c._.$=d,c._.id=S,c.format=function(){var a=/\{([^\}]+)\}/g,b=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,c=function(a,c,d){var e=d;return c.replace(b,function(a,b,c,d,f){b=b||d,e&&(b in e&&(e=e[b]),"function"==typeof e&&f&&(e=e()))}),e=(null==e||e==d?a:e)+""};return function(b,d){return A(b).replace(a,function(a,b){return c(a,b,d)})}}(),c._.clone=f,c._.cacher=i,c.rad=k,c.deg=l,c.sin=function(a){return D.sin(c.rad(a))},c.tan=function(a){return D.tan(c.rad(a))},c.cos=function(a){return D.cos(c.rad(a))},c.asin=function(a){return c.deg(D.asin(a))},c.acos=function(a){return c.deg(D.acos(a))},c.atan=function(a){return c.deg(D.atan(a))},c.atan2=function(a){return c.deg(D.atan2(a))},c.angle=j,c.len=function(a,b,d,e){return Math.sqrt(c.len2(a,b,d,e))},c.len2=function(a,b,c,d){return(a-c)*(a-c)+(b-d)*(b-d)},c.closestPoint=function(a,b,c){function d(a){var d=a.x-b,e=a.y-c;return d*d+e*e}for(var e,f,g,h,i=a.node,j=i.getTotalLength(),k=j/i.pathSegList.numberOfItems*.125,l=1/0,m=0;j>=m;m+=k)(h=d(g=i.getPointAtLength(m)))<l&&(e=g,f=m,l=h);for(k*=.5;k>.5;){var n,o,p,q,r,s;(p=f-k)>=0&&(r=d(n=i.getPointAtLength(p)))<l?(e=n,f=p,l=r):(q=f+k)<=j&&(s=d(o=i.getPointAtLength(q)))<l?(e=o,f=q,l=s):k*=.5}return e={x:e.x,y:e.y,length:f,distance:Math.sqrt(l)}},c.is=e,c.snapTo=function(a,b,c){if(c=e(c,"finite")?c:10,e(a,"array")){for(var d=a.length;d--;)if(G(a[d]-b)<=c)return a[d]}else{a=+a;var f=b%a;if(c>f)return b-f;if(f>a-c)return b-f+a}return b},c.getRGB=i(function(a){if(!a||(a=A(a)).indexOf("-")+1)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z};if("none"==a)return{r:-1,g:-1,b:-1,hex:"none",toString:Z};if(!(M[z](a.toLowerCase().substring(0,2))||"#"==a.charAt())&&(a=W(a)),!a)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z};var b,d,f,g,h,i,j=a.match(K);return j?(j[2]&&(f=C(j[2].substring(5),16),d=C(j[2].substring(3,5),16),b=C(j[2].substring(1,3),16)),j[3]&&(f=C((h=j[3].charAt(3))+h,16),d=C((h=j[3].charAt(2))+h,16),b=C((h=j[3].charAt(1))+h,16)),j[4]&&(i=j[4].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),d=B(i[1]),"%"==i[1].slice(-1)&&(d*=2.55),f=B(i[2]),"%"==i[2].slice(-1)&&(f*=2.55),"rgba"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100)),j[5]?(i=j[5].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b/=100),d=B(i[1]),"%"==i[1].slice(-1)&&(d/=100),f=B(i[2]),"%"==i[2].slice(-1)&&(f/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsba"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),c.hsb2rgb(b,d,f,g)):j[6]?(i=j[6].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b/=100),d=B(i[1]),"%"==i[1].slice(-1)&&(d/=100),f=B(i[2]),"%"==i[2].slice(-1)&&(f/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsla"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),c.hsl2rgb(b,d,f,g)):(b=F(D.round(b),255),d=F(D.round(d),255),f=F(D.round(f),255),g=F(E(g,0),1),j={r:b,g:d,b:f,toString:Z},j.hex="#"+(16777216|f|d<<8|b<<16).toString(16).slice(1),j.opacity=e(g,"finite")?g:1,j)):{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z}},c),c.hsb=i(function(a,b,d){return c.hsb2rgb(a,b,d).hex}),c.hsl=i(function(a,b,d){return c.hsl2rgb(a,b,d).hex}),c.rgb=i(function(a,b,c,d){if(e(d,"finite")){var f=D.round;return"rgba("+[f(a),f(b),f(c),+d.toFixed(2)]+")"}return"#"+(16777216|c|b<<8|a<<16).toString(16).slice(1)});var W=function(a){var b=y.doc.getElementsByTagName("head")[0]||y.doc.getElementsByTagName("svg")[0],c="rgb(255, 0, 0)";return(W=i(function(a){if("red"==a.toLowerCase())return c;b.style.color=c,b.style.color=a;var d=y.doc.defaultView.getComputedStyle(b,I).getPropertyValue("color");return d==c?null:d}))(a)},X=function(){return"hsb("+[this.h,this.s,this.b]+")"},Y=function(){return"hsl("+[this.h,this.s,this.l]+")"},Z=function(){return 1==this.opacity||null==this.opacity?this.hex:"rgba("+[this.r,this.g,this.b,this.opacity]+")"},$=function(a,b,d){if(null==b&&e(a,"object")&&"r"in a&&"g"in a&&"b"in a&&(d=a.b,b=a.g,a=a.r),null==b&&e(a,string)){var f=c.getRGB(a);a=f.r,b=f.g,d=f.b}return(a>1||b>1||d>1)&&(a/=255,b/=255,d/=255),[a,b,d]},_=function(a,b,d,f){a=D.round(255*a),b=D.round(255*b),d=D.round(255*d);var g={r:a,g:b,b:d,opacity:e(f,"finite")?f:1,hex:c.rgb(a,b,d),toString:Z};return e(f,"finite")&&(g.opacity=f),g};c.color=function(a){var b;return e(a,"object")&&"h"in a&&"s"in a&&"b"in a?(b=c.hsb2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):e(a,"object")&&"h"in a&&"s"in a&&"l"in a?(b=c.hsl2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):(e(a,"string")&&(a=c.getRGB(a)),e(a,"object")&&"r"in a&&"g"in a&&"b"in a&&!("error"in a)?(b=c.rgb2hsl(a),a.h=b.h,a.s=b.s,a.l=b.l,b=c.rgb2hsb(a),a.v=b.b):(a={hex:"none"},a.r=a.g=a.b=a.h=a.s=a.v=a.l=-1,a.error=1)),a.toString=Z,a},c.hsb2rgb=function(a,b,c,d){e(a,"object")&&"h"in a&&"s"in a&&"b"in a&&(c=a.b,b=a.s,d=a.o,a=a.h),a*=360;var f,g,h,i,j;return a=a%360/60,j=c*b,i=j*(1-G(a%2-1)),f=g=h=c-j,a=~~a,f+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],_(f,g,h,d)},c.hsl2rgb=function(a,b,c,d){e(a,"object")&&"h"in a&&"s"in a&&"l"in a&&(c=a.l,b=a.s,a=a.h),(a>1||b>1||c>1)&&(a/=360,b/=100,c/=100),a*=360;var f,g,h,i,j;return a=a%360/60,j=2*b*(.5>c?c:1-c),i=j*(1-G(a%2-1)),f=g=h=c-j/2,a=~~a,f+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],_(f,g,h,d)},c.rgb2hsb=function(a,b,c){c=$(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g;return f=E(a,b,c),g=f-F(a,b,c),d=0==g?null:f==a?(b-c)/g:f==b?(c-a)/g+2:(a-b)/g+4,d=(d+360)%6*60/360,e=0==g?0:g/f,{h:d,s:e,b:f,toString:X}},c.rgb2hsl=function(a,b,c){c=$(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g,h,i;return g=E(a,b,c),h=F(a,b,c),i=g-h,d=0==i?null:g==a?(b-c)/i:g==b?(c-a)/i+2:(a-b)/i+4,d=(d+360)%6*60/360,f=(g+h)/2,e=0==i?0:.5>f?i/(2*f):i/(2-2*f),{h:d,s:e,l:f,toString:Y}},c.parsePathString=function(a){if(!a)return null;var b=c.path(a);if(b.arr)return c.path.clone(b.arr);var d={a:7,c:6,o:2,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,u:3,z:0},f=[];return e(a,"array")&&e(a[0],"array")&&(f=c.path.clone(a)),f.length||A(a).replace(N,function(a,b,c){var e=[],g=b.toLowerCase();if(c.replace(P,function(a,b){b&&e.push(+b)}),"m"==g&&e.length>2&&(f.push([b].concat(e.splice(0,2))),g="l",b="m"==b?"l":"L"),"o"==g&&1==e.length&&f.push([b,e[0]]),"r"==g)f.push([b].concat(e));else for(;e.length>=d[g]&&(f.push([b].concat(e.splice(0,d[g]))),d[g]););}),f.toString=c.path.toString,b.arr=c.path.clone(f),f};var ab=c.parseTransformString=function(a){if(!a)return null;var b=[];return e(a,"array")&&e(a[0],"array")&&(b=c.path.clone(a)),b.length||A(a).replace(O,function(a,c,d){{var e=[];c.toLowerCase()}d.replace(P,function(a,b){b&&e.push(+b)}),b.push([c].concat(e))}),b.toString=c.path.toString,b};c._.svgTransform2string=m,c._.rgTransform=/^[a-z][\s]*-?\.?\d/i,c._.transform2matrix=n,c._unit2px=q;y.doc.contains||y.doc.compareDocumentPosition?function(a,b){var c=9==a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a==d||!(!d||1!=d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)for(;b;)if(b=b.parentNode,b==a)return!0;return!1};c._.getSomeDefs=o,c._.getSomeSVG=p,c.select=function(a){return a=A(a).replace(/([^\\]):/g,"$1\\:"),w(y.doc.querySelector(a))},c.selectAll=function(a){for(var b=y.doc.querySelectorAll(a),d=(c.set||Array)(),e=0;e<b.length;e++)d.push(w(b[e]));return d},setInterval(function(){for(var a in V)if(V[z](a)){var b=V[a],c=b.node;("svg"!=b.type&&!c.ownerSVGElement||"svg"==b.type&&(!c.parentNode||"ownerSVGElement"in c.parentNode&&!c.ownerSVGElement))&&delete V[a]}},1e4),s.prototype.attr=function(a,c){var d=this,f=d.node;if(!a){if(1!=f.nodeType)return{text:f.nodeValue};for(var g=f.attributes,h={},i=0,j=g.length;j>i;i++)h[g[i].nodeName]=g[i].nodeValue;return h}if(e(a,"string")){if(!(arguments.length>1))return b("snap.util.getattr."+a,d).firstDefined();var k={};k[a]=c,a=k}for(var l in a)a[z](l)&&b("snap.util.attr."+l,d,a[l]);return d},c.parse=function(a){var b=y.doc.createDocumentFragment(),c=!0,d=y.doc.createElement("div");if(a=A(a),a.match(/^\s*<\s*svg(?:\s|>)/)||(a="<svg>"+a+"</svg>",c=!1),d.innerHTML=a,a=d.getElementsByTagName("svg")[0])if(c)b=a;else for(;a.firstChild;)b.appendChild(a.firstChild);return new t(b)},c.fragment=function(){for(var a=Array.prototype.slice.call(arguments,0),b=y.doc.createDocumentFragment(),d=0,e=a.length;e>d;d++){var f=a[d];f.node&&f.node.nodeType&&b.appendChild(f.node),f.nodeType&&b.appendChild(f),"string"==typeof f&&b.appendChild(c.parse(f).node)}return new t(b)},c._.make=u,c._.wrap=w,v.prototype.el=function(a,b){var c=u(a,this.node);return b&&c.attr(b),c},s.prototype.children=function(){for(var a=[],b=this.node.childNodes,d=0,e=b.length;e>d;d++)a[d]=c(b[d]);return a},s.prototype.toJSON=function(){var a=[];return x([this],a),a[0]},b.on("snap.util.getattr",function(){var a=b.nt();a=a.substring(a.lastIndexOf(".")+1);var c=a.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});return bb[z](c)?this.node.ownerDocument.defaultView.getComputedStyle(this.node,null).getPropertyValue(c):d(this.node,a)});var bb={"alignment-baseline":0,"baseline-shift":0,clip:0,"clip-path":0,"clip-rule":0,color:0,"color-interpolation":0,"color-interpolation-filters":0,"color-profile":0,"color-rendering":0,cursor:0,direction:0,display:0,"dominant-baseline":0,"enable-background":0,fill:0,"fill-opacity":0,"fill-rule":0,filter:0,"flood-color":0,"flood-opacity":0,font:0,"font-family":0,"font-size":0,"font-size-adjust":0,"font-stretch":0,"font-style":0,"font-variant":0,"font-weight":0,"glyph-orientation-horizontal":0,"glyph-orientation-vertical":0,"image-rendering":0,kerning:0,"letter-spacing":0,"lighting-color":0,marker:0,"marker-end":0,"marker-mid":0,"marker-start":0,mask:0,opacity:0,overflow:0,"pointer-events":0,"shape-rendering":0,"stop-color":0,"stop-opacity":0,stroke:0,"stroke-dasharray":0,"stroke-dashoffset":0,"stroke-linecap":0,"stroke-linejoin":0,"stroke-miterlimit":0,"stroke-opacity":0,"stroke-width":0,"text-anchor":0,"text-decoration":0,"text-rendering":0,"unicode-bidi":0,visibility:0,"word-spacing":0,"writing-mode":0};b.on("snap.util.attr",function(a){var c=b.nt(),e={};c=c.substring(c.lastIndexOf(".")+1),e[c]=a;var f=c.replace(/-(\w)/gi,function(a,b){return b.toUpperCase()}),g=c.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});bb[z](g)?this.node.style[f]=null==a?I:a:d(this.node,e)}),function(){}(v.prototype),c.ajax=function(a,c,d,f){var g=new XMLHttpRequest,h=S();if(g){if(e(c,"function"))f=d,d=c,c=null;else if(e(c,"object")){var i=[];for(var j in c)c.hasOwnProperty(j)&&i.push(encodeURIComponent(j)+"="+encodeURIComponent(c[j]));c=i.join("&")}return g.open(c?"POST":"GET",a,!0),c&&(g.setRequestHeader("X-Requested-With","XMLHttpRequest"),g.setRequestHeader("Content-type","application/x-www-form-urlencoded")),d&&(b.once("snap.ajax."+h+".0",d),b.once("snap.ajax."+h+".200",d),b.once("snap.ajax."+h+".304",d)),g.onreadystatechange=function(){4==g.readyState&&b("snap.ajax."+h+"."+g.status,f,g)},4==g.readyState?g:(g.send(c),g)}},c.load=function(a,b,d){c.ajax(a,function(a){var e=c.parse(a.responseText);d?b.call(d,e):b(e)})};var cb=function(a){var b=a.getBoundingClientRect(),c=a.ownerDocument,d=c.body,e=c.documentElement,f=e.clientTop||d.clientTop||0,h=e.clientLeft||d.clientLeft||0,i=b.top+(g.win.pageYOffset||e.scrollTop||d.scrollTop)-f,j=b.left+(g.win.pageXOffset||e.scrollLeft||d.scrollLeft)-h;return{y:i,x:j}};return c.getElementByPoint=function(a,b){var c=this,d=(c.canvas,y.doc.elementFromPoint(a,b));if(y.win.opera&&"svg"==d.tagName){var e=cb(d),f=d.createSVGRect();f.x=a-e.x,f.y=b-e.y,f.width=f.height=1;var g=d.getIntersectionList(f,null);g.length&&(d=g[g.length-1])}return d?w(d):null},c.plugin=function(a){a(c,s,v,y,t)},y.win.Snap=c,c}(a||this);return d.plugin(function(d,e,f,g,h){function i(a,b){if(null==b){var c=!0;if(b=a.node.getAttribute("linearGradient"==a.type||"radialGradient"==a.type?"gradientTransform":"pattern"==a.type?"patternTransform":"transform"),!b)return new d.Matrix;b=d._.svgTransform2string(b)}else b=d._.rgTransform.test(b)?o(b).replace(/\.{3}|\u2026/g,a._.transform||""):d._.svgTransform2string(b),n(b,"array")&&(b=d.path?d.path.toString.call(b):o(b)),a._.transform=b;var e=d._.transform2matrix(b,a.getBBox(1));return c?e:void(a.matrix=e)}function j(a){function b(a,b){var c=q(a.node,b);c=c&&c.match(f),c=c&&c[2],c&&"#"==c.charAt()&&(c=c.substring(1),c&&(h[c]=(h[c]||[]).concat(function(c){var d={};d[b]=URL(c),q(a.node,d)})))}function c(a){var b=q(a.node,"xlink:href");b&&"#"==b.charAt()&&(b=b.substring(1),b&&(h[b]=(h[b]||[]).concat(function(b){a.attr("xlink:href","#"+b)})))}for(var d,e=a.selectAll("*"),f=/^\s*url\(("|'|)(.*)\1\)\s*$/,g=[],h={},i=0,j=e.length;j>i;i++){d=e[i],b(d,"fill"),b(d,"stroke"),b(d,"filter"),b(d,"mask"),b(d,"clip-path"),c(d);var k=q(d.node,"id");k&&(q(d.node,{id:d.id}),g.push({old:k,id:d.id}))}for(i=0,j=g.length;j>i;i++){var l=h[g[i].old];if(l)for(var m=0,n=l.length;n>m;m++)l[m](g[i].id)}}function k(a,b,c){return function(d){var e=d.slice(a,b);return 1==e.length&&(e=e[0]),c?c(e):e}}function l(a){return function(){var b=a?"<"+this.type:"",c=this.node.attributes,d=this.node.childNodes;if(a)for(var e=0,f=c.length;f>e;e++)b+=" "+c[e].name+'="'+c[e].value.replace(/"/g,'\\"')+'"';if(d.length){for(a&&(b+=">"),e=0,f=d.length;f>e;e++)3==d[e].nodeType?b+=d[e].nodeValue:1==d[e].nodeType&&(b+=u(d[e]).toString());a&&(b+="</"+this.type+">")}else a&&(b+="/>");return b}}var m=e.prototype,n=d.is,o=String,p=d._unit2px,q=d._.$,r=d._.make,s=d._.getSomeDefs,t="hasOwnProperty",u=d._.wrap;m.getBBox=function(a){if(!d.Matrix||!d.path)return this.node.getBBox();var b=this,c=new d.Matrix;if(b.removed)return d._.box();for(;"use"==b.type;)if(a||(c=c.add(b.transform().localMatrix.translate(b.attr("x")||0,b.attr("y")||0))),b.original)b=b.original;else{var e=b.attr("xlink:href");b=b.original=b.node.ownerDocument.getElementById(e.substring(e.indexOf("#")+1))}var f=b._,g=d.path.get[b.type]||d.path.get.deflt;try{return a?(f.bboxwt=g?d.path.getBBox(b.realPath=g(b)):d._.box(b.node.getBBox()),d._.box(f.bboxwt)):(b.realPath=g(b),b.matrix=b.transform().localMatrix,f.bbox=d.path.getBBox(d.path.map(b.realPath,c.add(b.matrix))),d._.box(f.bbox))}catch(h){return d._.box()}};var v=function(){return this.string};m.transform=function(a){var b=this._;if(null==a){for(var c,e=this,f=new d.Matrix(this.node.getCTM()),g=i(this),h=[g],j=new d.Matrix,k=g.toTransformString(),l=o(g)==o(this.matrix)?o(b.transform):k;"svg"!=e.type&&(e=e.parent());)h.push(i(e));for(c=h.length;c--;)j.add(h[c]);return{string:l,globalMatrix:f,totalMatrix:j,localMatrix:g,diffMatrix:f.clone().add(g.invert()),global:f.toTransformString(),total:j.toTransformString(),local:k,toString:v}}return a instanceof d.Matrix?(this.matrix=a,this._.transform=a.toTransformString()):i(this,a),this.node&&("linearGradient"==this.type||"radialGradient"==this.type?q(this.node,{gradientTransform:this.matrix}):"pattern"==this.type?q(this.node,{patternTransform:this.matrix}):q(this.node,{transform:this.matrix})),this},m.parent=function(){return u(this.node.parentNode)},m.append=m.add=function(a){if(a){if("set"==a.type){var b=this;return a.forEach(function(a){b.add(a)}),this}a=u(a),this.node.appendChild(a.node),a.paper=this.paper}return this},m.appendTo=function(a){return a&&(a=u(a),a.append(this)),this},m.prepend=function(a){if(a){if("set"==a.type){var b,c=this;return a.forEach(function(a){b?b.after(a):c.prepend(a),b=a}),this}a=u(a);var d=a.parent();this.node.insertBefore(a.node,this.node.firstChild),this.add&&this.add(),a.paper=this.paper,this.parent()&&this.parent().add(),d&&d.add()}return this},m.prependTo=function(a){return a=u(a),a.prepend(this),this},m.before=function(a){if("set"==a.type){var b=this;return a.forEach(function(a){var c=a.parent();b.node.parentNode.insertBefore(a.node,b.node),c&&c.add()}),this.parent().add(),this}a=u(a);var c=a.parent();return this.node.parentNode.insertBefore(a.node,this.node),this.parent()&&this.parent().add(),c&&c.add(),a.paper=this.paper,this},m.after=function(a){a=u(a);var b=a.parent();return this.node.nextSibling?this.node.parentNode.insertBefore(a.node,this.node.nextSibling):this.node.parentNode.appendChild(a.node),this.parent()&&this.parent().add(),b&&b.add(),a.paper=this.paper,this},m.insertBefore=function(a){a=u(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},m.insertAfter=function(a){a=u(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node.nextSibling),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},m.remove=function(){var a=this.parent();return this.node.parentNode&&this.node.parentNode.removeChild(this.node),delete this.paper,this.removed=!0,a&&a.add(),this},m.select=function(a){return u(this.node.querySelector(a))},m.selectAll=function(a){for(var b=this.node.querySelectorAll(a),c=(d.set||Array)(),e=0;e<b.length;e++)c.push(u(b[e]));return c},m.asPX=function(a,b){return null==b&&(b=this.attr(a)),+p(this,a,b)},m.use=function(){var a,b=this.node.id;return b||(b=this.id,q(this.node,{id:b})),a="linearGradient"==this.type||"radialGradient"==this.type||"pattern"==this.type?r(this.type,this.node.parentNode):r("use",this.node.parentNode),q(a.node,{"xlink:href":"#"+b}),a.original=this,a},m.clone=function(){var a=u(this.node.cloneNode(!0));return q(a.node,"id")&&q(a.node,{id:a.id}),j(a),a.insertAfter(this),a},m.toDefs=function(){var a=s(this);return a.appendChild(this.node),this},m.pattern=m.toPattern=function(a,b,c,d){var e=r("pattern",s(this));return null==a&&(a=this.getBBox()),n(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,a=a.x),q(e.node,{x:a,y:b,width:c,height:d,patternUnits:"userSpaceOnUse",id:e.id,viewBox:[a,b,c,d].join(" ")}),e.node.appendChild(this.node),e},m.marker=function(a,b,c,d,e,f){var g=r("marker",s(this));return null==a&&(a=this.getBBox()),n(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,e=a.refX||a.cx,f=a.refY||a.cy,a=a.x),q(g.node,{viewBox:[a,b,c,d].join(" "),markerWidth:c,markerHeight:d,orient:"auto",refX:e||0,refY:f||0,id:g.id}),g.node.appendChild(this.node),g};var w=function(a,b,d,e){"function"!=typeof d||d.length||(e=d,d=c.linear),this.attr=a,this.dur=b,d&&(this.easing=d),e&&(this.callback=e)};d._.Animation=w,d.animation=function(a,b,c,d){return new w(a,b,c,d)},m.inAnim=function(){var a=this,b=[];for(var c in a.anims)a.anims[t](c)&&!function(a){b.push({anim:new w(a._attrs,a.dur,a.easing,a._callback),mina:a,curStatus:a.status(),status:function(b){return a.status(b)},stop:function(){a.stop()}})}(a.anims[c]);return b},d.animate=function(a,d,e,f,g,h){"function"!=typeof g||g.length||(h=g,g=c.linear);var i=c.time(),j=c(a,d,i,i+f,c.time,e,g);return h&&b.once("mina.finish."+j.id,h),j},m.stop=function(){for(var a=this.inAnim(),b=0,c=a.length;c>b;b++)a[b].stop();return this},m.animate=function(a,d,e,f){"function"!=typeof e||e.length||(f=e,e=c.linear),a instanceof w&&(f=a.callback,e=a.easing,d=a.dur,a=a.attr);var g,h,i,j,l=[],m=[],p={},q=this;for(var r in a)if(a[t](r)){q.equal?(j=q.equal(r,o(a[r])),g=j.from,h=j.to,i=j.f):(g=+q.attr(r),h=+a[r]);var s=n(g,"array")?g.length:1;p[r]=k(l.length,l.length+s,i),l=l.concat(g),m=m.concat(h)}var u=c.time(),v=c(l,m,u,u+d,c.time,function(a){var b={};for(var c in p)p[t](c)&&(b[c]=p[c](a));q.attr(b)},e);return q.anims[v.id]=v,v._attrs=a,v._callback=f,b("snap.animcreated."+q.id,v),b.once("mina.finish."+v.id,function(){delete q.anims[v.id],f&&f.call(q)}),b.once("mina.stop."+v.id,function(){delete q.anims[v.id]}),q};var x={};m.data=function(a,c){var e=x[this.id]=x[this.id]||{};if(0==arguments.length)return b("snap.data.get."+this.id,this,e,null),e;
		if(1==arguments.length){if(d.is(a,"object")){for(var f in a)a[t](f)&&this.data(f,a[f]);return this}return b("snap.data.get."+this.id,this,e[a],a),e[a]}return e[a]=c,b("snap.data.set."+this.id,this,c,a),this},m.removeData=function(a){return null==a?x[this.id]={}:x[this.id]&&delete x[this.id][a],this},m.outerSVG=m.toString=l(1),m.innerSVG=l(),m.toDataURL=function(){if(a&&a.btoa){var b=this.getBBox(),c=d.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>',{x:+b.x.toFixed(3),y:+b.y.toFixed(3),width:+b.width.toFixed(3),height:+b.height.toFixed(3),contents:this.outerSVG()});return"data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(c)))}},h.prototype.select=m.select,h.prototype.selectAll=m.selectAll}),d.plugin(function(a){function b(a,b,d,e,f,g){return null==b&&"[object SVGMatrix]"==c.call(a)?(this.a=a.a,this.b=a.b,this.c=a.c,this.d=a.d,this.e=a.e,void(this.f=a.f)):void(null!=a?(this.a=+a,this.b=+b,this.c=+d,this.d=+e,this.e=+f,this.f=+g):(this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0))}var c=Object.prototype.toString,d=String,e=Math,f="";!function(c){function g(a){return a[0]*a[0]+a[1]*a[1]}function h(a){var b=e.sqrt(g(a));a[0]&&(a[0]/=b),a[1]&&(a[1]/=b)}c.add=function(a,c,d,e,f,g){var h,i,j,k,l=[[],[],[]],m=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],n=[[a,d,f],[c,e,g],[0,0,1]];for(a&&a instanceof b&&(n=[[a.a,a.c,a.e],[a.b,a.d,a.f],[0,0,1]]),h=0;3>h;h++)for(i=0;3>i;i++){for(k=0,j=0;3>j;j++)k+=m[h][j]*n[j][i];l[h][i]=k}return this.a=l[0][0],this.b=l[1][0],this.c=l[0][1],this.d=l[1][1],this.e=l[0][2],this.f=l[1][2],this},c.invert=function(){var a=this,c=a.a*a.d-a.b*a.c;return new b(a.d/c,-a.b/c,-a.c/c,a.a/c,(a.c*a.f-a.d*a.e)/c,(a.b*a.e-a.a*a.f)/c)},c.clone=function(){return new b(this.a,this.b,this.c,this.d,this.e,this.f)},c.translate=function(a,b){return this.add(1,0,0,1,a,b)},c.scale=function(a,b,c,d){return null==b&&(b=a),(c||d)&&this.add(1,0,0,1,c,d),this.add(a,0,0,b,0,0),(c||d)&&this.add(1,0,0,1,-c,-d),this},c.rotate=function(b,c,d){b=a.rad(b),c=c||0,d=d||0;var f=+e.cos(b).toFixed(9),g=+e.sin(b).toFixed(9);return this.add(f,g,-g,f,c,d),this.add(1,0,0,1,-c,-d)},c.x=function(a,b){return a*this.a+b*this.c+this.e},c.y=function(a,b){return a*this.b+b*this.d+this.f},c.get=function(a){return+this[d.fromCharCode(97+a)].toFixed(4)},c.toString=function(){return"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")"},c.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]},c.determinant=function(){return this.a*this.d-this.b*this.c},c.split=function(){var b={};b.dx=this.e,b.dy=this.f;var c=[[this.a,this.c],[this.b,this.d]];b.scalex=e.sqrt(g(c[0])),h(c[0]),b.shear=c[0][0]*c[1][0]+c[0][1]*c[1][1],c[1]=[c[1][0]-c[0][0]*b.shear,c[1][1]-c[0][1]*b.shear],b.scaley=e.sqrt(g(c[1])),h(c[1]),b.shear/=b.scaley,this.determinant()<0&&(b.scalex=-b.scalex);var d=-c[0][1],f=c[1][1];return 0>f?(b.rotate=a.deg(e.acos(f)),0>d&&(b.rotate=360-b.rotate)):b.rotate=a.deg(e.asin(d)),b.isSimple=!(+b.shear.toFixed(9)||b.scalex.toFixed(9)!=b.scaley.toFixed(9)&&b.rotate),b.isSuperSimple=!+b.shear.toFixed(9)&&b.scalex.toFixed(9)==b.scaley.toFixed(9)&&!b.rotate,b.noRotation=!+b.shear.toFixed(9)&&!b.rotate,b},c.toTransformString=function(a){var b=a||this.split();return+b.shear.toFixed(9)?"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]:(b.scalex=+b.scalex.toFixed(4),b.scaley=+b.scaley.toFixed(4),b.rotate=+b.rotate.toFixed(4),(b.dx||b.dy?"t"+[+b.dx.toFixed(4),+b.dy.toFixed(4)]:f)+(1!=b.scalex||1!=b.scaley?"s"+[b.scalex,b.scaley,0,0]:f)+(b.rotate?"r"+[+b.rotate.toFixed(4),0,0]:f))}}(b.prototype),a.Matrix=b,a.matrix=function(a,c,d,e,f,g){return new b(a,c,d,e,f,g)}}),d.plugin(function(a,c,d,e,f){function g(d){return function(e){if(b.stop(),e instanceof f&&1==e.node.childNodes.length&&("radialGradient"==e.node.firstChild.tagName||"linearGradient"==e.node.firstChild.tagName||"pattern"==e.node.firstChild.tagName)&&(e=e.node.firstChild,n(this).appendChild(e),e=l(e)),e instanceof c)if("radialGradient"==e.type||"linearGradient"==e.type||"pattern"==e.type){e.node.id||p(e.node,{id:e.id});var g=q(e.node.id)}else g=e.attr(d);else if(g=a.color(e),g.error){var h=a(n(this).ownerSVGElement).gradient(e);h?(h.node.id||p(h.node,{id:h.id}),g=q(h.node.id)):g=e}else g=r(g);var i={};i[d]=g,p(this.node,i),this.node.style[d]=t}}function h(a){b.stop(),a==+a&&(a+="px"),this.node.style.fontSize=a}function i(a){for(var b=[],c=a.childNodes,d=0,e=c.length;e>d;d++){var f=c[d];3==f.nodeType&&b.push(f.nodeValue),"tspan"==f.tagName&&b.push(1==f.childNodes.length&&3==f.firstChild.nodeType?f.firstChild.nodeValue:i(f))}return b}function j(){return b.stop(),this.node.style.fontSize}var k=a._.make,l=a._.wrap,m=a.is,n=a._.getSomeDefs,o=/^url\(#?([^)]+)\)$/,p=a._.$,q=a.url,r=String,s=a._.separator,t="";b.on("snap.util.attr.mask",function(a){if(a instanceof c||a instanceof f){if(b.stop(),a instanceof f&&1==a.node.childNodes.length&&(a=a.node.firstChild,n(this).appendChild(a),a=l(a)),"mask"==a.type)var d=a;else d=k("mask",n(this)),d.node.appendChild(a.node);!d.node.id&&p(d.node,{id:d.id}),p(this.node,{mask:q(d.id)})}}),function(a){b.on("snap.util.attr.clip",a),b.on("snap.util.attr.clip-path",a),b.on("snap.util.attr.clipPath",a)}(function(a){if(a instanceof c||a instanceof f){if(b.stop(),"clipPath"==a.type)var d=a;else d=k("clipPath",n(this)),d.node.appendChild(a.node),!d.node.id&&p(d.node,{id:d.id});p(this.node,{"clip-path":q(d.node.id||d.id)})}}),b.on("snap.util.attr.fill",g("fill")),b.on("snap.util.attr.stroke",g("stroke"));var u=/^([lr])(?:\(([^)]*)\))?(.*)$/i;b.on("snap.util.grad.parse",function(a){a=r(a);var b=a.match(u);if(!b)return null;var c=b[1],d=b[2],e=b[3];return d=d.split(/\s*,\s*/).map(function(a){return+a==a?+a:a}),1==d.length&&0==d[0]&&(d=[]),e=e.split("-"),e=e.map(function(a){a=a.split(":");var b={color:a[0]};return a[1]&&(b.offset=parseFloat(a[1])),b}),{type:c,params:d,stops:e}}),b.on("snap.util.attr.d",function(c){b.stop(),m(c,"array")&&m(c[0],"array")&&(c=a.path.toString.call(c)),c=r(c),c.match(/[ruo]/i)&&(c=a.path.toAbsolute(c)),p(this.node,{d:c})})(-1),b.on("snap.util.attr.#text",function(a){b.stop(),a=r(a);for(var c=e.doc.createTextNode(a);this.node.firstChild;)this.node.removeChild(this.node.firstChild);this.node.appendChild(c)})(-1),b.on("snap.util.attr.path",function(a){b.stop(),this.attr({d:a})})(-1),b.on("snap.util.attr.class",function(a){b.stop(),this.node.className.baseVal=a})(-1),b.on("snap.util.attr.viewBox",function(a){var c;c=m(a,"object")&&"x"in a?[a.x,a.y,a.width,a.height].join(" "):m(a,"array")?a.join(" "):a,p(this.node,{viewBox:c}),b.stop()})(-1),b.on("snap.util.attr.transform",function(a){this.transform(a),b.stop()})(-1),b.on("snap.util.attr.r",function(a){"rect"==this.type&&(b.stop(),p(this.node,{rx:a,ry:a}))})(-1),b.on("snap.util.attr.textpath",function(a){if(b.stop(),"text"==this.type){var d,e,f;if(!a&&this.textPath){for(e=this.textPath;e.node.firstChild;)this.node.appendChild(e.node.firstChild);return e.remove(),void delete this.textPath}if(m(a,"string")){var g=n(this),h=l(g.parentNode).path(a);g.appendChild(h.node),d=h.id,h.attr({id:d})}else a=l(a),a instanceof c&&(d=a.attr("id"),d||(d=a.id,a.attr({id:d})));if(d)if(e=this.textPath,f=this.node,e)e.attr({"xlink:href":"#"+d});else{for(e=p("textPath",{"xlink:href":"#"+d});f.firstChild;)e.appendChild(f.firstChild);f.appendChild(e),this.textPath=l(e)}}})(-1),b.on("snap.util.attr.text",function(a){if("text"==this.type){for(var c=this.node,d=function(a){var b=p("tspan");if(m(a,"array"))for(var c=0;c<a.length;c++)b.appendChild(d(a[c]));else b.appendChild(e.doc.createTextNode(a));return b.normalize&&b.normalize(),b};c.firstChild;)c.removeChild(c.firstChild);for(var f=d(a);f.firstChild;)c.appendChild(f.firstChild)}b.stop()})(-1),b.on("snap.util.attr.fontSize",h)(-1),b.on("snap.util.attr.font-size",h)(-1),b.on("snap.util.getattr.transform",function(){return b.stop(),this.transform()})(-1),b.on("snap.util.getattr.textpath",function(){return b.stop(),this.textPath})(-1),function(){function c(c){return function(){b.stop();var d=e.doc.defaultView.getComputedStyle(this.node,null).getPropertyValue("marker-"+c);return"none"==d?d:a(e.doc.getElementById(d.match(o)[1]))}}function d(a){return function(c){b.stop();var d="marker"+a.charAt(0).toUpperCase()+a.substring(1);if(""==c||!c)return void(this.node.style[d]="none");if("marker"==c.type){var e=c.node.id;return e||p(c.node,{id:c.id}),void(this.node.style[d]=q(e))}}}b.on("snap.util.getattr.marker-end",c("end"))(-1),b.on("snap.util.getattr.markerEnd",c("end"))(-1),b.on("snap.util.getattr.marker-start",c("start"))(-1),b.on("snap.util.getattr.markerStart",c("start"))(-1),b.on("snap.util.getattr.marker-mid",c("mid"))(-1),b.on("snap.util.getattr.markerMid",c("mid"))(-1),b.on("snap.util.attr.marker-end",d("end"))(-1),b.on("snap.util.attr.markerEnd",d("end"))(-1),b.on("snap.util.attr.marker-start",d("start"))(-1),b.on("snap.util.attr.markerStart",d("start"))(-1),b.on("snap.util.attr.marker-mid",d("mid"))(-1),b.on("snap.util.attr.markerMid",d("mid"))(-1)}(),b.on("snap.util.getattr.r",function(){return"rect"==this.type&&p(this.node,"rx")==p(this.node,"ry")?(b.stop(),p(this.node,"rx")):void 0})(-1),b.on("snap.util.getattr.text",function(){if("text"==this.type||"tspan"==this.type){b.stop();var a=i(this.node);return 1==a.length?a[0]:a}})(-1),b.on("snap.util.getattr.#text",function(){return this.node.textContent})(-1),b.on("snap.util.getattr.viewBox",function(){b.stop();var c=p(this.node,"viewBox");return c?(c=c.split(s),a._.box(+c[0],+c[1],+c[2],+c[3])):void 0})(-1),b.on("snap.util.getattr.points",function(){var a=p(this.node,"points");return b.stop(),a?a.split(s):void 0})(-1),b.on("snap.util.getattr.path",function(){var a=p(this.node,"d");return b.stop(),a})(-1),b.on("snap.util.getattr.class",function(){return this.node.className.baseVal})(-1),b.on("snap.util.getattr.fontSize",j)(-1),b.on("snap.util.getattr.font-size",j)(-1)}),d.plugin(function(a,b){var c=/\S+/g,d=String,e=b.prototype;e.addClass=function(a){var b,e,f,g,h=d(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];if(h.length){for(b=0;f=h[b++];)e=k.indexOf(f),~e||k.push(f);g=k.join(" "),j!=g&&(i.className.baseVal=g)}return this},e.removeClass=function(a){var b,e,f,g,h=d(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];if(k.length){for(b=0;f=h[b++];)e=k.indexOf(f),~e&&k.splice(e,1);g=k.join(" "),j!=g&&(i.className.baseVal=g)}return this},e.hasClass=function(a){var b=this.node,d=b.className.baseVal,e=d.match(c)||[];return!!~e.indexOf(a)},e.toggleClass=function(a,b){if(null!=b)return b?this.addClass(a):this.removeClass(a);var d,e,f,g,h=(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];for(d=0;f=h[d++];)e=k.indexOf(f),~e?k.splice(e,1):k.push(f);return g=k.join(" "),j!=g&&(i.className.baseVal=g),this}}),d.plugin(function(){function a(a){return a}function c(a){return function(b){return+b.toFixed(3)+a}}var d={"+":function(a,b){return a+b},"-":function(a,b){return a-b},"/":function(a,b){return a/b},"*":function(a,b){return a*b}},e=String,f=/[a-z]+$/i,g=/^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;b.on("snap.util.attr",function(a){var c=e(a).match(g);if(c){var h=b.nt(),i=h.substring(h.lastIndexOf(".")+1),j=this.attr(i),k={};b.stop();var l=c[3]||"",m=j.match(f),n=d[c[1]];if(m&&m==l?a=n(parseFloat(j),+c[2]):(j=this.asPX(i),a=n(this.asPX(i),this.asPX(i,c[2]+l))),isNaN(j)||isNaN(a))return;k[i]=a,this.attr(k)}})(-10),b.on("snap.util.equal",function(h,i){var j=e(this.attr(h)||""),k=e(i).match(g);if(k){b.stop();var l=k[3]||"",m=j.match(f),n=d[k[1]];return m&&m==l?{from:parseFloat(j),to:n(parseFloat(j),+k[2]),f:c(m)}:(j=this.asPX(h),{from:j,to:n(j,this.asPX(h,k[2]+l)),f:a})}})(-10)}),d.plugin(function(c,d,e,f){var g=e.prototype,h=c.is;g.rect=function(a,b,c,d,e,f){var g;return null==f&&(f=e),h(a,"object")&&"[object Object]"==a?g=a:null!=a&&(g={x:a,y:b,width:c,height:d},null!=e&&(g.rx=e,g.ry=f)),this.el("rect",g)},g.circle=function(a,b,c){var d;return h(a,"object")&&"[object Object]"==a?d=a:null!=a&&(d={cx:a,cy:b,r:c}),this.el("circle",d)};var i=function(){function a(){this.parentNode.removeChild(this)}return function(b,c){var d=f.doc.createElement("img"),e=f.doc.body;d.style.cssText="position:absolute;left:-9999em;top:-9999em",d.onload=function(){c.call(d),d.onload=d.onerror=null,e.removeChild(d)},d.onerror=a,e.appendChild(d),d.src=b}}();g.image=function(a,b,d,e,f){var g=this.el("image");if(h(a,"object")&&"src"in a)g.attr(a);else if(null!=a){var j={"xlink:href":a,preserveAspectRatio:"none"};null!=b&&null!=d&&(j.x=b,j.y=d),null!=e&&null!=f?(j.width=e,j.height=f):i(a,function(){c._.$(g.node,{width:this.offsetWidth,height:this.offsetHeight})}),c._.$(g.node,j)}return g},g.ellipse=function(a,b,c,d){var e;return h(a,"object")&&"[object Object]"==a?e=a:null!=a&&(e={cx:a,cy:b,rx:c,ry:d}),this.el("ellipse",e)},g.path=function(a){var b;return h(a,"object")&&!h(a,"array")?b=a:a&&(b={d:a}),this.el("path",b)},g.group=g.g=function(a){var b=this.el("g");return 1==arguments.length&&a&&!a.type?b.attr(a):arguments.length&&b.add(Array.prototype.slice.call(arguments,0)),b},g.svg=function(a,b,c,d,e,f,g,i){var j={};return h(a,"object")&&null==b?j=a:(null!=a&&(j.x=a),null!=b&&(j.y=b),null!=c&&(j.width=c),null!=d&&(j.height=d),null!=e&&null!=f&&null!=g&&null!=i&&(j.viewBox=[e,f,g,i])),this.el("svg",j)},g.mask=function(a){var b=this.el("mask");return 1==arguments.length&&a&&!a.type?b.attr(a):arguments.length&&b.add(Array.prototype.slice.call(arguments,0)),b},g.ptrn=function(a,b,c,d,e,f,g,i){if(h(a,"object"))var j=a;else j={patternUnits:"userSpaceOnUse"},a&&(j.x=a),b&&(j.y=b),null!=c&&(j.width=c),null!=d&&(j.height=d),j.viewBox=null!=e&&null!=f&&null!=g&&null!=i?[e,f,g,i]:[a||0,b||0,c||0,d||0];return this.el("pattern",j)},g.use=function(a){return null!=a?(a instanceof d&&(a.attr("id")||a.attr({id:c._.id(a)}),a=a.attr("id")),"#"==String(a).charAt()&&(a=a.substring(1)),this.el("use",{"xlink:href":"#"+a})):d.prototype.use.call(this)},g.symbol=function(a,b,c,d){var e={};return null!=a&&null!=b&&null!=c&&null!=d&&(e.viewBox=[a,b,c,d]),this.el("symbol",e)},g.text=function(a,b,c){var d={};return h(a,"object")?d=a:null!=a&&(d={x:a,y:b,text:c||""}),this.el("text",d)},g.line=function(a,b,c,d){var e={};return h(a,"object")?e=a:null!=a&&(e={x1:a,x2:c,y1:b,y2:d}),this.el("line",e)},g.polyline=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b={};return h(a,"object")&&!h(a,"array")?b=a:null!=a&&(b={points:a}),this.el("polyline",b)},g.polygon=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b={};return h(a,"object")&&!h(a,"array")?b=a:null!=a&&(b={points:a}),this.el("polygon",b)},function(){function d(){return this.selectAll("stop")}function e(a,b){var d=k("stop"),e={offset:+b+"%"};return a=c.color(a),e["stop-color"]=a.hex,a.opacity<1&&(e["stop-opacity"]=a.opacity),k(d,e),this.node.appendChild(d),this}function f(){if("linearGradient"==this.type){var a=k(this.node,"x1")||0,b=k(this.node,"x2")||1,d=k(this.node,"y1")||0,e=k(this.node,"y2")||0;return c._.box(a,d,math.abs(b-a),math.abs(e-d))}var f=this.node.cx||.5,g=this.node.cy||.5,h=this.node.r||0;return c._.box(f-h,g-h,2*h,2*h)}function h(a,c){function d(a,b){for(var c=(b-l)/(a-m),d=m;a>d;d++)g[d].offset=+(+l+c*(d-m)).toFixed(2);m=a,l=b}var e,f=b("snap.util.grad.parse",null,c).firstDefined();if(!f)return null;f.params.unshift(a),e="l"==f.type.toLowerCase()?i.apply(0,f.params):j.apply(0,f.params),f.type!=f.type.toLowerCase()&&k(e.node,{gradientUnits:"userSpaceOnUse"});var g=f.stops,h=g.length,l=0,m=0;h--;for(var n=0;h>n;n++)"offset"in g[n]&&d(n,g[n].offset);for(g[h].offset=g[h].offset||100,d(h,g[h].offset),n=0;h>=n;n++){var o=g[n];e.addStop(o.color,o.offset)}return e}function i(a,b,g,h,i){var j=c._.make("linearGradient",a);return j.stops=d,j.addStop=e,j.getBBox=f,null!=b&&k(j.node,{x1:b,y1:g,x2:h,y2:i}),j}function j(a,b,g,h,i,j){var l=c._.make("radialGradient",a);return l.stops=d,l.addStop=e,l.getBBox=f,null!=b&&k(l.node,{cx:b,cy:g,r:h}),null!=i&&null!=j&&k(l.node,{fx:i,fy:j}),l}var k=c._.$;g.gradient=function(a){return h(this.defs,a)},g.gradientLinear=function(a,b,c,d){return i(this.defs,a,b,c,d)},g.gradientRadial=function(a,b,c,d,e){return j(this.defs,a,b,c,d,e)},g.toString=function(){var a,b=this.node.ownerDocument,d=b.createDocumentFragment(),e=b.createElement("div"),f=this.node.cloneNode(!0);return d.appendChild(e),e.appendChild(f),c._.$(f,{xmlns:"http://www.w3.org/2000/svg"}),a=e.innerHTML,d.removeChild(d.firstChild),a},g.toDataURL=function(){return a&&a.btoa?"data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(this))):void 0},g.clear=function(){for(var a,b=this.node.firstChild;b;)a=b.nextSibling,"defs"!=b.tagName?b.parentNode.removeChild(b):g.clear.call({node:b}),b=a}}()}),d.plugin(function(a,b){function c(a){var b=c.ps=c.ps||{};return b[a]?b[a].sleep=100:b[a]={sleep:100},setTimeout(function(){for(var c in b)b[K](c)&&c!=a&&(b[c].sleep--,!b[c].sleep&&delete b[c])}),b[a]}function d(a,b,c,d){return null==a&&(a=b=c=d=0),null==b&&(b=a.y,c=a.width,d=a.height,a=a.x),{x:a,y:b,width:c,w:c,height:d,h:d,x2:a+c,y2:b+d,cx:a+c/2,cy:b+d/2,r1:N.min(c,d)/2,r2:N.max(c,d)/2,r0:N.sqrt(c*c+d*d)/2,path:w(a,b,c,d),vb:[a,b,c,d].join(" ")}}function e(){return this.join(",").replace(L,"$1")}function f(a){var b=J(a);return b.toString=e,b}function g(a,b,c,d,e,f,g,h,j){return null==j?n(a,b,c,d,e,f,g,h):i(a,b,c,d,e,f,g,h,o(a,b,c,d,e,f,g,h,j))}function h(c,d){function e(a){return+(+a).toFixed(3)}return a._.cacher(function(a,f,h){a instanceof b&&(a=a.attr("d")),a=E(a);for(var j,k,l,m,n,o="",p={},q=0,r=0,s=a.length;s>r;r++){if(l=a[r],"M"==l[0])j=+l[1],k=+l[2];else{if(m=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6]),q+m>f){if(d&&!p.start){if(n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q),o+=["C"+e(n.start.x),e(n.start.y),e(n.m.x),e(n.m.y),e(n.x),e(n.y)],h)return o;p.start=o,o=["M"+e(n.x),e(n.y)+"C"+e(n.n.x),e(n.n.y),e(n.end.x),e(n.end.y),e(l[5]),e(l[6])].join(),q+=m,j=+l[5],k=+l[6];continue}if(!c&&!d)return n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q)}q+=m,j=+l[5],k=+l[6]}o+=l.shift()+l}return p.end=o,n=c?q:d?p:i(j,k,l[0],l[1],l[2],l[3],l[4],l[5],1)},null,a._.clone)}function i(a,b,c,d,e,f,g,h,i){var j=1-i,k=R(j,3),l=R(j,2),m=i*i,n=m*i,o=k*a+3*l*i*c+3*j*i*i*e+n*g,p=k*b+3*l*i*d+3*j*i*i*f+n*h,q=a+2*i*(c-a)+m*(e-2*c+a),r=b+2*i*(d-b)+m*(f-2*d+b),s=c+2*i*(e-c)+m*(g-2*e+c),t=d+2*i*(f-d)+m*(h-2*f+d),u=j*a+i*c,v=j*b+i*d,w=j*e+i*g,x=j*f+i*h,y=90-180*N.atan2(q-s,r-t)/O;return{x:o,y:p,m:{x:q,y:r},n:{x:s,y:t},start:{x:u,y:v},end:{x:w,y:x},alpha:y}}function j(b,c,e,f,g,h,i,j){a.is(b,"array")||(b=[b,c,e,f,g,h,i,j]);var k=D.apply(null,b);return d(k.min.x,k.min.y,k.max.x-k.min.x,k.max.y-k.min.y)}function k(a,b,c){return b>=a.x&&b<=a.x+a.width&&c>=a.y&&c<=a.y+a.height}function l(a,b){return a=d(a),b=d(b),k(b,a.x,a.y)||k(b,a.x2,a.y)||k(b,a.x,a.y2)||k(b,a.x2,a.y2)||k(a,b.x,b.y)||k(a,b.x2,b.y)||k(a,b.x,b.y2)||k(a,b.x2,b.y2)||(a.x<b.x2&&a.x>b.x||b.x<a.x2&&b.x>a.x)&&(a.y<b.y2&&a.y>b.y||b.y<a.y2&&b.y>a.y)}function m(a,b,c,d,e){var f=-3*b+9*c-9*d+3*e,g=a*f+6*b-12*c+6*d;return a*g-3*b+3*c}function n(a,b,c,d,e,f,g,h,i){null==i&&(i=1),i=i>1?1:0>i?0:i;for(var j=i/2,k=12,l=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],n=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],o=0,p=0;k>p;p++){var q=j*l[p]+j,r=m(q,a,c,e,g),s=m(q,b,d,f,h),t=r*r+s*s;o+=n[p]*N.sqrt(t)}return j*o}function o(a,b,c,d,e,f,g,h,i){if(!(0>i||n(a,b,c,d,e,f,g,h)<i)){var j,k=1,l=k/2,m=k-l,o=.01;for(j=n(a,b,c,d,e,f,g,h,m);S(j-i)>o;)l/=2,m+=(i>j?1:-1)*l,j=n(a,b,c,d,e,f,g,h,m);return m}}function p(a,b,c,d,e,f,g,h){if(!(Q(a,c)<P(e,g)||P(a,c)>Q(e,g)||Q(b,d)<P(f,h)||P(b,d)>Q(f,h))){var i=(a*d-b*c)*(e-g)-(a-c)*(e*h-f*g),j=(a*d-b*c)*(f-h)-(b-d)*(e*h-f*g),k=(a-c)*(f-h)-(b-d)*(e-g);if(k){var l=i/k,m=j/k,n=+l.toFixed(2),o=+m.toFixed(2);if(!(n<+P(a,c).toFixed(2)||n>+Q(a,c).toFixed(2)||n<+P(e,g).toFixed(2)||n>+Q(e,g).toFixed(2)||o<+P(b,d).toFixed(2)||o>+Q(b,d).toFixed(2)||o<+P(f,h).toFixed(2)||o>+Q(f,h).toFixed(2)))return{x:l,y:m}}}}function q(a,b,c){var d=j(a),e=j(b);if(!l(d,e))return c?0:[];for(var f=n.apply(0,a),g=n.apply(0,b),h=~~(f/8),k=~~(g/8),m=[],o=[],q={},r=c?0:[],s=0;h+1>s;s++){var t=i.apply(0,a.concat(s/h));m.push({x:t.x,y:t.y,t:s/h})}for(s=0;k+1>s;s++)t=i.apply(0,b.concat(s/k)),o.push({x:t.x,y:t.y,t:s/k});for(s=0;h>s;s++)for(var u=0;k>u;u++){var v=m[s],w=m[s+1],x=o[u],y=o[u+1],z=S(w.x-v.x)<.001?"y":"x",A=S(y.x-x.x)<.001?"y":"x",B=p(v.x,v.y,w.x,w.y,x.x,x.y,y.x,y.y);if(B){if(q[B.x.toFixed(4)]==B.y.toFixed(4))continue;q[B.x.toFixed(4)]=B.y.toFixed(4);var C=v.t+S((B[z]-v[z])/(w[z]-v[z]))*(w.t-v.t),D=x.t+S((B[A]-x[A])/(y[A]-x[A]))*(y.t-x.t);C>=0&&1>=C&&D>=0&&1>=D&&(c?r++:r.push({x:B.x,y:B.y,t1:C,t2:D}))}}return r}function r(a,b){return t(a,b)}function s(a,b){return t(a,b,1)}function t(a,b,c){a=E(a),b=E(b);for(var d,e,f,g,h,i,j,k,l,m,n=c?0:[],o=0,p=a.length;p>o;o++){var r=a[o];if("M"==r[0])d=h=r[1],e=i=r[2];else{"C"==r[0]?(l=[d,e].concat(r.slice(1)),d=l[6],e=l[7]):(l=[d,e,d,e,h,i,h,i],d=h,e=i);for(var s=0,t=b.length;t>s;s++){var u=b[s];if("M"==u[0])f=j=u[1],g=k=u[2];else{"C"==u[0]?(m=[f,g].concat(u.slice(1)),f=m[6],g=m[7]):(m=[f,g,f,g,j,k,j,k],f=j,g=k);var v=q(l,m,c);if(c)n+=v;else{for(var w=0,x=v.length;x>w;w++)v[w].segment1=o,v[w].segment2=s,v[w].bez1=l,v[w].bez2=m;n=n.concat(v)}}}}}return n}function u(a,b,c){var d=v(a);return k(d,b,c)&&t(a,[["M",b,c],["H",d.x2+10]],1)%2==1}function v(a){var b=c(a);if(b.bbox)return J(b.bbox);if(!a)return d();a=E(a);for(var e,f=0,g=0,h=[],i=[],j=0,k=a.length;k>j;j++)if(e=a[j],"M"==e[0])f=e[1],g=e[2],h.push(f),i.push(g);else{var l=D(f,g,e[1],e[2],e[3],e[4],e[5],e[6]);h=h.concat(l.min.x,l.max.x),i=i.concat(l.min.y,l.max.y),f=e[5],g=e[6]}var m=P.apply(0,h),n=P.apply(0,i),o=Q.apply(0,h),p=Q.apply(0,i),q=d(m,n,o-m,p-n);return b.bbox=J(q),q}function w(a,b,c,d,f){if(f)return[["M",+a+ +f,b],["l",c-2*f,0],["a",f,f,0,0,1,f,f],["l",0,d-2*f],["a",f,f,0,0,1,-f,f],["l",2*f-c,0],["a",f,f,0,0,1,-f,-f],["l",0,2*f-d],["a",f,f,0,0,1,f,-f],["z"]];var g=[["M",a,b],["l",c,0],["l",0,d],["l",-c,0],["z"]];return g.toString=e,g}function x(a,b,c,d,f){if(null==f&&null==d&&(d=c),a=+a,b=+b,c=+c,d=+d,null!=f)var g=Math.PI/180,h=a+c*Math.cos(-d*g),i=a+c*Math.cos(-f*g),j=b+c*Math.sin(-d*g),k=b+c*Math.sin(-f*g),l=[["M",h,j],["A",c,c,0,+(f-d>180),0,i,k]];else l=[["M",a,b],["m",0,-d],["a",c,d,0,1,1,0,2*d],["a",c,d,0,1,1,0,-2*d],["z"]];return l.toString=e,l}function y(b){var d=c(b),g=String.prototype.toLowerCase;if(d.rel)return f(d.rel);a.is(b,"array")&&a.is(b&&b[0],"array")||(b=a.parsePathString(b));var h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=b[0][1],j=b[0][2],k=i,l=j,m++,h.push(["M",i,j]));for(var n=m,o=b.length;o>n;n++){var p=h[n]=[],q=b[n];if(q[0]!=g.call(q[0]))switch(p[0]=g.call(q[0]),p[0]){case"a":p[1]=q[1],p[2]=q[2],p[3]=q[3],p[4]=q[4],p[5]=q[5],p[6]=+(q[6]-i).toFixed(3),p[7]=+(q[7]-j).toFixed(3);break;case"v":p[1]=+(q[1]-j).toFixed(3);break;case"m":k=q[1],l=q[2];default:for(var r=1,s=q.length;s>r;r++)p[r]=+(q[r]-(r%2?i:j)).toFixed(3)}else{p=h[n]=[],"m"==q[0]&&(k=q[1]+i,l=q[2]+j);for(var t=0,u=q.length;u>t;t++)h[n][t]=q[t]}var v=h[n].length;switch(h[n][0]){case"z":i=k,j=l;break;case"h":i+=+h[n][v-1];break;case"v":j+=+h[n][v-1];break;default:i+=+h[n][v-2],j+=+h[n][v-1]}}return h.toString=e,d.rel=f(h),h}function z(b){var d=c(b);if(d.abs)return f(d.abs);if(I(b,"array")&&I(b&&b[0],"array")||(b=a.parsePathString(b)),!b||!b.length)return[["M",0,0]];var g,h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=+b[0][1],j=+b[0][2],k=i,l=j,m++,h[0]=["M",i,j]);for(var n,o,p=3==b.length&&"M"==b[0][0]&&"R"==b[1][0].toUpperCase()&&"Z"==b[2][0].toUpperCase(),q=m,r=b.length;r>q;q++){if(h.push(n=[]),o=b[q],g=o[0],g!=g.toUpperCase())switch(n[0]=g.toUpperCase(),n[0]){case"A":n[1]=o[1],n[2]=o[2],n[3]=o[3],n[4]=o[4],n[5]=o[5],n[6]=+o[6]+i,n[7]=+o[7]+j;break;case"V":n[1]=+o[1]+j;break;case"H":n[1]=+o[1]+i;break;case"R":for(var s=[i,j].concat(o.slice(1)),t=2,u=s.length;u>t;t++)s[t]=+s[t]+i,s[++t]=+s[t]+j;h.pop(),h=h.concat(G(s,p));break;case"O":h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);break;case"U":h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));break;case"M":k=+o[1]+i,l=+o[2]+j;default:for(t=1,u=o.length;u>t;t++)n[t]=+o[t]+(t%2?i:j)}else if("R"==g)s=[i,j].concat(o.slice(1)),h.pop(),h=h.concat(G(s,p)),n=["R"].concat(o.slice(-2));else if("O"==g)h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);else if("U"==g)h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));else for(var v=0,w=o.length;w>v;v++)n[v]=o[v];if(g=g.toUpperCase(),"O"!=g)switch(n[0]){case"Z":i=+k,j=+l;break;case"H":i=n[1];break;case"V":j=n[1];break;case"M":k=n[n.length-2],l=n[n.length-1];default:i=n[n.length-2],j=n[n.length-1]}}return h.toString=e,d.abs=f(h),h}function A(a,b,c,d){return[a,b,c,d,c,d]}function B(a,b,c,d,e,f){var g=1/3,h=2/3;return[g*a+h*c,g*b+h*d,g*e+h*c,g*f+h*d,e,f]}function C(b,c,d,e,f,g,h,i,j,k){var l,m=120*O/180,n=O/180*(+f||0),o=[],p=a._.cacher(function(a,b,c){var d=a*N.cos(c)-b*N.sin(c),e=a*N.sin(c)+b*N.cos(c);return{x:d,y:e}});if(k)y=k[0],z=k[1],w=k[2],x=k[3];else{l=p(b,c,-n),b=l.x,c=l.y,l=p(i,j,-n),i=l.x,j=l.y;var q=(N.cos(O/180*f),N.sin(O/180*f),(b-i)/2),r=(c-j)/2,s=q*q/(d*d)+r*r/(e*e);s>1&&(s=N.sqrt(s),d=s*d,e=s*e);var t=d*d,u=e*e,v=(g==h?-1:1)*N.sqrt(S((t*u-t*r*r-u*q*q)/(t*r*r+u*q*q))),w=v*d*r/e+(b+i)/2,x=v*-e*q/d+(c+j)/2,y=N.asin(((c-x)/e).toFixed(9)),z=N.asin(((j-x)/e).toFixed(9));y=w>b?O-y:y,z=w>i?O-z:z,0>y&&(y=2*O+y),0>z&&(z=2*O+z),h&&y>z&&(y-=2*O),!h&&z>y&&(z-=2*O)}var A=z-y;if(S(A)>m){var B=z,D=i,E=j;z=y+m*(h&&z>y?1:-1),i=w+d*N.cos(z),j=x+e*N.sin(z),o=C(i,j,d,e,f,0,h,D,E,[z,B,w,x])}A=z-y;var F=N.cos(y),G=N.sin(y),H=N.cos(z),I=N.sin(z),J=N.tan(A/4),K=4/3*d*J,L=4/3*e*J,M=[b,c],P=[b+K*G,c-L*F],Q=[i+K*I,j-L*H],R=[i,j];if(P[0]=2*M[0]-P[0],P[1]=2*M[1]-P[1],k)return[P,Q,R].concat(o);o=[P,Q,R].concat(o).join().split(",");for(var T=[],U=0,V=o.length;V>U;U++)T[U]=U%2?p(o[U-1],o[U],n).y:p(o[U],o[U+1],n).x;return T}function D(a,b,c,d,e,f,g,h){for(var i,j,k,l,m,n,o,p,q=[],r=[[],[]],s=0;2>s;++s)if(0==s?(j=6*a-12*c+6*e,i=-3*a+9*c-9*e+3*g,k=3*c-3*a):(j=6*b-12*d+6*f,i=-3*b+9*d-9*f+3*h,k=3*d-3*b),S(i)<1e-12){if(S(j)<1e-12)continue;l=-k/j,l>0&&1>l&&q.push(l)}else o=j*j-4*k*i,p=N.sqrt(o),0>o||(m=(-j+p)/(2*i),m>0&&1>m&&q.push(m),n=(-j-p)/(2*i),n>0&&1>n&&q.push(n));for(var t,u=q.length,v=u;u--;)l=q[u],t=1-l,r[0][u]=t*t*t*a+3*t*t*l*c+3*t*l*l*e+l*l*l*g,r[1][u]=t*t*t*b+3*t*t*l*d+3*t*l*l*f+l*l*l*h;return r[0][v]=a,r[1][v]=b,r[0][v+1]=g,r[1][v+1]=h,r[0].length=r[1].length=v+2,{min:{x:P.apply(0,r[0]),y:P.apply(0,r[1])},max:{x:Q.apply(0,r[0]),y:Q.apply(0,r[1])}}}function E(a,b){var d=!b&&c(a);if(!b&&d.curve)return f(d.curve);for(var e=z(a),g=b&&z(b),h={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},i={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},j=(function(a,b,c){var d,e;if(!a)return["C",b.x,b.y,b.x,b.y,b.x,b.y];switch(!(a[0]in{T:1,Q:1})&&(b.qx=b.qy=null),a[0]){case"M":b.X=a[1],b.Y=a[2];break;case"A":a=["C"].concat(C.apply(0,[b.x,b.y].concat(a.slice(1))));break;case"S":"C"==c||"S"==c?(d=2*b.x-b.bx,e=2*b.y-b.by):(d=b.x,e=b.y),a=["C",d,e].concat(a.slice(1));break;case"T":"Q"==c||"T"==c?(b.qx=2*b.x-b.qx,b.qy=2*b.y-b.qy):(b.qx=b.x,b.qy=b.y),a=["C"].concat(B(b.x,b.y,b.qx,b.qy,a[1],a[2]));break;case"Q":b.qx=a[1],b.qy=a[2],a=["C"].concat(B(b.x,b.y,a[1],a[2],a[3],a[4]));break;case"L":a=["C"].concat(A(b.x,b.y,a[1],a[2]));break;case"H":a=["C"].concat(A(b.x,b.y,a[1],b.y));break;case"V":a=["C"].concat(A(b.x,b.y,b.x,a[1]));break;case"Z":a=["C"].concat(A(b.x,b.y,b.X,b.Y))}return a}),k=function(a,b){if(a[b].length>7){a[b].shift();for(var c=a[b];c.length;)m[b]="A",g&&(n[b]="A"),a.splice(b++,0,["C"].concat(c.splice(0,6)));a.splice(b,1),r=Q(e.length,g&&g.length||0)}},l=function(a,b,c,d,f){a&&b&&"M"==a[f][0]&&"M"!=b[f][0]&&(b.splice(f,0,["M",d.x,d.y]),c.bx=0,c.by=0,c.x=a[f][1],c.y=a[f][2],r=Q(e.length,g&&g.length||0))},m=[],n=[],o="",p="",q=0,r=Q(e.length,g&&g.length||0);r>q;q++){e[q]&&(o=e[q][0]),"C"!=o&&(m[q]=o,q&&(p=m[q-1])),e[q]=j(e[q],h,p),"A"!=m[q]&&"C"==o&&(m[q]="C"),k(e,q),g&&(g[q]&&(o=g[q][0]),"C"!=o&&(n[q]=o,q&&(p=n[q-1])),g[q]=j(g[q],i,p),"A"!=n[q]&&"C"==o&&(n[q]="C"),k(g,q)),l(e,g,h,i,q),l(g,e,i,h,q);var s=e[q],t=g&&g[q],u=s.length,v=g&&t.length;h.x=s[u-2],h.y=s[u-1],h.bx=M(s[u-4])||h.x,h.by=M(s[u-3])||h.y,i.bx=g&&(M(t[v-4])||i.x),i.by=g&&(M(t[v-3])||i.y),i.x=g&&t[v-2],i.y=g&&t[v-1]}return g||(d.curve=f(e)),g?[e,g]:e}function F(a,b){if(!b)return a;var c,d,e,f,g,h,i;for(a=E(a),e=0,g=a.length;g>e;e++)for(i=a[e],f=1,h=i.length;h>f;f+=2)c=b.x(i[f],i[f+1]),d=b.y(i[f],i[f+1]),i[f]=c,i[f+1]=d;return a}function G(a,b){for(var c=[],d=0,e=a.length;e-2*!b>d;d+=2){var f=[{x:+a[d-2],y:+a[d-1]},{x:+a[d],y:+a[d+1]},{x:+a[d+2],y:+a[d+3]},{x:+a[d+4],y:+a[d+5]}];b?d?e-4==d?f[3]={x:+a[0],y:+a[1]}:e-2==d&&(f[2]={x:+a[0],y:+a[1]},f[3]={x:+a[2],y:+a[3]}):f[0]={x:+a[e-2],y:+a[e-1]}:e-4==d?f[3]=f[2]:d||(f[0]={x:+a[d],y:+a[d+1]}),c.push(["C",(-f[0].x+6*f[1].x+f[2].x)/6,(-f[0].y+6*f[1].y+f[2].y)/6,(f[1].x+6*f[2].x-f[3].x)/6,(f[1].y+6*f[2].y-f[3].y)/6,f[2].x,f[2].y])}return c}var H=b.prototype,I=a.is,J=a._.clone,K="hasOwnProperty",L=/,?([a-z]),?/gi,M=parseFloat,N=Math,O=N.PI,P=N.min,Q=N.max,R=N.pow,S=N.abs,T=h(1),U=h(),V=h(0,1),W=a._unit2px,X={path:function(a){return a.attr("path")},circle:function(a){var b=W(a);return x(b.cx,b.cy,b.r)},ellipse:function(a){var b=W(a);return x(b.cx||0,b.cy||0,b.rx,b.ry)},rect:function(a){var b=W(a);return w(b.x||0,b.y||0,b.width,b.height,b.rx,b.ry)},image:function(a){var b=W(a);return w(b.x||0,b.y||0,b.width,b.height)},line:function(a){return"M"+[a.attr("x1")||0,a.attr("y1")||0,a.attr("x2"),a.attr("y2")]},polyline:function(a){return"M"+a.attr("points")},polygon:function(a){return"M"+a.attr("points")+"z"},deflt:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)}};a.path=c,a.path.getTotalLength=T,a.path.getPointAtLength=U,a.path.getSubpath=function(a,b,c){if(this.getTotalLength(a)-c<1e-6)return V(a,b).end;var d=V(a,c,1);return b?V(d,b).end:d},H.getTotalLength=function(){return this.node.getTotalLength?this.node.getTotalLength():void 0},H.getPointAtLength=function(a){return U(this.attr("d"),a)},H.getSubpath=function(b,c){return a.path.getSubpath(this.attr("d"),b,c)},a._.box=d,a.path.findDotsAtSegment=i,a.path.bezierBBox=j,a.path.isPointInsideBBox=k,a.closest=function(b,c,e,f){for(var g=100,h=d(b-g/2,c-g/2,g,g),i=[],j=e[0].hasOwnProperty("x")?function(a){return{x:e[a].x,y:e[a].y}}:function(a){return{x:e[a],y:f[a]}},l=0;1e6>=g&&!l;){for(var m=0,n=e.length;n>m;m++){var o=j(m);if(k(h,o.x,o.y)){l++,i.push(o);break}}l||(g*=2,h=d(b-g/2,c-g/2,g,g))}if(1e6!=g){var p,q=1/0;for(m=0,n=i.length;n>m;m++){var r=a.len(b,c,i[m].x,i[m].y);q>r&&(q=r,i[m].len=r,p=i[m])}return p}},a.path.isBBoxIntersect=l,a.path.intersection=r,a.path.intersectionNumber=s,a.path.isPointInside=u,a.path.getBBox=v,a.path.get=X,a.path.toRelative=y,a.path.toAbsolute=z,a.path.toCubic=E,a.path.map=F,a.path.toString=e,a.path.clone=f}),d.plugin(function(a){var d=Math.max,e=Math.min,f=function(a){if(this.items=[],this.bindings={},this.length=0,this.type="set",a)for(var b=0,c=a.length;c>b;b++)a[b]&&(this[this.items.length]=this.items[this.items.length]=a[b],this.length++)},g=f.prototype;g.push=function(){for(var a,b,c=0,d=arguments.length;d>c;c++)a=arguments[c],a&&(b=this.items.length,this[b]=this.items[b]=a,this.length++);return this},g.pop=function(){return this.length&&delete this[this.length--],this.items.pop()},g.forEach=function(a,b){for(var c=0,d=this.items.length;d>c;c++)if(a.call(b,this.items[c],c)===!1)return this;return this},g.animate=function(d,e,f,g){"function"!=typeof f||f.length||(g=f,f=c.linear),d instanceof a._.Animation&&(g=d.callback,f=d.easing,e=f.dur,d=d.attr);var h=arguments;if(a.is(d,"array")&&a.is(h[h.length-1],"array"))var i=!0;var j,k=function(){j?this.b=j:j=this.b},l=0,m=this,n=g&&function(){++l==m.length&&g.call(this)
		};return this.forEach(function(a,c){b.once("snap.animcreated."+a.id,k),i?h[c]&&a.animate.apply(a,h[c]):a.animate(d,e,f,n)})},g.remove=function(){for(;this.length;)this.pop().remove();return this},g.bind=function(a,b,c){var d={};if("function"==typeof b)this.bindings[a]=b;else{var e=c||a;this.bindings[a]=function(a){d[e]=a,b.attr(d)}}return this},g.attr=function(a){var b={};for(var c in a)this.bindings[c]?this.bindings[c](a[c]):b[c]=a[c];for(var d=0,e=this.items.length;e>d;d++)this.items[d].attr(b);return this},g.clear=function(){for(;this.length;)this.pop()},g.splice=function(a,b){a=0>a?d(this.length+a,0):a,b=d(0,e(this.length-a,b));var c,g=[],h=[],i=[];for(c=2;c<arguments.length;c++)i.push(arguments[c]);for(c=0;b>c;c++)h.push(this[a+c]);for(;c<this.length-a;c++)g.push(this[a+c]);var j=i.length;for(c=0;c<j+g.length;c++)this.items[a+c]=this[a+c]=j>c?i[c]:g[c-j];for(c=this.items.length=this.length-=b-j;this[c];)delete this[c++];return new f(h)},g.exclude=function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]==a)return this.splice(b,1),!0;return!1},g.insertAfter=function(a){for(var b=this.items.length;b--;)this.items[b].insertAfter(a);return this},g.getBBox=function(){for(var a=[],b=[],c=[],f=[],g=this.items.length;g--;)if(!this.items[g].removed){var h=this.items[g].getBBox();a.push(h.x),b.push(h.y),c.push(h.x+h.width),f.push(h.y+h.height)}return a=e.apply(0,a),b=e.apply(0,b),c=d.apply(0,c),f=d.apply(0,f),{x:a,y:b,x2:c,y2:f,width:c-a,height:f-b,cx:a+(c-a)/2,cy:b+(f-b)/2}},g.clone=function(a){a=new f;for(var b=0,c=this.items.length;c>b;b++)a.push(this.items[b].clone());return a},g.toString=function(){return"Snap‘s set"},g.type="set",a.Set=f,a.set=function(){var a=new f;return arguments.length&&a.push.apply(a,Array.prototype.slice.call(arguments,0)),a}}),d.plugin(function(a,c){function d(a){var b=a[0];switch(b.toLowerCase()){case"t":return[b,0,0];case"m":return[b,1,0,0,1,0,0];case"r":return 4==a.length?[b,0,a[2],a[3]]:[b,0];case"s":return 5==a.length?[b,1,1,a[3],a[4]]:3==a.length?[b,1,1]:[b,1]}}function e(b,c,e){c=p(c).replace(/\.{3}|\u2026/g,b),b=a.parseTransformString(b)||[],c=a.parseTransformString(c)||[];for(var f,g,h,i,l=Math.max(b.length,c.length),m=[],n=[],o=0;l>o;o++){if(h=b[o]||d(c[o]),i=c[o]||d(h),h[0]!=i[0]||"r"==h[0].toLowerCase()&&(h[2]!=i[2]||h[3]!=i[3])||"s"==h[0].toLowerCase()&&(h[3]!=i[3]||h[4]!=i[4])){b=a._.transform2matrix(b,e()),c=a._.transform2matrix(c,e()),m=[["m",b.a,b.b,b.c,b.d,b.e,b.f]],n=[["m",c.a,c.b,c.c,c.d,c.e,c.f]];break}for(m[o]=[],n[o]=[],f=0,g=Math.max(h.length,i.length);g>f;f++)f in h&&(m[o][f]=h[f]),f in i&&(n[o][f]=i[f])}return{from:k(m),to:k(n),f:j(m)}}function f(a){return a}function g(a){return function(b){return+b.toFixed(3)+a}}function h(a){return a.join(" ")}function i(b){return a.rgb(b[0],b[1],b[2])}function j(a){var b,c,d,e,f,g,h=0,i=[];for(b=0,c=a.length;c>b;b++){for(f="[",g=['"'+a[b][0]+'"'],d=1,e=a[b].length;e>d;d++)g[d]="val["+h++ +"]";f+=g+"]",i[b]=f}return Function("val","return Snap.path.toString.call(["+i+"])")}function k(a){for(var b=[],c=0,d=a.length;d>c;c++)for(var e=1,f=a[c].length;f>e;e++)b.push(a[c][e]);return b}function l(a){return isFinite(parseFloat(a))}function m(b,c){return a.is(b,"array")&&a.is(c,"array")?b.toString()==c.toString():!1}var n={},o=/[a-z]+$/i,p=String;n.stroke=n.fill="colour",c.prototype.equal=function(a,c){return b("snap.util.equal",this,a,c).firstDefined()},b.on("snap.util.equal",function(b,c){var d,q,r=p(this.attr(b)||""),s=this;if(l(r)&&l(c))return{from:parseFloat(r),to:parseFloat(c),f:f};if("colour"==n[b])return d=a.color(r),q=a.color(c),{from:[d.r,d.g,d.b,d.opacity],to:[q.r,q.g,q.b,q.opacity],f:i};if("viewBox"==b)return d=this.attr(b).vb.split(" ").map(Number),q=c.split(" ").map(Number),{from:d,to:q,f:h};if("transform"==b||"gradientTransform"==b||"patternTransform"==b)return c instanceof a.Matrix&&(c=c.toTransformString()),a._.rgTransform.test(c)||(c=a._.svgTransform2string(c)),e(r,c,function(){return s.getBBox(1)});if("d"==b||"path"==b)return d=a.path.toCubic(r,c),{from:k(d[0]),to:k(d[1]),f:j(d[0])};if("points"==b)return d=p(r).split(a._.separator),q=p(c).split(a._.separator),{from:d,to:q,f:function(a){return a}};var t=r.match(o),u=p(c).match(o);return t&&m(t,u)?{from:parseFloat(r),to:parseFloat(c),f:g(t)}:{from:this.asPX(b),to:this.asPX(b,c),f:f}})}),d.plugin(function(a,c,d,e){for(var f=c.prototype,g="hasOwnProperty",h=("createTouch"in e.doc),i=["click","dblclick","mousedown","mousemove","mouseout","mouseover","mouseup","touchstart","touchmove","touchend","touchcancel"],j={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},k=(function(a,b){var c="y"==a?"scrollTop":"scrollLeft",d=b&&b.node?b.node.ownerDocument:e.doc;return d[c in d.documentElement?"documentElement":"body"][c]}),l=function(){return this.originalEvent.preventDefault()},m=function(){return this.originalEvent.stopPropagation()},n=function(a,b,c,d){var e=h&&j[b]?j[b]:b,f=function(e){var f=k("y",d),i=k("x",d);if(h&&j[g](b))for(var n=0,o=e.targetTouches&&e.targetTouches.length;o>n;n++)if(e.targetTouches[n].target==a||a.contains(e.targetTouches[n].target)){var p=e;e=e.targetTouches[n],e.originalEvent=p,e.preventDefault=l,e.stopPropagation=m;break}var q=e.clientX+i,r=e.clientY+f;return c.call(d,e,q,r)};return b!==e&&a.addEventListener(b,f,!1),a.addEventListener(e,f,!1),function(){return b!==e&&a.removeEventListener(b,f,!1),a.removeEventListener(e,f,!1),!0}},o=[],p=function(a){for(var c,d=a.clientX,e=a.clientY,f=k("y"),g=k("x"),i=o.length;i--;){if(c=o[i],h){for(var j,l=a.touches&&a.touches.length;l--;)if(j=a.touches[l],j.identifier==c.el._drag.id||c.el.node.contains(j.target)){d=j.clientX,e=j.clientY,(a.originalEvent?a.originalEvent:a).preventDefault();break}}else a.preventDefault();{var m=c.el.node;m.nextSibling,m.parentNode,m.style.display}d+=g,e+=f,b("snap.drag.move."+c.el.id,c.move_scope||c.el,d-c.el._drag.x,e-c.el._drag.y,d,e,a)}},q=function(c){a.unmousemove(p).unmouseup(q);for(var d,e=o.length;e--;)d=o[e],d.el._drag={},b("snap.drag.end."+d.el.id,d.end_scope||d.start_scope||d.move_scope||d.el,c),b.off("snap.drag.*."+d.el.id);o=[]},r=i.length;r--;)!function(b){a[b]=f[b]=function(c,d){if(a.is(c,"function"))this.events=this.events||[],this.events.push({name:b,f:c,unbind:n(this.node||document,b,c,d||this)});else for(var e=0,f=this.events.length;f>e;e++)if(this.events[e].name==b)try{this.events[e].f.call(this)}catch(g){}return this},a["un"+b]=f["un"+b]=function(a){for(var c=this.events||[],d=c.length;d--;)if(c[d].name==b&&(c[d].f==a||!a))return c[d].unbind(),c.splice(d,1),!c.length&&delete this.events,this;return this}}(i[r]);f.hover=function(a,b,c,d){return this.mouseover(a,c).mouseout(b,d||c)},f.unhover=function(a,b){return this.unmouseover(a).unmouseout(b)};var s=[];f.drag=function(c,d,e,f,g,h){function i(i,j,l){(i.originalEvent||i).preventDefault(),k._drag.x=j,k._drag.y=l,k._drag.id=i.identifier,!o.length&&a.mousemove(p).mouseup(q),o.push({el:k,move_scope:f,start_scope:g,end_scope:h}),d&&b.on("snap.drag.start."+k.id,d),c&&b.on("snap.drag.move."+k.id,c),e&&b.on("snap.drag.end."+k.id,e),b("snap.drag.start."+k.id,g||f||k,j,l,i)}function j(a,c,d){b("snap.draginit."+k.id,k,a,c,d)}var k=this;if(!arguments.length){var l;return k.drag(function(a,b){this.attr({transform:l+(l?"T":"t")+[a,b]})},function(){l=this.transform().local})}return b.on("snap.draginit."+k.id,i),k._drag={},s.push({el:k,start:i,init:j}),k.mousedown(j),k},f.undrag=function(){for(var c=s.length;c--;)s[c].el==this&&(this.unmousedown(s[c].init),s.splice(c,1),b.unbind("snap.drag.*."+this.id),b.unbind("snap.draginit."+this.id));return!s.length&&a.unmousemove(p).unmouseup(q),this}}),d.plugin(function(a,c,d){var e=(c.prototype,d.prototype),f=/^\s*url\((.+)\)/,g=String,h=a._.$;a.filter={},e.filter=function(b){var d=this;"svg"!=d.type&&(d=d.paper);var e=a.parse(g(b)),f=a._.id(),i=(d.node.offsetWidth,d.node.offsetHeight,h("filter"));return h(i,{id:f,filterUnits:"userSpaceOnUse"}),i.appendChild(e.node),d.defs.appendChild(i),new c(i)},b.on("snap.util.getattr.filter",function(){b.stop();var c=h(this.node,"filter");if(c){var d=g(c).match(f);return d&&a.select(d[1])}}),b.on("snap.util.attr.filter",function(d){if(d instanceof c&&"filter"==d.type){b.stop();var e=d.node.id;e||(h(d.node,{id:d.id}),e=d.id),h(this.node,{filter:a.url(e)})}d&&"none"!=d||(b.stop(),this.node.removeAttribute("filter"))}),a.filter.blur=function(b,c){null==b&&(b=2);var d=null==c?b:[b,c];return a.format('<feGaussianBlur stdDeviation="{def}"/>',{def:d})},a.filter.blur.toString=function(){return this()},a.filter.shadow=function(b,c,d,e,f){return"string"==typeof d&&(e=d,f=e,d=4),"string"!=typeof e&&(f=e,e="#000"),e=e||"#000",null==d&&(d=4),null==f&&(f=1),null==b&&(b=0,c=2),null==c&&(c=b),e=a.color(e),a.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>',{color:e,dx:b,dy:c,blur:d,opacity:f})},a.filter.shadow.toString=function(){return this()},a.filter.grayscale=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>',{a:.2126+.7874*(1-b),b:.7152-.7152*(1-b),c:.0722-.0722*(1-b),d:.2126-.2126*(1-b),e:.7152+.2848*(1-b),f:.0722-.0722*(1-b),g:.2126-.2126*(1-b),h:.0722+.9278*(1-b)})},a.filter.grayscale.toString=function(){return this()},a.filter.sepia=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>',{a:.393+.607*(1-b),b:.769-.769*(1-b),c:.189-.189*(1-b),d:.349-.349*(1-b),e:.686+.314*(1-b),f:.168-.168*(1-b),g:.272-.272*(1-b),h:.534-.534*(1-b),i:.131+.869*(1-b)})},a.filter.sepia.toString=function(){return this()},a.filter.saturate=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="saturate" values="{amount}"/>',{amount:1-b})},a.filter.saturate.toString=function(){return this()},a.filter.hueRotate=function(b){return b=b||0,a.format('<feColorMatrix type="hueRotate" values="{angle}"/>',{angle:b})},a.filter.hueRotate.toString=function(){return this()},a.filter.invert=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>',{amount:b,amount2:1-b})},a.filter.invert.toString=function(){return this()},a.filter.brightness=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>',{amount:b})},a.filter.brightness.toString=function(){return this()},a.filter.contrast=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>',{amount:b,amount2:.5-b/2})},a.filter.contrast.toString=function(){return this()}}),d.plugin(function(a,b){var c=a._.box,d=a.is,e=/^[^a-z]*([tbmlrc])/i,f=function(){return"T"+this.dx+","+this.dy};b.prototype.getAlign=function(a,b){null==b&&d(a,"string")&&(b=a,a=null),a=a||this.paper;var g=a.getBBox?a.getBBox():c(a),h=this.getBBox(),i={};switch(b=b&&b.match(e),b=b?b[1].toLowerCase():"c"){case"t":i.dx=0,i.dy=g.y-h.y;break;case"b":i.dx=0,i.dy=g.y2-h.y2;break;case"m":i.dx=0,i.dy=g.cy-h.cy;break;case"l":i.dx=g.x-h.x,i.dy=0;break;case"r":i.dx=g.x2-h.x2,i.dy=0;break;default:i.dx=g.cx-h.cx,i.dy=0}return i.toString=f,i},b.prototype.align=function(a,b){return this.transform("..."+this.getAlign(a,b))}}),d});
	
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Snap.svg 0.4.1
		//
		// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		// http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		//
		// build: 2015-04-13
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		// ┌────────────────────────────────────────────────────────────┐ \\
		// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
		// ├────────────────────────────────────────────────────────────┤ \\
		// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
		// └────────────────────────────────────────────────────────────┘ \\
		
		(function (glob) {
		    var version = "0.4.2",
		        has = "hasOwnProperty",
		        separator = /[\.\/]/,
		        comaseparator = /\s*,\s*/,
		        wildcard = "*",
		        fun = function () {},
		        numsort = function (a, b) {
		            return a - b;
		        },
		        current_event,
		        stop,
		        events = {n: {}},
		        firstDefined = function () {
		            for (var i = 0, ii = this.length; i < ii; i++) {
		                if (typeof this[i] != "undefined") {
		                    return this[i];
		                }
		            }
		        },
		        lastDefined = function () {
		            var i = this.length;
		            while (--i) {
		                if (typeof this[i] != "undefined") {
		                    return this[i];
		                }
		            }
		        },
		    /*\
		     * eve
		     [ method ]
		
		     * Fires event with given `name`, given scope and other parameters.
		
		     > Arguments
		
		     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
		     - scope (object) context for the event handlers
		     - varargs (...) the rest of arguments will be sent to event handlers
		
		     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
		    \*/
		        eve = function (name, scope) {
		            name = String(name);
		            var e = events,
		                oldstop = stop,
		                args = Array.prototype.slice.call(arguments, 2),
		                listeners = eve.listeners(name),
		                z = 0,
		                f = false,
		                l,
		                indexed = [],
		                queue = {},
		                out = [],
		                ce = current_event,
		                errors = [];
		            out.firstDefined = firstDefined;
		            out.lastDefined = lastDefined;
		            current_event = name;
		            stop = 0;
		            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
		                indexed.push(listeners[i].zIndex);
		                if (listeners[i].zIndex < 0) {
		                    queue[listeners[i].zIndex] = listeners[i];
		                }
		            }
		            indexed.sort(numsort);
		            while (indexed[z] < 0) {
		                l = queue[indexed[z++]];
		                out.push(l.apply(scope, args));
		                if (stop) {
		                    stop = oldstop;
		                    return out;
		                }
		            }
		            for (i = 0; i < ii; i++) {
		                l = listeners[i];
		                if ("zIndex" in l) {
		                    if (l.zIndex == indexed[z]) {
		                        out.push(l.apply(scope, args));
		                        if (stop) {
		                            break;
		                        }
		                        do {
		                            z++;
		                            l = queue[indexed[z]];
		                            l && out.push(l.apply(scope, args));
		                            if (stop) {
		                                break;
		                            }
		                        } while (l)
		                    } else {
		                        queue[l.zIndex] = l;
		                    }
		                } else {
		                    out.push(l.apply(scope, args));
		                    if (stop) {
		                        break;
		                    }
		                }
		            }
		            stop = oldstop;
		            current_event = ce;
		            return out;
		        };
		        // Undocumented. Debug only.
		        eve._events = events;
		    /*\
		     * eve.listeners
		     [ method ]
		
		     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.
		
		     > Arguments
		
		     - name (string) name of the event, dot (`.`) or slash (`/`) separated
		
		     = (array) array of event handlers
		    \*/
		    eve.listeners = function (name) {
		        var names = name.split(separator),
		            e = events,
		            item,
		            items,
		            k,
		            i,
		            ii,
		            j,
		            jj,
		            nes,
		            es = [e],
		            out = [];
		        for (i = 0, ii = names.length; i < ii; i++) {
		            nes = [];
		            for (j = 0, jj = es.length; j < jj; j++) {
		                e = es[j].n;
		                items = [e[names[i]], e[wildcard]];
		                k = 2;
		                while (k--) {
		                    item = items[k];
		                    if (item) {
		                        nes.push(item);
		                        out = out.concat(item.f || []);
		                    }
		                }
		            }
		            es = nes;
		        }
		        return out;
		    };
		    
		    /*\
		     * eve.on
		     [ method ]
		     **
		     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
		     | eve.on("*.under.*", f);
		     | eve("mouse.under.floor"); // triggers f
		     * Use @eve to trigger the listener.
		     **
		     > Arguments
		     **
		     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
		     - f (function) event handler function
		     **
		     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
		     > Example:
		     | eve.on("mouse", eatIt)(2);
		     | eve.on("mouse", scream);
		     | eve.on("mouse", catchIt)(1);
		     * This will ensure that `catchIt` function will be called before `eatIt`.
		     *
		     * If you want to put your handler before non-indexed handlers, specify a negative value.
		     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
		    \*/
		    eve.on = function (name, f) {
		        name = String(name);
		        if (typeof f != "function") {
		            return function () {};
		        }
		        var names = name.split(comaseparator);
		        for (var i = 0, ii = names.length; i < ii; i++) {
		            (function (name) {
		                var names = name.split(separator),
		                    e = events,
		                    exist;
		                for (var i = 0, ii = names.length; i < ii; i++) {
		                    e = e.n;
		                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
		                }
		                e.f = e.f || [];
		                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
		                    exist = true;
		                    break;
		                }
		                !exist && e.f.push(f);
		            }(names[i]));
		        }
		        return function (zIndex) {
		            if (+zIndex == +zIndex) {
		                f.zIndex = +zIndex;
		            }
		        };
		    };
		    /*\
		     * eve.f
		     [ method ]
		     **
		     * Returns function that will fire given event with optional arguments.
		     * Arguments that will be passed to the result function will be also
		     * concated to the list of final arguments.
		     | el.onclick = eve.f("click", 1, 2);
		     | eve.on("click", function (a, b, c) {
		     |     console.log(a, b, c); // 1, 2, [event object]
		     | });
		     > Arguments
		     - event (string) event name
		     - varargs (…) and any other arguments
		     = (function) possible event handler function
		    \*/
		    eve.f = function (event) {
		        var attrs = [].slice.call(arguments, 1);
		        return function () {
		            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
		        };
		    };
		    /*\
		     * eve.stop
		     [ method ]
		     **
		     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
		    \*/
		    eve.stop = function () {
		        stop = 1;
		    };
		    /*\
		     * eve.nt
		     [ method ]
		     **
		     * Could be used inside event handler to figure out actual name of the event.
		     **
		     > Arguments
		     **
		     - subname (string) #optional subname of the event
		     **
		     = (string) name of the event, if `subname` is not specified
		     * or
		     = (boolean) `true`, if current event’s name contains `subname`
		    \*/
		    eve.nt = function (subname) {
		        if (subname) {
		            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
		        }
		        return current_event;
		    };
		    /*\
		     * eve.nts
		     [ method ]
		     **
		     * Could be used inside event handler to figure out actual name of the event.
		     **
		     **
		     = (array) names of the event
		    \*/
		    eve.nts = function () {
		        return current_event.split(separator);
		    };
		    /*\
		     * eve.off
		     [ method ]
		     **
		     * Removes given function from the list of event listeners assigned to given name.
		     * If no arguments specified all the events will be cleared.
		     **
		     > Arguments
		     **
		     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
		     - f (function) event handler function
		    \*/
		    /*\
		     * eve.unbind
		     [ method ]
		     **
		     * See @eve.off
		    \*/
		    eve.off = eve.unbind = function (name, f) {
		        if (!name) {
		            eve._events = events = {n: {}};
		            return;
		        }
		        var names = name.split(comaseparator);
		        if (names.length > 1) {
		            for (var i = 0, ii = names.length; i < ii; i++) {
		                eve.off(names[i], f);
		            }
		            return;
		        }
		        names = name.split(separator);
		        var e,
		            key,
		            splice,
		            i, ii, j, jj,
		            cur = [events];
		        for (i = 0, ii = names.length; i < ii; i++) {
		            for (j = 0; j < cur.length; j += splice.length - 2) {
		                splice = [j, 1];
		                e = cur[j].n;
		                if (names[i] != wildcard) {
		                    if (e[names[i]]) {
		                        splice.push(e[names[i]]);
		                    }
		                } else {
		                    for (key in e) if (e[has](key)) {
		                        splice.push(e[key]);
		                    }
		                }
		                cur.splice.apply(cur, splice);
		            }
		        }
		        for (i = 0, ii = cur.length; i < ii; i++) {
		            e = cur[i];
		            while (e.n) {
		                if (f) {
		                    if (e.f) {
		                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
		                            e.f.splice(j, 1);
		                            break;
		                        }
		                        !e.f.length && delete e.f;
		                    }
		                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
		                        var funcs = e.n[key].f;
		                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
		                            funcs.splice(j, 1);
		                            break;
		                        }
		                        !funcs.length && delete e.n[key].f;
		                    }
		                } else {
		                    delete e.f;
		                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
		                        delete e.n[key].f;
		                    }
		                }
		                e = e.n;
		            }
		        }
		    };
		    /*\
		     * eve.once
		     [ method ]
		     **
		     * Binds given event handler with a given name to only run once then unbind itself.
		     | eve.once("login", f);
		     | eve("login"); // triggers f
		     | eve("login"); // no listeners
		     * Use @eve to trigger the listener.
		     **
		     > Arguments
		     **
		     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
		     - f (function) event handler function
		     **
		     = (function) same return function as @eve.on
		    \*/
		    eve.once = function (name, f) {
		        var f2 = function () {
		            eve.unbind(name, f2);
		            return f.apply(this, arguments);
		        };
		        return eve.on(name, f2);
		    };
		    /*\
		     * eve.version
		     [ property (string) ]
		     **
		     * Current version of the library.
		    \*/
		    eve.version = version;
		    eve.toString = function () {
		        return "You are running Eve " + version;
		    };
		    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))) : (glob.eve = eve));
		})(this);
		
		(function (glob, factory) {
		    // AMD support
		    if (true) {
		        // Define as an anonymous module
		        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {
		            return factory(glob, eve);
		        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		    } else if (typeof exports != 'undefined') {
		        // Next for Node.js or CommonJS
		        var eve = require('eve');
		        module.exports = factory(glob, eve);
		    } else {
		        // Browser globals (glob is window)
		        // Snap adds itself to window
		        factory(glob, glob.eve);
		    }
		}(window || this, function (window, eve) {
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		var mina = (function (eve) {
		    var animations = {},
		    requestAnimFrame = window.requestAnimationFrame       ||
		                       window.webkitRequestAnimationFrame ||
		                       window.mozRequestAnimationFrame    ||
		                       window.oRequestAnimationFrame      ||
		                       window.msRequestAnimationFrame     ||
		                       function (callback) {
		                           setTimeout(callback, 16);
		                       },
		    isArray = Array.isArray || function (a) {
		        return a instanceof Array ||
		            Object.prototype.toString.call(a) == "[object Array]";
		    },
		    idgen = 0,
		    idprefix = "M" + (+new Date).toString(36),
		    ID = function () {
		        return idprefix + (idgen++).toString(36);
		    },
		    diff = function (a, b, A, B) {
		        if (isArray(a)) {
		            res = [];
		            for (var i = 0, ii = a.length; i < ii; i++) {
		                res[i] = diff(a[i], b, A[i], B);
		            }
		            return res;
		        }
		        var dif = (A - a) / (B - b);
		        return function (bb) {
		            return a + dif * (bb - b);
		        };
		    },
		    timer = Date.now || function () {
		        return +new Date;
		    },
		    sta = function (val) {
		        var a = this;
		        if (val == null) {
		            return a.s;
		        }
		        var ds = a.s - val;
		        a.b += a.dur * ds;
		        a.B += a.dur * ds;
		        a.s = val;
		    },
		    speed = function (val) {
		        var a = this;
		        if (val == null) {
		            return a.spd;
		        }
		        a.spd = val;
		    },
		    duration = function (val) {
		        var a = this;
		        if (val == null) {
		            return a.dur;
		        }
		        a.s = a.s * val / a.dur;
		        a.dur = val;
		    },
		    stopit = function () {
		        var a = this;
		        delete animations[a.id];
		        a.update();
		        eve("mina.stop." + a.id, a);
		    },
		    pause = function () {
		        var a = this;
		        if (a.pdif) {
		            return;
		        }
		        delete animations[a.id];
		        a.update();
		        a.pdif = a.get() - a.b;
		    },
		    resume = function () {
		        var a = this;
		        if (!a.pdif) {
		            return;
		        }
		        a.b = a.get() - a.pdif;
		        delete a.pdif;
		        animations[a.id] = a;
		    },
		    update = function () {
		        var a = this,
		            res;
		        if (isArray(a.start)) {
		            res = [];
		            for (var j = 0, jj = a.start.length; j < jj; j++) {
		                res[j] = +a.start[j] +
		                    (a.end[j] - a.start[j]) * a.easing(a.s);
		            }
		        } else {
		            res = +a.start + (a.end - a.start) * a.easing(a.s);
		        }
		        a.set(res);
		    },
		    frame = function () {
		        var len = 0;
		        for (var i in animations) if (animations.hasOwnProperty(i)) {
		            var a = animations[i],
		                b = a.get(),
		                res;
		            len++;
		            a.s = (b - a.b) / (a.dur / a.spd);
		            if (a.s >= 1) {
		                delete animations[i];
		                a.s = 1;
		                len--;
		                (function (a) {
		                    setTimeout(function () {
		                        eve("mina.finish." + a.id, a);
		                    });
		                }(a));
		            }
		            a.update();
		        }
		        len && requestAnimFrame(frame);
		    },
		    /*\
		     * mina
		     [ method ]
		     **
		     * Generic animation of numbers
		     **
		     - a (number) start _slave_ number
		     - A (number) end _slave_ number
		     - b (number) start _master_ number (start time in general case)
		     - B (number) end _master_ number (end time in gereal case)
		     - get (function) getter of _master_ number (see @mina.time)
		     - set (function) setter of _slave_ number
		     - easing (function) #optional easing function, default is @mina.linear
		     = (object) animation descriptor
		     o {
		     o         id (string) animation id,
		     o         start (number) start _slave_ number,
		     o         end (number) end _slave_ number,
		     o         b (number) start _master_ number,
		     o         s (number) animation status (0..1),
		     o         dur (number) animation duration,
		     o         spd (number) animation speed,
		     o         get (function) getter of _master_ number (see @mina.time),
		     o         set (function) setter of _slave_ number,
		     o         easing (function) easing function, default is @mina.linear,
		     o         status (function) status getter/setter,
		     o         speed (function) speed getter/setter,
		     o         duration (function) duration getter/setter,
		     o         stop (function) animation stopper
		     o         pause (function) pauses the animation
		     o         resume (function) resumes the animation
		     o         update (function) calles setter with the right value of the animation
		     o }
		    \*/
		    mina = function (a, A, b, B, get, set, easing) {
		        var anim = {
		            id: ID(),
		            start: a,
		            end: A,
		            b: b,
		            s: 0,
		            dur: B - b,
		            spd: 1,
		            get: get,
		            set: set,
		            easing: easing || mina.linear,
		            status: sta,
		            speed: speed,
		            duration: duration,
		            stop: stopit,
		            pause: pause,
		            resume: resume,
		            update: update
		        };
		        animations[anim.id] = anim;
		        var len = 0, i;
		        for (i in animations) if (animations.hasOwnProperty(i)) {
		            len++;
		            if (len == 2) {
		                break;
		            }
		        }
		        len == 1 && requestAnimFrame(frame);
		        return anim;
		    };
		    /*\
		     * mina.time
		     [ method ]
		     **
		     * Returns the current time. Equivalent to:
		     | function () {
		     |     return (new Date).getTime();
		     | }
		    \*/
		    mina.time = timer;
		    /*\
		     * mina.getById
		     [ method ]
		     **
		     * Returns an animation by its id
		     - id (string) animation's id
		     = (object) See @mina
		    \*/
		    mina.getById = function (id) {
		        return animations[id] || null;
		    };
		
		    /*\
		     * mina.linear
		     [ method ]
		     **
		     * Default linear easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.linear = function (n) {
		        return n;
		    };
		    /*\
		     * mina.easeout
		     [ method ]
		     **
		     * Easeout easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.easeout = function (n) {
		        return Math.pow(n, 1.7);
		    };
		    /*\
		     * mina.easein
		     [ method ]
		     **
		     * Easein easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.easein = function (n) {
		        return Math.pow(n, .48);
		    };
		    /*\
		     * mina.easeinout
		     [ method ]
		     **
		     * Easeinout easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.easeinout = function (n) {
		        if (n == 1) {
		            return 1;
		        }
		        if (n == 0) {
		            return 0;
		        }
		        var q = .48 - n / 1.04,
		            Q = Math.sqrt(.1734 + q * q),
		            x = Q - q,
		            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
		            y = -Q - q,
		            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
		            t = X + Y + .5;
		        return (1 - t) * 3 * t * t + t * t * t;
		    };
		    /*\
		     * mina.backin
		     [ method ]
		     **
		     * Backin easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.backin = function (n) {
		        if (n == 1) {
		            return 1;
		        }
		        var s = 1.70158;
		        return n * n * ((s + 1) * n - s);
		    };
		    /*\
		     * mina.backout
		     [ method ]
		     **
		     * Backout easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.backout = function (n) {
		        if (n == 0) {
		            return 0;
		        }
		        n = n - 1;
		        var s = 1.70158;
		        return n * n * ((s + 1) * n + s) + 1;
		    };
		    /*\
		     * mina.elastic
		     [ method ]
		     **
		     * Elastic easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.elastic = function (n) {
		        if (n == !!n) {
		            return n;
		        }
		        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
		            (2 * Math.PI) / .3) + 1;
		    };
		    /*\
		     * mina.bounce
		     [ method ]
		     **
		     * Bounce easing
		     - n (number) input 0..1
		     = (number) output 0..1
		    \*/
		    mina.bounce = function (n) {
		        var s = 7.5625,
		            p = 2.75,
		            l;
		        if (n < (1 / p)) {
		            l = s * n * n;
		        } else {
		            if (n < (2 / p)) {
		                n -= (1.5 / p);
		                l = s * n * n + .75;
		            } else {
		                if (n < (2.5 / p)) {
		                    n -= (2.25 / p);
		                    l = s * n * n + .9375;
		                } else {
		                    n -= (2.625 / p);
		                    l = s * n * n + .984375;
		                }
		            }
		        }
		        return l;
		    };
		    window.mina = mina;
		    return mina;
		})(typeof eve == "undefined" ? function () {} : eve);
		// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		
		var Snap = (function(root) {
		Snap.version = "0.4.0";
		/*\
		 * Snap
		 [ method ]
		 **
		 * Creates a drawing surface or wraps existing SVG element.
		 **
		 - width (number|string) width of surface
		 - height (number|string) height of surface
		 * or
		 - DOM (SVGElement) element to be wrapped into Snap structure
		 * or
		 - array (array) array of elements (will return set of elements)
		 * or
		 - query (string) CSS query selector
		 = (object) @Element
		\*/
		function Snap(w, h) {
		    if (w) {
		        if (w.nodeType) {
		            return wrap(w);
		        }
		        if (is(w, "array") && Snap.set) {
		            return Snap.set.apply(Snap, w);
		        }
		        if (w instanceof Element) {
		            return w;
		        }
		        if (h == null) {
		            w = glob.doc.querySelector(String(w));
		            return wrap(w);
		        }
		    }
		    w = w == null ? "100%" : w;
		    h = h == null ? "100%" : h;
		    return new Paper(w, h);
		}
		Snap.toString = function () {
		    return "Snap v" + this.version;
		};
		Snap._ = {};
		var glob = {
		    win: root.window,
		    doc: root.window.document
		};
		Snap._.glob = glob;
		var has = "hasOwnProperty",
		    Str = String,
		    toFloat = parseFloat,
		    toInt = parseInt,
		    math = Math,
		    mmax = math.max,
		    mmin = math.min,
		    abs = math.abs,
		    pow = math.pow,
		    PI = math.PI,
		    round = math.round,
		    E = "",
		    S = " ",
		    objectToString = Object.prototype.toString,
		    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
		    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
		    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
		    reURLValue = /^url\(#?([^)]+)\)$/,
		    separator = Snap._.separator = /[,\s]+/,
		    whitespace = /[\s]/g,
		    commaSpaces = /[\s]*,[\s]*/,
		    hsrg = {hs: 1, rg: 1},
		    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
		    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
		    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig,
		    idgen = 0,
		    idprefix = "S" + (+new Date).toString(36),
		    ID = function (el) {
		        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
		    },
		    xlink = "http://www.w3.org/1999/xlink",
		    xmlns = "http://www.w3.org/2000/svg",
		    hub = {},
		    URL = Snap.url = function (url) {
		        return "url('#" + url + "')";
		    };
		
		function $(el, attr) {
		    if (attr) {
		        if (el == "#text") {
		            el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
		        }
		        if (el == "#comment") {
		            el = glob.doc.createComment(attr.text || attr["#text"] || "");
		        }
		        if (typeof el == "string") {
		            el = $(el);
		        }
		        if (typeof attr == "string") {
		            if (el.nodeType == 1) {
		                if (attr.substring(0, 6) == "xlink:") {
		                    return el.getAttributeNS(xlink, attr.substring(6));
		                }
		                if (attr.substring(0, 4) == "xml:") {
		                    return el.getAttributeNS(xmlns, attr.substring(4));
		                }
		                return el.getAttribute(attr);
		            } else if (attr == "text") {
		                return el.nodeValue;
		            } else {
		                return null;
		            }
		        }
		        if (el.nodeType == 1) {
		            for (var key in attr) if (attr[has](key)) {
		                var val = Str(attr[key]);
		                if (val) {
		                    if (key.substring(0, 6) == "xlink:") {
		                        el.setAttributeNS(xlink, key.substring(6), val);
		                    } else if (key.substring(0, 4) == "xml:") {
		                        el.setAttributeNS(xmlns, key.substring(4), val);
		                    } else {
		                        el.setAttribute(key, val);
		                    }
		                } else {
		                    el.removeAttribute(key);
		                }
		            }
		        } else if ("text" in attr) {
		            el.nodeValue = attr.text;
		        }
		    } else {
		        el = glob.doc.createElementNS(xmlns, el);
		    }
		    return el;
		}
		Snap._.$ = $;
		Snap._.id = ID;
		function getAttrs(el) {
		    var attrs = el.attributes,
		        name,
		        out = {};
		    for (var i = 0; i < attrs.length; i++) {
		        if (attrs[i].namespaceURI == xlink) {
		            name = "xlink:";
		        } else {
		            name = "";
		        }
		        name += attrs[i].name;
		        out[name] = attrs[i].textContent;
		    }
		    return out;
		}
		function is(o, type) {
		    type = Str.prototype.toLowerCase.call(type);
		    if (type == "finite") {
		        return isFinite(o);
		    }
		    if (type == "array" &&
		        (o instanceof Array || Array.isArray && Array.isArray(o))) {
		        return true;
		    }
		    return  (type == "null" && o === null) ||
		            (type == typeof o && o !== null) ||
		            (type == "object" && o === Object(o)) ||
		            objectToString.call(o).slice(8, -1).toLowerCase() == type;
		}
		/*\
		 * Snap.format
		 [ method ]
		 **
		 * Replaces construction of type `{<name>}` to the corresponding argument
		 **
		 - token (string) string to format
		 - json (object) object which properties are used as a replacement
		 = (string) formatted string
		 > Usage
		 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
		 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
		 |     x: 10,
		 |     y: 20,
		 |     dim: {
		 |         width: 40,
		 |         height: 50,
		 |         "negative width": -40
		 |     }
		 | }));
		\*/
		Snap.format = (function () {
		    var tokenRegex = /\{([^\}]+)\}/g,
		        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
		        replacer = function (all, key, obj) {
		            var res = obj;
		            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
		                name = name || quotedName;
		                if (res) {
		                    if (name in res) {
		                        res = res[name];
		                    }
		                    typeof res == "function" && isFunc && (res = res());
		                }
		            });
		            res = (res == null || res == obj ? all : res) + "";
		            return res;
		        };
		    return function (str, obj) {
		        return Str(str).replace(tokenRegex, function (all, key) {
		            return replacer(all, key, obj);
		        });
		    };
		})();
		function clone(obj) {
		    if (typeof obj == "function" || Object(obj) !== obj) {
		        return obj;
		    }
		    var res = new obj.constructor;
		    for (var key in obj) if (obj[has](key)) {
		        res[key] = clone(obj[key]);
		    }
		    return res;
		}
		Snap._.clone = clone;
		function repush(array, item) {
		    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
		        return array.push(array.splice(i, 1)[0]);
		    }
		}
		function cacher(f, scope, postprocessor) {
		    function newf() {
		        var arg = Array.prototype.slice.call(arguments, 0),
		            args = arg.join("\u2400"),
		            cache = newf.cache = newf.cache || {},
		            count = newf.count = newf.count || [];
		        if (cache[has](args)) {
		            repush(count, args);
		            return postprocessor ? postprocessor(cache[args]) : cache[args];
		        }
		        count.length >= 1e3 && delete cache[count.shift()];
		        count.push(args);
		        cache[args] = f.apply(scope, arg);
		        return postprocessor ? postprocessor(cache[args]) : cache[args];
		    }
		    return newf;
		}
		Snap._.cacher = cacher;
		function angle(x1, y1, x2, y2, x3, y3) {
		    if (x3 == null) {
		        var x = x1 - x2,
		            y = y1 - y2;
		        if (!x && !y) {
		            return 0;
		        }
		        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
		    } else {
		        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
		    }
		}
		function rad(deg) {
		    return deg % 360 * PI / 180;
		}
		function deg(rad) {
		    return rad * 180 / PI % 360;
		}
		function x_y() {
		    return this.x + S + this.y;
		}
		function x_y_w_h() {
		    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
		}
		
		/*\
		 * Snap.rad
		 [ method ]
		 **
		 * Transform angle to radians
		 - deg (number) angle in degrees
		 = (number) angle in radians
		\*/
		Snap.rad = rad;
		/*\
		 * Snap.deg
		 [ method ]
		 **
		 * Transform angle to degrees
		 - rad (number) angle in radians
		 = (number) angle in degrees
		\*/
		Snap.deg = deg;
		/*\
		 * Snap.sin
		 [ method ]
		 **
		 * Equivalent to `Math.sin()` only works with degrees, not radians.
		 - angle (number) angle in degrees
		 = (number) sin
		\*/
		Snap.sin = function (angle) {
		    return math.sin(Snap.rad(angle));
		};
		/*\
		 * Snap.tan
		 [ method ]
		 **
		 * Equivalent to `Math.tan()` only works with degrees, not radians.
		 - angle (number) angle in degrees
		 = (number) tan
		\*/
		Snap.tan = function (angle) {
		    return math.tan(Snap.rad(angle));
		};
		/*\
		 * Snap.cos
		 [ method ]
		 **
		 * Equivalent to `Math.cos()` only works with degrees, not radians.
		 - angle (number) angle in degrees
		 = (number) cos
		\*/
		Snap.cos = function (angle) {
		    return math.cos(Snap.rad(angle));
		};
		/*\
		 * Snap.asin
		 [ method ]
		 **
		 * Equivalent to `Math.asin()` only works with degrees, not radians.
		 - num (number) value
		 = (number) asin in degrees
		\*/
		Snap.asin = function (num) {
		    return Snap.deg(math.asin(num));
		};
		/*\
		 * Snap.acos
		 [ method ]
		 **
		 * Equivalent to `Math.acos()` only works with degrees, not radians.
		 - num (number) value
		 = (number) acos in degrees
		\*/
		Snap.acos = function (num) {
		    return Snap.deg(math.acos(num));
		};
		/*\
		 * Snap.atan
		 [ method ]
		 **
		 * Equivalent to `Math.atan()` only works with degrees, not radians.
		 - num (number) value
		 = (number) atan in degrees
		\*/
		Snap.atan = function (num) {
		    return Snap.deg(math.atan(num));
		};
		/*\
		 * Snap.atan2
		 [ method ]
		 **
		 * Equivalent to `Math.atan2()` only works with degrees, not radians.
		 - num (number) value
		 = (number) atan2 in degrees
		\*/
		Snap.atan2 = function (num) {
		    return Snap.deg(math.atan2(num));
		};
		/*\
		 * Snap.angle
		 [ method ]
		 **
		 * Returns an angle between two or three points
		 > Parameters
		 - x1 (number) x coord of first point
		 - y1 (number) y coord of first point
		 - x2 (number) x coord of second point
		 - y2 (number) y coord of second point
		 - x3 (number) #optional x coord of third point
		 - y3 (number) #optional y coord of third point
		 = (number) angle in degrees
		\*/
		Snap.angle = angle;
		/*\
		 * Snap.len
		 [ method ]
		 **
		 * Returns distance between two points
		 > Parameters
		 - x1 (number) x coord of first point
		 - y1 (number) y coord of first point
		 - x2 (number) x coord of second point
		 - y2 (number) y coord of second point
		 = (number) distance
		\*/
		Snap.len = function (x1, y1, x2, y2) {
		    return Math.sqrt(Snap.len2(x1, y1, x2, y2));
		};
		/*\
		 * Snap.len2
		 [ method ]
		 **
		 * Returns squared distance between two points
		 > Parameters
		 - x1 (number) x coord of first point
		 - y1 (number) y coord of first point
		 - x2 (number) x coord of second point
		 - y2 (number) y coord of second point
		 = (number) distance
		\*/
		Snap.len2 = function (x1, y1, x2, y2) {
		    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
		};
		/*\
		 * Snap.closestPoint
		 [ method ]
		 **
		 * Returns closest point to a given one on a given path.
		 > Parameters
		 - path (Element) path element
		 - x (number) x coord of a point
		 - y (number) y coord of a point
		 = (object) in format
		 {
		    x (number) x coord of the point on the path
		    y (number) y coord of the point on the path
		    length (number) length of the path to the point
		    distance (number) distance from the given point to the path
		 }
		\*/
		// Copied from http://bl.ocks.org/mbostock/8027637
		Snap.closestPoint = function (path, x, y) {
		    function distance2(p) {
		        var dx = p.x - x,
		            dy = p.y - y;
		        return dx * dx + dy * dy;
		    }
		    var pathNode = path.node,
		        pathLength = pathNode.getTotalLength(),
		        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
		        best,
		        bestLength,
		        bestDistance = Infinity;
		
		    // linear scan for coarse approximation
		    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
		        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
		            best = scan, bestLength = scanLength, bestDistance = scanDistance;
		        }
		    }
		
		    // binary search for precise estimate
		    precision *= .5;
		    while (precision > .5) {
		        var before,
		            after,
		            beforeLength,
		            afterLength,
		            beforeDistance,
		            afterDistance;
		        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
		            best = before, bestLength = beforeLength, bestDistance = beforeDistance;
		        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
		            best = after, bestLength = afterLength, bestDistance = afterDistance;
		        } else {
		            precision *= .5;
		        }
		    }
		
		    best = {
		        x: best.x,
		        y: best.y,
		        length: bestLength,
		        distance: Math.sqrt(bestDistance)
		    };
		    return best;
		}
		/*\
		 * Snap.is
		 [ method ]
		 **
		 * Handy replacement for the `typeof` operator
		 - o (…) any object or primitive
		 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
		 = (boolean) `true` if given value is of given type
		\*/
		Snap.is = is;
		/*\
		 * Snap.snapTo
		 [ method ]
		 **
		 * Snaps given value to given grid
		 - values (array|number) given array of values or step of the grid
		 - value (number) value to adjust
		 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
		 = (number) adjusted value
		\*/
		Snap.snapTo = function (values, value, tolerance) {
		    tolerance = is(tolerance, "finite") ? tolerance : 10;
		    if (is(values, "array")) {
		        var i = values.length;
		        while (i--) if (abs(values[i] - value) <= tolerance) {
		            return values[i];
		        }
		    } else {
		        values = +values;
		        var rem = value % values;
		        if (rem < tolerance) {
		            return value - rem;
		        }
		        if (rem > values - tolerance) {
		            return value - rem + values;
		        }
		    }
		    return value;
		};
		// Colour
		/*\
		 * Snap.getRGB
		 [ method ]
		 **
		 * Parses color string as RGB object
		 - color (string) color string in one of the following formats:
		 # <ul>
		 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
		 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
		 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
		 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
		 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
		 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
		 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
		 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
		 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
		 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
		 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
		 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
		 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
		 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
		 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
		 # </ul>
		 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
		 = (object) RGB object in the following format:
		 o {
		 o     r (number) red,
		 o     g (number) green,
		 o     b (number) blue,
		 o     hex (string) color in HTML/CSS format: #••••••,
		 o     error (boolean) true if string can't be parsed
		 o }
		\*/
		Snap.getRGB = cacher(function (colour) {
		    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
		        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
		    }
		    if (colour == "none") {
		        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
		    }
		    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
		    if (!colour) {
		        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
		    }
		    var res,
		        red,
		        green,
		        blue,
		        opacity,
		        t,
		        values,
		        rgb = colour.match(colourRegExp);
		    if (rgb) {
		        if (rgb[2]) {
		            blue = toInt(rgb[2].substring(5), 16);
		            green = toInt(rgb[2].substring(3, 5), 16);
		            red = toInt(rgb[2].substring(1, 3), 16);
		        }
		        if (rgb[3]) {
		            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
		            green = toInt((t = rgb[3].charAt(2)) + t, 16);
		            red = toInt((t = rgb[3].charAt(1)) + t, 16);
		        }
		        if (rgb[4]) {
		            values = rgb[4].split(commaSpaces);
		            red = toFloat(values[0]);
		            values[0].slice(-1) == "%" && (red *= 2.55);
		            green = toFloat(values[1]);
		            values[1].slice(-1) == "%" && (green *= 2.55);
		            blue = toFloat(values[2]);
		            values[2].slice(-1) == "%" && (blue *= 2.55);
		            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
		            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
		        }
		        if (rgb[5]) {
		            values = rgb[5].split(commaSpaces);
		            red = toFloat(values[0]);
		            values[0].slice(-1) == "%" && (red /= 100);
		            green = toFloat(values[1]);
		            values[1].slice(-1) == "%" && (green /= 100);
		            blue = toFloat(values[2]);
		            values[2].slice(-1) == "%" && (blue /= 100);
		            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
		            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
		            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
		            return Snap.hsb2rgb(red, green, blue, opacity);
		        }
		        if (rgb[6]) {
		            values = rgb[6].split(commaSpaces);
		            red = toFloat(values[0]);
		            values[0].slice(-1) == "%" && (red /= 100);
		            green = toFloat(values[1]);
		            values[1].slice(-1) == "%" && (green /= 100);
		            blue = toFloat(values[2]);
		            values[2].slice(-1) == "%" && (blue /= 100);
		            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
		            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
		            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
		            return Snap.hsl2rgb(red, green, blue, opacity);
		        }
		        red = mmin(math.round(red), 255);
		        green = mmin(math.round(green), 255);
		        blue = mmin(math.round(blue), 255);
		        opacity = mmin(mmax(opacity, 0), 1);
		        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
		        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
		        rgb.opacity = is(opacity, "finite") ? opacity : 1;
		        return rgb;
		    }
		    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
		}, Snap);
		/*\
		 * Snap.hsb
		 [ method ]
		 **
		 * Converts HSB values to a hex representation of the color
		 - h (number) hue
		 - s (number) saturation
		 - b (number) value or brightness
		 = (string) hex representation of the color
		\*/
		Snap.hsb = cacher(function (h, s, b) {
		    return Snap.hsb2rgb(h, s, b).hex;
		});
		/*\
		 * Snap.hsl
		 [ method ]
		 **
		 * Converts HSL values to a hex representation of the color
		 - h (number) hue
		 - s (number) saturation
		 - l (number) luminosity
		 = (string) hex representation of the color
		\*/
		Snap.hsl = cacher(function (h, s, l) {
		    return Snap.hsl2rgb(h, s, l).hex;
		});
		/*\
		 * Snap.rgb
		 [ method ]
		 **
		 * Converts RGB values to a hex representation of the color
		 - r (number) red
		 - g (number) green
		 - b (number) blue
		 = (string) hex representation of the color
		\*/
		Snap.rgb = cacher(function (r, g, b, o) {
		    if (is(o, "finite")) {
		        var round = math.round;
		        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
		    }
		    return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
		});
		var toHex = function (color) {
		    var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
		        red = "rgb(255, 0, 0)";
		    toHex = cacher(function (color) {
		        if (color.toLowerCase() == "red") {
		            return red;
		        }
		        i.style.color = red;
		        i.style.color = color;
		        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
		        return out == red ? null : out;
		    });
		    return toHex(color);
		},
		hsbtoString = function () {
		    return "hsb(" + [this.h, this.s, this.b] + ")";
		},
		hsltoString = function () {
		    return "hsl(" + [this.h, this.s, this.l] + ")";
		},
		rgbtoString = function () {
		    return this.opacity == 1 || this.opacity == null ?
		            this.hex :
		            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
		},
		prepareRGB = function (r, g, b) {
		    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
		        b = r.b;
		        g = r.g;
		        r = r.r;
		    }
		    if (g == null && is(r, string)) {
		        var clr = Snap.getRGB(r);
		        r = clr.r;
		        g = clr.g;
		        b = clr.b;
		    }
		    if (r > 1 || g > 1 || b > 1) {
		        r /= 255;
		        g /= 255;
		        b /= 255;
		    }
		    
		    return [r, g, b];
		},
		packageRGB = function (r, g, b, o) {
		    r = math.round(r * 255);
		    g = math.round(g * 255);
		    b = math.round(b * 255);
		    var rgb = {
		        r: r,
		        g: g,
		        b: b,
		        opacity: is(o, "finite") ? o : 1,
		        hex: Snap.rgb(r, g, b),
		        toString: rgbtoString
		    };
		    is(o, "finite") && (rgb.opacity = o);
		    return rgb;
		};
		/*\
		 * Snap.color
		 [ method ]
		 **
		 * Parses the color string and returns an object featuring the color's component values
		 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
		 = (object) Combined RGB/HSB object in the following format:
		 o {
		 o     r (number) red,
		 o     g (number) green,
		 o     b (number) blue,
		 o     hex (string) color in HTML/CSS format: #••••••,
		 o     error (boolean) `true` if string can't be parsed,
		 o     h (number) hue,
		 o     s (number) saturation,
		 o     v (number) value (brightness),
		 o     l (number) lightness
		 o }
		\*/
		Snap.color = function (clr) {
		    var rgb;
		    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
		        rgb = Snap.hsb2rgb(clr);
		        clr.r = rgb.r;
		        clr.g = rgb.g;
		        clr.b = rgb.b;
		        clr.opacity = 1;
		        clr.hex = rgb.hex;
		    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
		        rgb = Snap.hsl2rgb(clr);
		        clr.r = rgb.r;
		        clr.g = rgb.g;
		        clr.b = rgb.b;
		        clr.opacity = 1;
		        clr.hex = rgb.hex;
		    } else {
		        if (is(clr, "string")) {
		            clr = Snap.getRGB(clr);
		        }
		        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
		            rgb = Snap.rgb2hsl(clr);
		            clr.h = rgb.h;
		            clr.s = rgb.s;
		            clr.l = rgb.l;
		            rgb = Snap.rgb2hsb(clr);
		            clr.v = rgb.b;
		        } else {
		            clr = {hex: "none"};
		            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
		            clr.error = 1;
		        }
		    }
		    clr.toString = rgbtoString;
		    return clr;
		};
		/*\
		 * Snap.hsb2rgb
		 [ method ]
		 **
		 * Converts HSB values to an RGB object
		 - h (number) hue
		 - s (number) saturation
		 - v (number) value or brightness
		 = (object) RGB object in the following format:
		 o {
		 o     r (number) red,
		 o     g (number) green,
		 o     b (number) blue,
		 o     hex (string) color in HTML/CSS format: #••••••
		 o }
		\*/
		Snap.hsb2rgb = function (h, s, v, o) {
		    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
		        v = h.b;
		        s = h.s;
		        o = h.o;
		        h = h.h;
		    }
		    h *= 360;
		    var R, G, B, X, C;
		    h = (h % 360) / 60;
		    C = v * s;
		    X = C * (1 - abs(h % 2 - 1));
		    R = G = B = v - C;
		
		    h = ~~h;
		    R += [C, X, 0, 0, X, C][h];
		    G += [X, C, C, X, 0, 0][h];
		    B += [0, 0, X, C, C, X][h];
		    return packageRGB(R, G, B, o);
		};
		/*\
		 * Snap.hsl2rgb
		 [ method ]
		 **
		 * Converts HSL values to an RGB object
		 - h (number) hue
		 - s (number) saturation
		 - l (number) luminosity
		 = (object) RGB object in the following format:
		 o {
		 o     r (number) red,
		 o     g (number) green,
		 o     b (number) blue,
		 o     hex (string) color in HTML/CSS format: #••••••
		 o }
		\*/
		Snap.hsl2rgb = function (h, s, l, o) {
		    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
		        l = h.l;
		        s = h.s;
		        h = h.h;
		    }
		    if (h > 1 || s > 1 || l > 1) {
		        h /= 360;
		        s /= 100;
		        l /= 100;
		    }
		    h *= 360;
		    var R, G, B, X, C;
		    h = (h % 360) / 60;
		    C = 2 * s * (l < .5 ? l : 1 - l);
		    X = C * (1 - abs(h % 2 - 1));
		    R = G = B = l - C / 2;
		
		    h = ~~h;
		    R += [C, X, 0, 0, X, C][h];
		    G += [X, C, C, X, 0, 0][h];
		    B += [0, 0, X, C, C, X][h];
		    return packageRGB(R, G, B, o);
		};
		/*\
		 * Snap.rgb2hsb
		 [ method ]
		 **
		 * Converts RGB values to an HSB object
		 - r (number) red
		 - g (number) green
		 - b (number) blue
		 = (object) HSB object in the following format:
		 o {
		 o     h (number) hue,
		 o     s (number) saturation,
		 o     b (number) brightness
		 o }
		\*/
		Snap.rgb2hsb = function (r, g, b) {
		    b = prepareRGB(r, g, b);
		    r = b[0];
		    g = b[1];
		    b = b[2];
		
		    var H, S, V, C;
		    V = mmax(r, g, b);
		    C = V - mmin(r, g, b);
		    H = (C == 0 ? null :
		         V == r ? (g - b) / C :
		         V == g ? (b - r) / C + 2 :
		                  (r - g) / C + 4
		        );
		    H = ((H + 360) % 6) * 60 / 360;
		    S = C == 0 ? 0 : C / V;
		    return {h: H, s: S, b: V, toString: hsbtoString};
		};
		/*\
		 * Snap.rgb2hsl
		 [ method ]
		 **
		 * Converts RGB values to an HSL object
		 - r (number) red
		 - g (number) green
		 - b (number) blue
		 = (object) HSL object in the following format:
		 o {
		 o     h (number) hue,
		 o     s (number) saturation,
		 o     l (number) luminosity
		 o }
		\*/
		Snap.rgb2hsl = function (r, g, b) {
		    b = prepareRGB(r, g, b);
		    r = b[0];
		    g = b[1];
		    b = b[2];
		
		    var H, S, L, M, m, C;
		    M = mmax(r, g, b);
		    m = mmin(r, g, b);
		    C = M - m;
		    H = (C == 0 ? null :
		         M == r ? (g - b) / C :
		         M == g ? (b - r) / C + 2 :
		                  (r - g) / C + 4);
		    H = ((H + 360) % 6) * 60 / 360;
		    L = (M + m) / 2;
		    S = (C == 0 ? 0 :
		         L < .5 ? C / (2 * L) :
		                  C / (2 - 2 * L));
		    return {h: H, s: S, l: L, toString: hsltoString};
		};
		
		// Transformations
		/*\
		 * Snap.parsePathString
		 [ method ]
		 **
		 * Utility method
		 **
		 * Parses given path string into an array of arrays of path segments
		 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
		 = (array) array of segments
		\*/
		Snap.parsePathString = function (pathString) {
		    if (!pathString) {
		        return null;
		    }
		    var pth = Snap.path(pathString);
		    if (pth.arr) {
		        return Snap.path.clone(pth.arr);
		    }
		    
		    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
		        data = [];
		    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
		        data = Snap.path.clone(pathString);
		    }
		    if (!data.length) {
		        Str(pathString).replace(pathCommand, function (a, b, c) {
		            var params = [],
		                name = b.toLowerCase();
		            c.replace(pathValues, function (a, b) {
		                b && params.push(+b);
		            });
		            if (name == "m" && params.length > 2) {
		                data.push([b].concat(params.splice(0, 2)));
		                name = "l";
		                b = b == "m" ? "l" : "L";
		            }
		            if (name == "o" && params.length == 1) {
		                data.push([b, params[0]]);
		            }
		            if (name == "r") {
		                data.push([b].concat(params));
		            } else while (params.length >= paramCounts[name]) {
		                data.push([b].concat(params.splice(0, paramCounts[name])));
		                if (!paramCounts[name]) {
		                    break;
		                }
		            }
		        });
		    }
		    data.toString = Snap.path.toString;
		    pth.arr = Snap.path.clone(data);
		    return data;
		};
		/*\
		 * Snap.parseTransformString
		 [ method ]
		 **
		 * Utility method
		 **
		 * Parses given transform string into an array of transformations
		 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
		 = (array) array of transformations
		\*/
		var parseTransformString = Snap.parseTransformString = function (TString) {
		    if (!TString) {
		        return null;
		    }
		    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
		        data = [];
		    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
		        data = Snap.path.clone(TString);
		    }
		    if (!data.length) {
		        Str(TString).replace(tCommand, function (a, b, c) {
		            var params = [],
		                name = b.toLowerCase();
		            c.replace(pathValues, function (a, b) {
		                b && params.push(+b);
		            });
		            data.push([b].concat(params));
		        });
		    }
		    data.toString = Snap.path.toString;
		    return data;
		};
		function svgTransform2string(tstr) {
		    var res = [];
		    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
		        params = params.split(/\s*,\s*|\s+/);
		        if (name == "rotate" && params.length == 1) {
		            params.push(0, 0);
		        }
		        if (name == "scale") {
		            if (params.length > 2) {
		                params = params.slice(0, 2);
		            } else if (params.length == 2) {
		                params.push(0, 0);
		            }
		            if (params.length == 1) {
		                params.push(params[0], 0, 0);
		            }
		        }
		        if (name == "skewX") {
		            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
		        } else if (name == "skewY") {
		            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
		        } else {
		            res.push([name.charAt(0)].concat(params));
		        }
		        return all;
		    });
		    return res;
		}
		Snap._.svgTransform2string = svgTransform2string;
		Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
		function transform2matrix(tstr, bbox) {
		    var tdata = parseTransformString(tstr),
		        m = new Snap.Matrix;
		    if (tdata) {
		        for (var i = 0, ii = tdata.length; i < ii; i++) {
		            var t = tdata[i],
		                tlen = t.length,
		                command = Str(t[0]).toLowerCase(),
		                absolute = t[0] != command,
		                inver = absolute ? m.invert() : 0,
		                x1,
		                y1,
		                x2,
		                y2,
		                bb;
		            if (command == "t" && tlen == 2){
		                m.translate(t[1], 0);
		            } else if (command == "t" && tlen == 3) {
		                if (absolute) {
		                    x1 = inver.x(0, 0);
		                    y1 = inver.y(0, 0);
		                    x2 = inver.x(t[1], t[2]);
		                    y2 = inver.y(t[1], t[2]);
		                    m.translate(x2 - x1, y2 - y1);
		                } else {
		                    m.translate(t[1], t[2]);
		                }
		            } else if (command == "r") {
		                if (tlen == 2) {
		                    bb = bb || bbox;
		                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
		                } else if (tlen == 4) {
		                    if (absolute) {
		                        x2 = inver.x(t[2], t[3]);
		                        y2 = inver.y(t[2], t[3]);
		                        m.rotate(t[1], x2, y2);
		                    } else {
		                        m.rotate(t[1], t[2], t[3]);
		                    }
		                }
		            } else if (command == "s") {
		                if (tlen == 2 || tlen == 3) {
		                    bb = bb || bbox;
		                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
		                } else if (tlen == 4) {
		                    if (absolute) {
		                        x2 = inver.x(t[2], t[3]);
		                        y2 = inver.y(t[2], t[3]);
		                        m.scale(t[1], t[1], x2, y2);
		                    } else {
		                        m.scale(t[1], t[1], t[2], t[3]);
		                    }
		                } else if (tlen == 5) {
		                    if (absolute) {
		                        x2 = inver.x(t[3], t[4]);
		                        y2 = inver.y(t[3], t[4]);
		                        m.scale(t[1], t[2], x2, y2);
		                    } else {
		                        m.scale(t[1], t[2], t[3], t[4]);
		                    }
		                }
		            } else if (command == "m" && tlen == 7) {
		                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
		            }
		        }
		    }
		    return m;
		}
		Snap._.transform2matrix = transform2matrix;
		Snap._unit2px = unit2px;
		var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
		    function (a, b) {
		        var adown = a.nodeType == 9 ? a.documentElement : a,
		            bup = b && b.parentNode;
		            return a == bup || !!(bup && bup.nodeType == 1 && (
		                adown.contains ?
		                    adown.contains(bup) :
		                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
		            ));
		    } :
		    function (a, b) {
		        if (b) {
		            while (b) {
		                b = b.parentNode;
		                if (b == a) {
		                    return true;
		                }
		            }
		        }
		        return false;
		    };
		function getSomeDefs(el) {
		    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||
		            (el.node.parentNode && wrap(el.node.parentNode)) ||
		            Snap.select("svg") ||
		            Snap(0, 0),
		        pdefs = p.select("defs"),
		        defs  = pdefs == null ? false : pdefs.node;
		    if (!defs) {
		        defs = make("defs", p.node).node;
		    }
		    return defs;
		}
		function getSomeSVG(el) {
		    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
		}
		Snap._.getSomeDefs = getSomeDefs;
		Snap._.getSomeSVG = getSomeSVG;
		function unit2px(el, name, value) {
		    var svg = getSomeSVG(el).node,
		        out = {},
		        mgr = svg.querySelector(".svg---mgr");
		    if (!mgr) {
		        mgr = $("rect");
		        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
		        svg.appendChild(mgr);
		    }
		    function getW(val) {
		        if (val == null) {
		            return E;
		        }
		        if (val == +val) {
		            return val;
		        }
		        $(mgr, {width: val});
		        try {
		            return mgr.getBBox().width;
		        } catch (e) {
		            return 0;
		        }
		    }
		    function getH(val) {
		        if (val == null) {
		            return E;
		        }
		        if (val == +val) {
		            return val;
		        }
		        $(mgr, {height: val});
		        try {
		            return mgr.getBBox().height;
		        } catch (e) {
		            return 0;
		        }
		    }
		    function set(nam, f) {
		        if (name == null) {
		            out[nam] = f(el.attr(nam) || 0);
		        } else if (nam == name) {
		            out = f(value == null ? el.attr(nam) || 0 : value);
		        }
		    }
		    switch (el.type) {
		        case "rect":
		            set("rx", getW);
		            set("ry", getH);
		        case "image":
		            set("width", getW);
		            set("height", getH);
		        case "text":
		            set("x", getW);
		            set("y", getH);
		        break;
		        case "circle":
		            set("cx", getW);
		            set("cy", getH);
		            set("r", getW);
		        break;
		        case "ellipse":
		            set("cx", getW);
		            set("cy", getH);
		            set("rx", getW);
		            set("ry", getH);
		        break;
		        case "line":
		            set("x1", getW);
		            set("x2", getW);
		            set("y1", getH);
		            set("y2", getH);
		        break;
		        case "marker":
		            set("refX", getW);
		            set("markerWidth", getW);
		            set("refY", getH);
		            set("markerHeight", getH);
		        break;
		        case "radialGradient":
		            set("fx", getW);
		            set("fy", getH);
		        break;
		        case "tspan":
		            set("dx", getW);
		            set("dy", getH);
		        break;
		        default:
		            set(name, getW);
		    }
		    svg.removeChild(mgr);
		    return out;
		}
		/*\
		 * Snap.select
		 [ method ]
		 **
		 * Wraps a DOM element specified by CSS selector as @Element
		 - query (string) CSS selector of the element
		 = (Element) the current element
		\*/
		Snap.select = function (query) {
		    query = Str(query).replace(/([^\\]):/g, "$1\\:");
		    return wrap(glob.doc.querySelector(query));
		};
		/*\
		 * Snap.selectAll
		 [ method ]
		 **
		 * Wraps DOM elements specified by CSS selector as set or array of @Element
		 - query (string) CSS selector of the element
		 = (Element) the current element
		\*/
		Snap.selectAll = function (query) {
		    var nodelist = glob.doc.querySelectorAll(query),
		        set = (Snap.set || Array)();
		    for (var i = 0; i < nodelist.length; i++) {
		        set.push(wrap(nodelist[i]));
		    }
		    return set;
		};
		
		function add2group(list) {
		    if (!is(list, "array")) {
		        list = Array.prototype.slice.call(arguments, 0);
		    }
		    var i = 0,
		        j = 0,
		        node = this.node;
		    while (this[i]) delete this[i++];
		    for (i = 0; i < list.length; i++) {
		        if (list[i].type == "set") {
		            list[i].forEach(function (el) {
		                node.appendChild(el.node);
		            });
		        } else {
		            node.appendChild(list[i].node);
		        }
		    }
		    var children = node.childNodes;
		    for (i = 0; i < children.length; i++) {
		        this[j++] = wrap(children[i]);
		    }
		    return this;
		}
		// Hub garbage collector every 10s
		setInterval(function () {
		    for (var key in hub) if (hub[has](key)) {
		        var el = hub[key],
		            node = el.node;
		        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
		            delete hub[key];
		        }
		    }
		}, 1e4);
		function Element(el) {
		    if (el.snap in hub) {
		        return hub[el.snap];
		    }
		    var svg;
		    try {
		        svg = el.ownerSVGElement;
		    } catch(e) {}
		    /*\
		     * Element.node
		     [ property (object) ]
		     **
		     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
		     > Usage
		     | // draw a circle at coordinate 10,10 with radius of 10
		     | var c = paper.circle(10, 10, 10);
		     | c.node.onclick = function () {
		     |     c.attr("fill", "red");
		     | };
		    \*/
		    this.node = el;
		    if (svg) {
		        this.paper = new Paper(svg);
		    }
		    /*\
		     * Element.type
		     [ property (string) ]
		     **
		     * SVG tag name of the given element.
		    \*/
		    this.type = el.tagName || el.nodeName;
		    var id = this.id = ID(this);
		    this.anims = {};
		    this._ = {
		        transform: []
		    };
		    el.snap = id;
		    hub[id] = this;
		    if (this.type == "g") {
		        this.add = add2group;
		    }
		    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
		        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
		            this[method] = Paper.prototype[method];
		        }
		    }
		}
		   /*\
		     * Element.attr
		     [ method ]
		     **
		     * Gets or sets given attributes of the element.
		     **
		     - params (object) contains key-value pairs of attributes you want to set
		     * or
		     - param (string) name of the attribute
		     = (Element) the current element
		     * or
		     = (string) value of attribute
		     > Usage
		     | el.attr({
		     |     fill: "#fc0",
		     |     stroke: "#000",
		     |     strokeWidth: 2, // CamelCase...
		     |     "fill-opacity": 0.5, // or dash-separated names
		     |     width: "*=2" // prefixed values
		     | });
		     | console.log(el.attr("fill")); // #fc0
		     * Prefixed values in format `"+=10"` supported. All four operations
		     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
		     * and `-`: `"+=2em"`.
		    \*/
		    Element.prototype.attr = function (params, value) {
		        var el = this,
		            node = el.node;
		        if (!params) {
		            if (node.nodeType != 1) {
		                return {
		                    text: node.nodeValue
		                };
		            }
		            var attr = node.attributes,
		                out = {};
		            for (var i = 0, ii = attr.length; i < ii; i++) {
		                out[attr[i].nodeName] = attr[i].nodeValue;
		            }
		            return out;
		        }
		        if (is(params, "string")) {
		            if (arguments.length > 1) {
		                var json = {};
		                json[params] = value;
		                params = json;
		            } else {
		                return eve("snap.util.getattr." + params, el).firstDefined();
		            }
		        }
		        for (var att in params) {
		            if (params[has](att)) {
		                eve("snap.util.attr." + att, el, params[att]);
		            }
		        }
		        return el;
		    };
		/*\
		 * Snap.parse
		 [ method ]
		 **
		 * Parses SVG fragment and converts it into a @Fragment
		 **
		 - svg (string) SVG string
		 = (Fragment) the @Fragment
		\*/
		Snap.parse = function (svg) {
		    var f = glob.doc.createDocumentFragment(),
		        full = true,
		        div = glob.doc.createElement("div");
		    svg = Str(svg);
		    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
		        svg = "<svg>" + svg + "</svg>";
		        full = false;
		    }
		    div.innerHTML = svg;
		    svg = div.getElementsByTagName("svg")[0];
		    if (svg) {
		        if (full) {
		            f = svg;
		        } else {
		            while (svg.firstChild) {
		                f.appendChild(svg.firstChild);
		            }
		        }
		    }
		    return new Fragment(f);
		};
		function Fragment(frag) {
		    this.node = frag;
		}
		/*\
		 * Snap.fragment
		 [ method ]
		 **
		 * Creates a DOM fragment from a given list of elements or strings
		 **
		 - varargs (…) SVG string
		 = (Fragment) the @Fragment
		\*/
		Snap.fragment = function () {
		    var args = Array.prototype.slice.call(arguments, 0),
		        f = glob.doc.createDocumentFragment();
		    for (var i = 0, ii = args.length; i < ii; i++) {
		        var item = args[i];
		        if (item.node && item.node.nodeType) {
		            f.appendChild(item.node);
		        }
		        if (item.nodeType) {
		            f.appendChild(item);
		        }
		        if (typeof item == "string") {
		            f.appendChild(Snap.parse(item).node);
		        }
		    }
		    return new Fragment(f);
		};
		
		function make(name, parent) {
		    var res = $(name);
		    parent.appendChild(res);
		    var el = wrap(res);
		    return el;
		}
		function Paper(w, h) {
		    var res,
		        desc,
		        defs,
		        proto = Paper.prototype;
		    if (w && w.tagName == "svg") {
		        if (w.snap in hub) {
		            return hub[w.snap];
		        }
		        var doc = w.ownerDocument;
		        res = new Element(w);
		        desc = w.getElementsByTagName("desc")[0];
		        defs = w.getElementsByTagName("defs")[0];
		        if (!desc) {
		            desc = $("desc");
		            desc.appendChild(doc.createTextNode("Created with Snap"));
		            res.node.appendChild(desc);
		        }
		        if (!defs) {
		            defs = $("defs");
		            res.node.appendChild(defs);
		        }
		        res.defs = defs;
		        for (var key in proto) if (proto[has](key)) {
		            res[key] = proto[key];
		        }
		        res.paper = res.root = res;
		    } else {
		        res = make("svg", glob.doc.body);
		        $(res.node, {
		            height: h,
		            version: 1.1,
		            width: w,
		            xmlns: xmlns
		        });
		    }
		    return res;
		}
		function wrap(dom) {
		    if (!dom) {
		        return dom;
		    }
		    if (dom instanceof Element || dom instanceof Fragment) {
		        return dom;
		    }
		    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
		        return new Paper(dom);
		    }
		    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
		        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
		    }
		    return new Element(dom);
		}
		
		Snap._.make = make;
		Snap._.wrap = wrap;
		/*\
		 * Paper.el
		 [ method ]
		 **
		 * Creates an element on paper with a given name and no attributes
		 **
		 - name (string) tag name
		 - attr (object) attributes
		 = (Element) the current element
		 > Usage
		 | var c = paper.circle(10, 10, 10); // is the same as...
		 | var c = paper.el("circle").attr({
		 |     cx: 10,
		 |     cy: 10,
		 |     r: 10
		 | });
		 | // and the same as
		 | var c = paper.el("circle", {
		 |     cx: 10,
		 |     cy: 10,
		 |     r: 10
		 | });
		\*/
		Paper.prototype.el = function (name, attr) {
		    var el = make(name, this.node);
		    attr && el.attr(attr);
		    return el;
		};
		/*\
		 * Element.children
		 [ method ]
		 **
		 * Returns array of all the children of the element.
		 = (array) array of Elements
		\*/
		Element.prototype.children = function () {
		    var out = [],
		        ch = this.node.childNodes;
		    for (var i = 0, ii = ch.length; i < ii; i++) {
		        out[i] = Snap(ch[i]);
		    }
		    return out;
		};
		function jsonFiller(root, o) {
		    for (var i = 0, ii = root.length; i < ii; i++) {
		        var item = {
		                type: root[i].type,
		                attr: root[i].attr()
		            },
		            children = root[i].children();
		        o.push(item);
		        if (children.length) {
		            jsonFiller(children, item.childNodes = []);
		        }
		    }
		}
		/*\
		 * Element.toJSON
		 [ method ]
		 **
		 * Returns object representation of the given element and all its children.
		 = (object) in format
		 o {
		 o     type (string) this.type,
		 o     attr (object) attributes map,
		 o     childNodes (array) optional array of children in the same format
		 o }
		\*/
		Element.prototype.toJSON = function () {
		    var out = [];
		    jsonFiller([this], out);
		    return out[0];
		};
		// default
		eve.on("snap.util.getattr", function () {
		    var att = eve.nt();
		    att = att.substring(att.lastIndexOf(".") + 1);
		    var css = att.replace(/[A-Z]/g, function (letter) {
		        return "-" + letter.toLowerCase();
		    });
		    if (cssAttr[has](css)) {
		        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
		    } else {
		        return $(this.node, att);
		    }
		});
		var cssAttr = {
		    "alignment-baseline": 0,
		    "baseline-shift": 0,
		    "clip": 0,
		    "clip-path": 0,
		    "clip-rule": 0,
		    "color": 0,
		    "color-interpolation": 0,
		    "color-interpolation-filters": 0,
		    "color-profile": 0,
		    "color-rendering": 0,
		    "cursor": 0,
		    "direction": 0,
		    "display": 0,
		    "dominant-baseline": 0,
		    "enable-background": 0,
		    "fill": 0,
		    "fill-opacity": 0,
		    "fill-rule": 0,
		    "filter": 0,
		    "flood-color": 0,
		    "flood-opacity": 0,
		    "font": 0,
		    "font-family": 0,
		    "font-size": 0,
		    "font-size-adjust": 0,
		    "font-stretch": 0,
		    "font-style": 0,
		    "font-variant": 0,
		    "font-weight": 0,
		    "glyph-orientation-horizontal": 0,
		    "glyph-orientation-vertical": 0,
		    "image-rendering": 0,
		    "kerning": 0,
		    "letter-spacing": 0,
		    "lighting-color": 0,
		    "marker": 0,
		    "marker-end": 0,
		    "marker-mid": 0,
		    "marker-start": 0,
		    "mask": 0,
		    "opacity": 0,
		    "overflow": 0,
		    "pointer-events": 0,
		    "shape-rendering": 0,
		    "stop-color": 0,
		    "stop-opacity": 0,
		    "stroke": 0,
		    "stroke-dasharray": 0,
		    "stroke-dashoffset": 0,
		    "stroke-linecap": 0,
		    "stroke-linejoin": 0,
		    "stroke-miterlimit": 0,
		    "stroke-opacity": 0,
		    "stroke-width": 0,
		    "text-anchor": 0,
		    "text-decoration": 0,
		    "text-rendering": 0,
		    "unicode-bidi": 0,
		    "visibility": 0,
		    "word-spacing": 0,
		    "writing-mode": 0
		};
		
		eve.on("snap.util.attr", function (value) {
		    var att = eve.nt(),
		        attr = {};
		    att = att.substring(att.lastIndexOf(".") + 1);
		    attr[att] = value;
		    var style = att.replace(/-(\w)/gi, function (all, letter) {
		            return letter.toUpperCase();
		        }),
		        css = att.replace(/[A-Z]/g, function (letter) {
		            return "-" + letter.toLowerCase();
		        });
		    if (cssAttr[has](css)) {
		        this.node.style[style] = value == null ? E : value;
		    } else {
		        $(this.node, attr);
		    }
		});
		(function (proto) {}(Paper.prototype));
		
		// simple ajax
		/*\
		 * Snap.ajax
		 [ method ]
		 **
		 * Simple implementation of Ajax
		 **
		 - url (string) URL
		 - postData (object|string) data for post request
		 - callback (function) callback
		 - scope (object) #optional scope of callback
		 * or
		 - url (string) URL
		 - callback (function) callback
		 - scope (object) #optional scope of callback
		 = (XMLHttpRequest) the XMLHttpRequest object, just in case
		\*/
		Snap.ajax = function (url, postData, callback, scope){
		    var req = new XMLHttpRequest,
		        id = ID();
		    if (req) {
		        if (is(postData, "function")) {
		            scope = callback;
		            callback = postData;
		            postData = null;
		        } else if (is(postData, "object")) {
		            var pd = [];
		            for (var key in postData) if (postData.hasOwnProperty(key)) {
		                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
		            }
		            postData = pd.join("&");
		        }
		        req.open((postData ? "POST" : "GET"), url, true);
		        if (postData) {
		            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
		            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
		        }
		        if (callback) {
		            eve.once("snap.ajax." + id + ".0", callback);
		            eve.once("snap.ajax." + id + ".200", callback);
		            eve.once("snap.ajax." + id + ".304", callback);
		        }
		        req.onreadystatechange = function() {
		            if (req.readyState != 4) return;
		            eve("snap.ajax." + id + "." + req.status, scope, req);
		        };
		        if (req.readyState == 4) {
		            return req;
		        }
		        req.send(postData);
		        return req;
		    }
		};
		/*\
		 * Snap.load
		 [ method ]
		 **
		 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
		 **
		 - url (string) URL
		 - callback (function) callback
		 - scope (object) #optional scope of callback
		\*/
		Snap.load = function (url, callback, scope) {
		    Snap.ajax(url, function (req) {
		        var f = Snap.parse(req.responseText);
		        scope ? callback.call(scope, f) : callback(f);
		    });
		};
		var getOffset = function (elem) {
		    var box = elem.getBoundingClientRect(),
		        doc = elem.ownerDocument,
		        body = doc.body,
		        docElem = doc.documentElement,
		        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
		        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
		        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
		    return {
		        y: top,
		        x: left
		    };
		};
		/*\
		 * Snap.getElementByPoint
		 [ method ]
		 **
		 * Returns you topmost element under given point.
		 **
		 = (object) Snap element object
		 - x (number) x coordinate from the top left corner of the window
		 - y (number) y coordinate from the top left corner of the window
		 > Usage
		 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
		\*/
		Snap.getElementByPoint = function (x, y) {
		    var paper = this,
		        svg = paper.canvas,
		        target = glob.doc.elementFromPoint(x, y);
		    if (glob.win.opera && target.tagName == "svg") {
		        var so = getOffset(target),
		            sr = target.createSVGRect();
		        sr.x = x - so.x;
		        sr.y = y - so.y;
		        sr.width = sr.height = 1;
		        var hits = target.getIntersectionList(sr, null);
		        if (hits.length) {
		            target = hits[hits.length - 1];
		        }
		    }
		    if (!target) {
		        return null;
		    }
		    return wrap(target);
		};
		/*\
		 * Snap.plugin
		 [ method ]
		 **
		 * Let you write plugins. You pass in a function with five arguments, like this:
		 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
		 |     Snap.newmethod = function () {};
		 |     Element.prototype.newmethod = function () {};
		 |     Paper.prototype.newmethod = function () {};
		 | });
		 * Inside the function you have access to all main objects (and their
		 * prototypes). This allow you to extend anything you want.
		 **
		 - f (function) your plugin body
		\*/
		Snap.plugin = function (f) {
		    f(Snap, Element, Paper, glob, Fragment);
		};
		glob.win.Snap = Snap;
		return Snap;
		}(window || this));
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		// http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var elproto = Element.prototype,
		        is = Snap.is,
		        Str = String,
		        unit2px = Snap._unit2px,
		        $ = Snap._.$,
		        make = Snap._.make,
		        getSomeDefs = Snap._.getSomeDefs,
		        has = "hasOwnProperty",
		        wrap = Snap._.wrap;
		    /*\
		     * Element.getBBox
		     [ method ]
		     **
		     * Returns the bounding box descriptor for the given element
		     **
		     = (object) bounding box descriptor:
		     o {
		     o     cx: (number) x of the center,
		     o     cy: (number) x of the center,
		     o     h: (number) height,
		     o     height: (number) height,
		     o     path: (string) path command for the box,
		     o     r0: (number) radius of a circle that fully encloses the box,
		     o     r1: (number) radius of the smallest circle that can be enclosed,
		     o     r2: (number) radius of the largest circle that can be enclosed,
		     o     vb: (string) box as a viewbox command,
		     o     w: (number) width,
		     o     width: (number) width,
		     o     x2: (number) x of the right side,
		     o     x: (number) x of the left side,
		     o     y2: (number) y of the bottom edge,
		     o     y: (number) y of the top edge
		     o }
		    \*/
		    elproto.getBBox = function (isWithoutTransform) {
		        if (!Snap.Matrix || !Snap.path) {
		            return this.node.getBBox();
		        }
		        var el = this,
		            m = new Snap.Matrix;
		        if (el.removed) {
		            return Snap._.box();
		        }
		        while (el.type == "use") {
		            if (!isWithoutTransform) {
		                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
		            }
		            if (el.original) {
		                el = el.original;
		            } else {
		                var href = el.attr("xlink:href");
		                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
		            }
		        }
		        var _ = el._,
		            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
		        try {
		            if (isWithoutTransform) {
		                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
		                return Snap._.box(_.bboxwt);
		            } else {
		                el.realPath = pathfinder(el);
		                el.matrix = el.transform().localMatrix;
		                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
		                return Snap._.box(_.bbox);
		            }
		        } catch (e) {
		            // Firefox doesn’t give you bbox of hidden element
		            return Snap._.box();
		        }
		    };
		    var propString = function () {
		        return this.string;
		    };
		    function extractTransform(el, tstr) {
		        if (tstr == null) {
		            var doReturn = true;
		            if (el.type == "linearGradient" || el.type == "radialGradient") {
		                tstr = el.node.getAttribute("gradientTransform");
		            } else if (el.type == "pattern") {
		                tstr = el.node.getAttribute("patternTransform");
		            } else {
		                tstr = el.node.getAttribute("transform");
		            }
		            if (!tstr) {
		                return new Snap.Matrix;
		            }
		            tstr = Snap._.svgTransform2string(tstr);
		        } else {
		            if (!Snap._.rgTransform.test(tstr)) {
		                tstr = Snap._.svgTransform2string(tstr);
		            } else {
		                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
		            }
		            if (is(tstr, "array")) {
		                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
		            }
		            el._.transform = tstr;
		        }
		        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
		        if (doReturn) {
		            return m;
		        } else {
		            el.matrix = m;
		        }
		    }
		    /*\
		     * Element.transform
		     [ method ]
		     **
		     * Gets or sets transformation of the element
		     **
		     - tstr (string) transform string in Snap or SVG format
		     = (Element) the current element
		     * or
		     = (object) transformation descriptor:
		     o {
		     o     string (string) transform string,
		     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
		     o     localMatrix (Matrix) matrix of transformations applied only to the element,
		     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
		     o     global (string) global transformation as string,
		     o     local (string) local transformation as string,
		     o     toString (function) returns `string` property
		     o }
		    \*/
		    elproto.transform = function (tstr) {
		        var _ = this._;
		        if (tstr == null) {
		            var papa = this,
		                global = new Snap.Matrix(this.node.getCTM()),
		                local = extractTransform(this),
		                ms = [local],
		                m = new Snap.Matrix,
		                i,
		                localString = local.toTransformString(),
		                string = Str(local) == Str(this.matrix) ?
		                            Str(_.transform) : localString;
		            while (papa.type != "svg" && (papa = papa.parent())) {
		                ms.push(extractTransform(papa));
		            }
		            i = ms.length;
		            while (i--) {
		                m.add(ms[i]);
		            }
		            return {
		                string: string,
		                globalMatrix: global,
		                totalMatrix: m,
		                localMatrix: local,
		                diffMatrix: global.clone().add(local.invert()),
		                global: global.toTransformString(),
		                total: m.toTransformString(),
		                local: localString,
		                toString: propString
		            };
		        }
		        if (tstr instanceof Snap.Matrix) {
		            this.matrix = tstr;
		            this._.transform = tstr.toTransformString();
		        } else {
		            extractTransform(this, tstr);
		        }
		
		        if (this.node) {
		            if (this.type == "linearGradient" || this.type == "radialGradient") {
		                $(this.node, {gradientTransform: this.matrix});
		            } else if (this.type == "pattern") {
		                $(this.node, {patternTransform: this.matrix});
		            } else {
		                $(this.node, {transform: this.matrix});
		            }
		        }
		
		        return this;
		    };
		    /*\
		     * Element.parent
		     [ method ]
		     **
		     * Returns the element's parent
		     **
		     = (Element) the parent element
		    \*/
		    elproto.parent = function () {
		        return wrap(this.node.parentNode);
		    };
		    /*\
		     * Element.append
		     [ method ]
		     **
		     * Appends the given element to current one
		     **
		     - el (Element|Set) element to append
		     = (Element) the parent element
		    \*/
		    /*\
		     * Element.add
		     [ method ]
		     **
		     * See @Element.append
		    \*/
		    elproto.append = elproto.add = function (el) {
		        if (el) {
		            if (el.type == "set") {
		                var it = this;
		                el.forEach(function (el) {
		                    it.add(el);
		                });
		                return this;
		            }
		            el = wrap(el);
		            this.node.appendChild(el.node);
		            el.paper = this.paper;
		        }
		        return this;
		    };
		    /*\
		     * Element.appendTo
		     [ method ]
		     **
		     * Appends the current element to the given one
		     **
		     - el (Element) parent element to append to
		     = (Element) the child element
		    \*/
		    elproto.appendTo = function (el) {
		        if (el) {
		            el = wrap(el);
		            el.append(this);
		        }
		        return this;
		    };
		    /*\
		     * Element.prepend
		     [ method ]
		     **
		     * Prepends the given element to the current one
		     **
		     - el (Element) element to prepend
		     = (Element) the parent element
		    \*/
		    elproto.prepend = function (el) {
		        if (el) {
		            if (el.type == "set") {
		                var it = this,
		                    first;
		                el.forEach(function (el) {
		                    if (first) {
		                        first.after(el);
		                    } else {
		                        it.prepend(el);
		                    }
		                    first = el;
		                });
		                return this;
		            }
		            el = wrap(el);
		            var parent = el.parent();
		            this.node.insertBefore(el.node, this.node.firstChild);
		            this.add && this.add();
		            el.paper = this.paper;
		            this.parent() && this.parent().add();
		            parent && parent.add();
		        }
		        return this;
		    };
		    /*\
		     * Element.prependTo
		     [ method ]
		     **
		     * Prepends the current element to the given one
		     **
		     - el (Element) parent element to prepend to
		     = (Element) the child element
		    \*/
		    elproto.prependTo = function (el) {
		        el = wrap(el);
		        el.prepend(this);
		        return this;
		    };
		    /*\
		     * Element.before
		     [ method ]
		     **
		     * Inserts given element before the current one
		     **
		     - el (Element) element to insert
		     = (Element) the parent element
		    \*/
		    elproto.before = function (el) {
		        if (el.type == "set") {
		            var it = this;
		            el.forEach(function (el) {
		                var parent = el.parent();
		                it.node.parentNode.insertBefore(el.node, it.node);
		                parent && parent.add();
		            });
		            this.parent().add();
		            return this;
		        }
		        el = wrap(el);
		        var parent = el.parent();
		        this.node.parentNode.insertBefore(el.node, this.node);
		        this.parent() && this.parent().add();
		        parent && parent.add();
		        el.paper = this.paper;
		        return this;
		    };
		    /*\
		     * Element.after
		     [ method ]
		     **
		     * Inserts given element after the current one
		     **
		     - el (Element) element to insert
		     = (Element) the parent element
		    \*/
		    elproto.after = function (el) {
		        el = wrap(el);
		        var parent = el.parent();
		        if (this.node.nextSibling) {
		            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
		        } else {
		            this.node.parentNode.appendChild(el.node);
		        }
		        this.parent() && this.parent().add();
		        parent && parent.add();
		        el.paper = this.paper;
		        return this;
		    };
		    /*\
		     * Element.insertBefore
		     [ method ]
		     **
		     * Inserts the element after the given one
		     **
		     - el (Element) element next to whom insert to
		     = (Element) the parent element
		    \*/
		    elproto.insertBefore = function (el) {
		        el = wrap(el);
		        var parent = this.parent();
		        el.node.parentNode.insertBefore(this.node, el.node);
		        this.paper = el.paper;
		        parent && parent.add();
		        el.parent() && el.parent().add();
		        return this;
		    };
		    /*\
		     * Element.insertAfter
		     [ method ]
		     **
		     * Inserts the element after the given one
		     **
		     - el (Element) element next to whom insert to
		     = (Element) the parent element
		    \*/
		    elproto.insertAfter = function (el) {
		        el = wrap(el);
		        var parent = this.parent();
		        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
		        this.paper = el.paper;
		        parent && parent.add();
		        el.parent() && el.parent().add();
		        return this;
		    };
		    /*\
		     * Element.remove
		     [ method ]
		     **
		     * Removes element from the DOM
		     = (Element) the detached element
		    \*/
		    elproto.remove = function () {
		        var parent = this.parent();
		        this.node.parentNode && this.node.parentNode.removeChild(this.node);
		        delete this.paper;
		        this.removed = true;
		        parent && parent.add();
		        return this;
		    };
		    /*\
		     * Element.select
		     [ method ]
		     **
		     * Gathers the nested @Element matching the given set of CSS selectors
		     **
		     - query (string) CSS selector
		     = (Element) result of query selection
		    \*/
		    elproto.select = function (query) {
		        return wrap(this.node.querySelector(query));
		    };
		    /*\
		     * Element.selectAll
		     [ method ]
		     **
		     * Gathers nested @Element objects matching the given set of CSS selectors
		     **
		     - query (string) CSS selector
		     = (Set|array) result of query selection
		    \*/
		    elproto.selectAll = function (query) {
		        var nodelist = this.node.querySelectorAll(query),
		            set = (Snap.set || Array)();
		        for (var i = 0; i < nodelist.length; i++) {
		            set.push(wrap(nodelist[i]));
		        }
		        return set;
		    };
		    /*\
		     * Element.asPX
		     [ method ]
		     **
		     * Returns given attribute of the element as a `px` value (not %, em, etc.)
		     **
		     - attr (string) attribute name
		     - value (string) #optional attribute value
		     = (Element) result of query selection
		    \*/
		    elproto.asPX = function (attr, value) {
		        if (value == null) {
		            value = this.attr(attr);
		        }
		        return +unit2px(this, attr, value);
		    };
		    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
		    /*\
		     * Element.use
		     [ method ]
		     **
		     * Creates a `<use>` element linked to the current element
		     **
		     = (Element) the `<use>` element
		    \*/
		    elproto.use = function () {
		        var use,
		            id = this.node.id;
		        if (!id) {
		            id = this.id;
		            $(this.node, {
		                id: id
		            });
		        }
		        if (this.type == "linearGradient" || this.type == "radialGradient" ||
		            this.type == "pattern") {
		            use = make(this.type, this.node.parentNode);
		        } else {
		            use = make("use", this.node.parentNode);
		        }
		        $(use.node, {
		            "xlink:href": "#" + id
		        });
		        use.original = this;
		        return use;
		    };
		    function fixids(el) {
		        var els = el.selectAll("*"),
		            it,
		            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
		            ids = [],
		            uses = {};
		        function urltest(it, name) {
		            var val = $(it.node, name);
		            val = val && val.match(url);
		            val = val && val[2];
		            if (val && val.charAt() == "#") {
		                val = val.substring(1);
		            } else {
		                return;
		            }
		            if (val) {
		                uses[val] = (uses[val] || []).concat(function (id) {
		                    var attr = {};
		                    attr[name] = URL(id);
		                    $(it.node, attr);
		                });
		            }
		        }
		        function linktest(it) {
		            var val = $(it.node, "xlink:href");
		            if (val && val.charAt() == "#") {
		                val = val.substring(1);
		            } else {
		                return;
		            }
		            if (val) {
		                uses[val] = (uses[val] || []).concat(function (id) {
		                    it.attr("xlink:href", "#" + id);
		                });
		            }
		        }
		        for (var i = 0, ii = els.length; i < ii; i++) {
		            it = els[i];
		            urltest(it, "fill");
		            urltest(it, "stroke");
		            urltest(it, "filter");
		            urltest(it, "mask");
		            urltest(it, "clip-path");
		            linktest(it);
		            var oldid = $(it.node, "id");
		            if (oldid) {
		                $(it.node, {id: it.id});
		                ids.push({
		                    old: oldid,
		                    id: it.id
		                });
		            }
		        }
		        for (i = 0, ii = ids.length; i < ii; i++) {
		            var fs = uses[ids[i].old];
		            if (fs) {
		                for (var j = 0, jj = fs.length; j < jj; j++) {
		                    fs[j](ids[i].id);
		                }
		            }
		        }
		    }
		    /*\
		     * Element.clone
		     [ method ]
		     **
		     * Creates a clone of the element and inserts it after the element
		     **
		     = (Element) the clone
		    \*/
		    elproto.clone = function () {
		        var clone = wrap(this.node.cloneNode(true));
		        if ($(clone.node, "id")) {
		            $(clone.node, {id: clone.id});
		        }
		        fixids(clone);
		        clone.insertAfter(this);
		        return clone;
		    };
		    /*\
		     * Element.toDefs
		     [ method ]
		     **
		     * Moves element to the shared `<defs>` area
		     **
		     = (Element) the element
		    \*/
		    elproto.toDefs = function () {
		        var defs = getSomeDefs(this);
		        defs.appendChild(this.node);
		        return this;
		    };
		    /*\
		     * Element.toPattern
		     [ method ]
		     **
		     * Creates a `<pattern>` element from the current element
		     **
		     * To create a pattern you have to specify the pattern rect:
		     - x (string|number)
		     - y (string|number)
		     - width (string|number)
		     - height (string|number)
		     = (Element) the `<pattern>` element
		     * You can use pattern later on as an argument for `fill` attribute:
		     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
		     |         fill: "none",
		     |         stroke: "#bada55",
		     |         strokeWidth: 5
		     |     }).pattern(0, 0, 10, 10),
		     |     c = paper.circle(200, 200, 100);
		     | c.attr({
		     |     fill: p
		     | });
		    \*/
		    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
		        var p = make("pattern", getSomeDefs(this));
		        if (x == null) {
		            x = this.getBBox();
		        }
		        if (is(x, "object") && "x" in x) {
		            y = x.y;
		            width = x.width;
		            height = x.height;
		            x = x.x;
		        }
		        $(p.node, {
		            x: x,
		            y: y,
		            width: width,
		            height: height,
		            patternUnits: "userSpaceOnUse",
		            id: p.id,
		            viewBox: [x, y, width, height].join(" ")
		        });
		        p.node.appendChild(this.node);
		        return p;
		    };
		// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
		// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
		    /*\
		     * Element.marker
		     [ method ]
		     **
		     * Creates a `<marker>` element from the current element
		     **
		     * To create a marker you have to specify the bounding rect and reference point:
		     - x (number)
		     - y (number)
		     - width (number)
		     - height (number)
		     - refX (number)
		     - refY (number)
		     = (Element) the `<marker>` element
		     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
		    \*/
		    // TODO add usage for markers
		    elproto.marker = function (x, y, width, height, refX, refY) {
		        var p = make("marker", getSomeDefs(this));
		        if (x == null) {
		            x = this.getBBox();
		        }
		        if (is(x, "object") && "x" in x) {
		            y = x.y;
		            width = x.width;
		            height = x.height;
		            refX = x.refX || x.cx;
		            refY = x.refY || x.cy;
		            x = x.x;
		        }
		        $(p.node, {
		            viewBox: [x, y, width, height].join(" "),
		            markerWidth: width,
		            markerHeight: height,
		            orient: "auto",
		            refX: refX || 0,
		            refY: refY || 0,
		            id: p.id
		        });
		        p.node.appendChild(this.node);
		        return p;
		    };
		    // animation
		    function slice(from, to, f) {
		        return function (arr) {
		            var res = arr.slice(from, to);
		            if (res.length == 1) {
		                res = res[0];
		            }
		            return f ? f(res) : res;
		        };
		    }
		    var Animation = function (attr, ms, easing, callback) {
		        if (typeof easing == "function" && !easing.length) {
		            callback = easing;
		            easing = mina.linear;
		        }
		        this.attr = attr;
		        this.dur = ms;
		        easing && (this.easing = easing);
		        callback && (this.callback = callback);
		    };
		    Snap._.Animation = Animation;
		    /*\
		     * Snap.animation
		     [ method ]
		     **
		     * Creates an animation object
		     **
		     - attr (object) attributes of final destination
		     - duration (number) duration of the animation, in milliseconds
		     - easing (function) #optional one of easing functions of @mina or custom one
		     - callback (function) #optional callback function that fires when animation ends
		     = (object) animation object
		    \*/
		    Snap.animation = function (attr, ms, easing, callback) {
		        return new Animation(attr, ms, easing, callback);
		    };
		    /*\
		     * Element.inAnim
		     [ method ]
		     **
		     * Returns a set of animations that may be able to manipulate the current element
		     **
		     = (object) in format:
		     o {
		     o     anim (object) animation object,
		     o     mina (object) @mina object,
		     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
		     o     status (function) gets or sets the status of the animation,
		     o     stop (function) stops the animation
		     o }
		    \*/
		    elproto.inAnim = function () {
		        var el = this,
		            res = [];
		        for (var id in el.anims) if (el.anims[has](id)) {
		            (function (a) {
		                res.push({
		                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
		                    mina: a,
		                    curStatus: a.status(),
		                    status: function (val) {
		                        return a.status(val);
		                    },
		                    stop: function () {
		                        a.stop();
		                    }
		                });
		            }(el.anims[id]));
		        }
		        return res;
		    };
		    /*\
		     * Snap.animate
		     [ method ]
		     **
		     * Runs generic animation of one number into another with a caring function
		     **
		     - from (number|array) number or array of numbers
		     - to (number|array) number or array of numbers
		     - setter (function) caring function that accepts one number argument
		     - duration (number) duration, in milliseconds
		     - easing (function) #optional easing function from @mina or custom
		     - callback (function) #optional callback function to execute when animation ends
		     = (object) animation object in @mina format
		     o {
		     o     id (string) animation id, consider it read-only,
		     o     duration (function) gets or sets the duration of the animation,
		     o     easing (function) easing,
		     o     speed (function) gets or sets the speed of the animation,
		     o     status (function) gets or sets the status of the animation,
		     o     stop (function) stops the animation
		     o }
		     | var rect = Snap().rect(0, 0, 10, 10);
		     | Snap.animate(0, 10, function (val) {
		     |     rect.attr({
		     |         x: val
		     |     });
		     | }, 1000);
		     | // in given context is equivalent to
		     | rect.animate({x: 10}, 1000);
		    \*/
		    Snap.animate = function (from, to, setter, ms, easing, callback) {
		        if (typeof easing == "function" && !easing.length) {
		            callback = easing;
		            easing = mina.linear;
		        }
		        var now = mina.time(),
		            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
		        callback && eve.once("mina.finish." + anim.id, callback);
		        return anim;
		    };
		    /*\
		     * Element.stop
		     [ method ]
		     **
		     * Stops all the animations for the current element
		     **
		     = (Element) the current element
		    \*/
		    elproto.stop = function () {
		        var anims = this.inAnim();
		        for (var i = 0, ii = anims.length; i < ii; i++) {
		            anims[i].stop();
		        }
		        return this;
		    };
		    /*\
		     * Element.animate
		     [ method ]
		     **
		     * Animates the given attributes of the element
		     **
		     - attrs (object) key-value pairs of destination attributes
		     - duration (number) duration of the animation in milliseconds
		     - easing (function) #optional easing function from @mina or custom
		     - callback (function) #optional callback function that executes when the animation ends
		     = (Element) the current element
		    \*/
		    elproto.animate = function (attrs, ms, easing, callback) {
		        if (typeof easing == "function" && !easing.length) {
		            callback = easing;
		            easing = mina.linear;
		        }
		        if (attrs instanceof Animation) {
		            callback = attrs.callback;
		            easing = attrs.easing;
		            ms = attrs.dur;
		            attrs = attrs.attr;
		        }
		        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
		            el = this;
		        for (var key in attrs) if (attrs[has](key)) {
		            if (el.equal) {
		                eq = el.equal(key, Str(attrs[key]));
		                from = eq.from;
		                to = eq.to;
		                f = eq.f;
		            } else {
		                from = +el.attr(key);
		                to = +attrs[key];
		            }
		            var len = is(from, "array") ? from.length : 1;
		            keys[key] = slice(fkeys.length, fkeys.length + len, f);
		            fkeys = fkeys.concat(from);
		            tkeys = tkeys.concat(to);
		        }
		        var now = mina.time(),
		            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
		                var attr = {};
		                for (var key in keys) if (keys[has](key)) {
		                    attr[key] = keys[key](val);
		                }
		                el.attr(attr);
		            }, easing);
		        el.anims[anim.id] = anim;
		        anim._attrs = attrs;
		        anim._callback = callback;
		        eve("snap.animcreated." + el.id, anim);
		        eve.once("mina.finish." + anim.id, function () {
		            delete el.anims[anim.id];
		            callback && callback.call(el);
		        });
		        eve.once("mina.stop." + anim.id, function () {
		            delete el.anims[anim.id];
		        });
		        return el;
		    };
		    var eldata = {};
		    /*\
		     * Element.data
		     [ method ]
		     **
		     * Adds or retrieves given value associated with given key. (Don’t confuse
		     * with `data-` attributes)
		     *
		     * See also @Element.removeData
		     - key (string) key to store data
		     - value (any) #optional value to store
		     = (object) @Element
		     * or, if value is not specified:
		     = (any) value
		     > Usage
		     | for (var i = 0, i < 5, i++) {
		     |     paper.circle(10 + 15 * i, 10, 10)
		     |          .attr({fill: "#000"})
		     |          .data("i", i)
		     |          .click(function () {
		     |             alert(this.data("i"));
		     |          });
		     | }
		    \*/
		    elproto.data = function (key, value) {
		        var data = eldata[this.id] = eldata[this.id] || {};
		        if (arguments.length == 0){
		            eve("snap.data.get." + this.id, this, data, null);
		            return data;
		        }
		        if (arguments.length == 1) {
		            if (Snap.is(key, "object")) {
		                for (var i in key) if (key[has](i)) {
		                    this.data(i, key[i]);
		                }
		                return this;
		            }
		            eve("snap.data.get." + this.id, this, data[key], key);
		            return data[key];
		        }
		        data[key] = value;
		        eve("snap.data.set." + this.id, this, value, key);
		        return this;
		    };
		    /*\
		     * Element.removeData
		     [ method ]
		     **
		     * Removes value associated with an element by given key.
		     * If key is not provided, removes all the data of the element.
		     - key (string) #optional key
		     = (object) @Element
		    \*/
		    elproto.removeData = function (key) {
		        if (key == null) {
		            eldata[this.id] = {};
		        } else {
		            eldata[this.id] && delete eldata[this.id][key];
		        }
		        return this;
		    };
		    /*\
		     * Element.outerSVG
		     [ method ]
		     **
		     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
		     *
		     * See also @Element.innerSVG
		     = (string) SVG code for the element
		    \*/
		    /*\
		     * Element.toString
		     [ method ]
		     **
		     * See @Element.outerSVG
		    \*/
		    elproto.outerSVG = elproto.toString = toString(1);
		    /*\
		     * Element.innerSVG
		     [ method ]
		     **
		     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
		     = (string) SVG code for the element
		    \*/
		    elproto.innerSVG = toString();
		    function toString(type) {
		        return function () {
		            var res = type ? "<" + this.type : "",
		                attr = this.node.attributes,
		                chld = this.node.childNodes;
		            if (type) {
		                for (var i = 0, ii = attr.length; i < ii; i++) {
		                    res += " " + attr[i].name + '="' +
		                            attr[i].value.replace(/"/g, '\\"') + '"';
		                }
		            }
		            if (chld.length) {
		                type && (res += ">");
		                for (i = 0, ii = chld.length; i < ii; i++) {
		                    if (chld[i].nodeType == 3) {
		                        res += chld[i].nodeValue;
		                    } else if (chld[i].nodeType == 1) {
		                        res += wrap(chld[i]).toString();
		                    }
		                }
		                type && (res += "</" + this.type + ">");
		            } else {
		                type && (res += "/>");
		            }
		            return res;
		        };
		    }
		    elproto.toDataURL = function () {
		        if (window && window.btoa) {
		            var bb = this.getBBox(),
		                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
		                x: +bb.x.toFixed(3),
		                y: +bb.y.toFixed(3),
		                width: +bb.width.toFixed(3),
		                height: +bb.height.toFixed(3),
		                contents: this.outerSVG()
		            });
		            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
		        }
		    };
		    /*\
		     * Fragment.select
		     [ method ]
		     **
		     * See @Element.select
		    \*/
		    Fragment.prototype.select = elproto.select;
		    /*\
		     * Fragment.selectAll
		     [ method ]
		     **
		     * See @Element.selectAll
		    \*/
		    Fragment.prototype.selectAll = elproto.selectAll;
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var objectToString = Object.prototype.toString,
		        Str = String,
		        math = Math,
		        E = "";
		    function Matrix(a, b, c, d, e, f) {
		        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
		            this.a = a.a;
		            this.b = a.b;
		            this.c = a.c;
		            this.d = a.d;
		            this.e = a.e;
		            this.f = a.f;
		            return;
		        }
		        if (a != null) {
		            this.a = +a;
		            this.b = +b;
		            this.c = +c;
		            this.d = +d;
		            this.e = +e;
		            this.f = +f;
		        } else {
		            this.a = 1;
		            this.b = 0;
		            this.c = 0;
		            this.d = 1;
		            this.e = 0;
		            this.f = 0;
		        }
		    }
		    (function (matrixproto) {
		        /*\
		         * Matrix.add
		         [ method ]
		         **
		         * Adds the given matrix to existing one
		         - a (number)
		         - b (number)
		         - c (number)
		         - d (number)
		         - e (number)
		         - f (number)
		         * or
		         - matrix (object) @Matrix
		        \*/
		        matrixproto.add = function (a, b, c, d, e, f) {
		            var out = [[], [], []],
		                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
		                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
		                x, y, z, res;
		
		            if (a && a instanceof Matrix) {
		                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
		            }
		
		            for (x = 0; x < 3; x++) {
		                for (y = 0; y < 3; y++) {
		                    res = 0;
		                    for (z = 0; z < 3; z++) {
		                        res += m[x][z] * matrix[z][y];
		                    }
		                    out[x][y] = res;
		                }
		            }
		            this.a = out[0][0];
		            this.b = out[1][0];
		            this.c = out[0][1];
		            this.d = out[1][1];
		            this.e = out[0][2];
		            this.f = out[1][2];
		            return this;
		        };
		        /*\
		         * Matrix.invert
		         [ method ]
		         **
		         * Returns an inverted version of the matrix
		         = (object) @Matrix
		        \*/
		        matrixproto.invert = function () {
		            var me = this,
		                x = me.a * me.d - me.b * me.c;
		            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
		        };
		        /*\
		         * Matrix.clone
		         [ method ]
		         **
		         * Returns a copy of the matrix
		         = (object) @Matrix
		        \*/
		        matrixproto.clone = function () {
		            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
		        };
		        /*\
		         * Matrix.translate
		         [ method ]
		         **
		         * Translate the matrix
		         - x (number) horizontal offset distance
		         - y (number) vertical offset distance
		        \*/
		        matrixproto.translate = function (x, y) {
		            return this.add(1, 0, 0, 1, x, y);
		        };
		        /*\
		         * Matrix.scale
		         [ method ]
		         **
		         * Scales the matrix
		         - x (number) amount to be scaled, with `1` resulting in no change
		         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
		         - cx (number) #optional horizontal origin point from which to scale
		         - cy (number) #optional vertical origin point from which to scale
		         * Default cx, cy is the middle point of the element.
		        \*/
		        matrixproto.scale = function (x, y, cx, cy) {
		            y == null && (y = x);
		            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
		            this.add(x, 0, 0, y, 0, 0);
		            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
		            return this;
		        };
		        /*\
		         * Matrix.rotate
		         [ method ]
		         **
		         * Rotates the matrix
		         - a (number) angle of rotation, in degrees
		         - x (number) horizontal origin point from which to rotate
		         - y (number) vertical origin point from which to rotate
		        \*/
		        matrixproto.rotate = function (a, x, y) {
		            a = Snap.rad(a);
		            x = x || 0;
		            y = y || 0;
		            var cos = +math.cos(a).toFixed(9),
		                sin = +math.sin(a).toFixed(9);
		            this.add(cos, sin, -sin, cos, x, y);
		            return this.add(1, 0, 0, 1, -x, -y);
		        };
		        /*\
		         * Matrix.x
		         [ method ]
		         **
		         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
		         - x (number)
		         - y (number)
		         = (number) x
		        \*/
		        matrixproto.x = function (x, y) {
		            return x * this.a + y * this.c + this.e;
		        };
		        /*\
		         * Matrix.y
		         [ method ]
		         **
		         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
		         - x (number)
		         - y (number)
		         = (number) y
		        \*/
		        matrixproto.y = function (x, y) {
		            return x * this.b + y * this.d + this.f;
		        };
		        matrixproto.get = function (i) {
		            return +this[Str.fromCharCode(97 + i)].toFixed(4);
		        };
		        matrixproto.toString = function () {
		            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
		        };
		        matrixproto.offset = function () {
		            return [this.e.toFixed(4), this.f.toFixed(4)];
		        };
		        function norm(a) {
		            return a[0] * a[0] + a[1] * a[1];
		        }
		        function normalize(a) {
		            var mag = math.sqrt(norm(a));
		            a[0] && (a[0] /= mag);
		            a[1] && (a[1] /= mag);
		        }
		        /*\
		         * Matrix.determinant
		         [ method ]
		         **
		         * Finds determinant of the given matrix.
		         = (number) determinant
		        \*/
		        matrixproto.determinant = function () {
		            return this.a * this.d - this.b * this.c;
		        };
		        /*\
		         * Matrix.split
		         [ method ]
		         **
		         * Splits matrix into primitive transformations
		         = (object) in format:
		         o dx (number) translation by x
		         o dy (number) translation by y
		         o scalex (number) scale by x
		         o scaley (number) scale by y
		         o shear (number) shear
		         o rotate (number) rotation in deg
		         o isSimple (boolean) could it be represented via simple transformations
		        \*/
		        matrixproto.split = function () {
		            var out = {};
		            // translation
		            out.dx = this.e;
		            out.dy = this.f;
		
		            // scale and shear
		            var row = [[this.a, this.c], [this.b, this.d]];
		            out.scalex = math.sqrt(norm(row[0]));
		            normalize(row[0]);
		
		            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
		            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];
		
		            out.scaley = math.sqrt(norm(row[1]));
		            normalize(row[1]);
		            out.shear /= out.scaley;
		
		            if (this.determinant() < 0) {
		                out.scalex = -out.scalex;
		            }
		
		            // rotation
		            var sin = -row[0][1],
		                cos = row[1][1];
		            if (cos < 0) {
		                out.rotate = Snap.deg(math.acos(cos));
		                if (sin < 0) {
		                    out.rotate = 360 - out.rotate;
		                }
		            } else {
		                out.rotate = Snap.deg(math.asin(sin));
		            }
		
		            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
		            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
		            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
		            return out;
		        };
		        /*\
		         * Matrix.toTransformString
		         [ method ]
		         **
		         * Returns transform string that represents given matrix
		         = (string) transform string
		        \*/
		        matrixproto.toTransformString = function (shorter) {
		            var s = shorter || this.split();
		            if (!+s.shear.toFixed(9)) {
		                s.scalex = +s.scalex.toFixed(4);
		                s.scaley = +s.scaley.toFixed(4);
		                s.rotate = +s.rotate.toFixed(4);
		                return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + 
		                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
		                        (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
		            } else {
		                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
		            }
		        };
		    })(Matrix.prototype);
		    /*\
		     * Snap.Matrix
		     [ method ]
		     **
		     * Matrix constructor, extend on your own risk.
		     * To create matrices use @Snap.matrix.
		    \*/
		    Snap.Matrix = Matrix;
		    /*\
		     * Snap.matrix
		     [ method ]
		     **
		     * Utility method
		     **
		     * Returns a matrix based on the given parameters
		     - a (number)
		     - b (number)
		     - c (number)
		     - d (number)
		     - e (number)
		     - f (number)
		     * or
		     - svgMatrix (SVGMatrix)
		     = (object) @Matrix
		    \*/
		    Snap.matrix = function (a, b, c, d, e, f) {
		        return new Matrix(a, b, c, d, e, f);
		    };
		});
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var has = "hasOwnProperty",
		        make = Snap._.make,
		        wrap = Snap._.wrap,
		        is = Snap.is,
		        getSomeDefs = Snap._.getSomeDefs,
		        reURLValue = /^url\(#?([^)]+)\)$/,
		        $ = Snap._.$,
		        URL = Snap.url,
		        Str = String,
		        separator = Snap._.separator,
		        E = "";
		    // Attributes event handlers
		    eve.on("snap.util.attr.mask", function (value) {
		        if (value instanceof Element || value instanceof Fragment) {
		            eve.stop();
		            if (value instanceof Fragment && value.node.childNodes.length == 1) {
		                value = value.node.firstChild;
		                getSomeDefs(this).appendChild(value);
		                value = wrap(value);
		            }
		            if (value.type == "mask") {
		                var mask = value;
		            } else {
		                mask = make("mask", getSomeDefs(this));
		                mask.node.appendChild(value.node);
		            }
		            !mask.node.id && $(mask.node, {
		                id: mask.id
		            });
		            $(this.node, {
		                mask: URL(mask.id)
		            });
		        }
		    });
		    (function (clipIt) {
		        eve.on("snap.util.attr.clip", clipIt);
		        eve.on("snap.util.attr.clip-path", clipIt);
		        eve.on("snap.util.attr.clipPath", clipIt);
		    }(function (value) {
		        if (value instanceof Element || value instanceof Fragment) {
		            eve.stop();
		            if (value.type == "clipPath") {
		                var clip = value;
		            } else {
		                clip = make("clipPath", getSomeDefs(this));
		                clip.node.appendChild(value.node);
		                !clip.node.id && $(clip.node, {
		                    id: clip.id
		                });
		            }
		            $(this.node, {
		                "clip-path": URL(clip.node.id || clip.id)
		            });
		        }
		    }));
		    function fillStroke(name) {
		        return function (value) {
		            eve.stop();
		            if (value instanceof Fragment && value.node.childNodes.length == 1 &&
		                (value.node.firstChild.tagName == "radialGradient" ||
		                value.node.firstChild.tagName == "linearGradient" ||
		                value.node.firstChild.tagName == "pattern")) {
		                value = value.node.firstChild;
		                getSomeDefs(this).appendChild(value);
		                value = wrap(value);
		            }
		            if (value instanceof Element) {
		                if (value.type == "radialGradient" || value.type == "linearGradient"
		                   || value.type == "pattern") {
		                    if (!value.node.id) {
		                        $(value.node, {
		                            id: value.id
		                        });
		                    }
		                    var fill = URL(value.node.id);
		                } else {
		                    fill = value.attr(name);
		                }
		            } else {
		                fill = Snap.color(value);
		                if (fill.error) {
		                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
		                    if (grad) {
		                        if (!grad.node.id) {
		                            $(grad.node, {
		                                id: grad.id
		                            });
		                        }
		                        fill = URL(grad.node.id);
		                    } else {
		                        fill = value;
		                    }
		                } else {
		                    fill = Str(fill);
		                }
		            }
		            var attrs = {};
		            attrs[name] = fill;
		            $(this.node, attrs);
		            this.node.style[name] = E;
		        };
		    }
		    eve.on("snap.util.attr.fill", fillStroke("fill"));
		    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
		    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
		    eve.on("snap.util.grad.parse", function parseGrad(string) {
		        string = Str(string);
		        var tokens = string.match(gradrg);
		        if (!tokens) {
		            return null;
		        }
		        var type = tokens[1],
		            params = tokens[2],
		            stops = tokens[3];
		        params = params.split(/\s*,\s*/).map(function (el) {
		            return +el == el ? +el : el;
		        });
		        if (params.length == 1 && params[0] == 0) {
		            params = [];
		        }
		        stops = stops.split("-");
		        stops = stops.map(function (el) {
		            el = el.split(":");
		            var out = {
		                color: el[0]
		            };
		            if (el[1]) {
		                out.offset = parseFloat(el[1]);
		            }
		            return out;
		        });
		        return {
		            type: type,
		            params: params,
		            stops: stops
		        };
		    });
		
		    eve.on("snap.util.attr.d", function (value) {
		        eve.stop();
		        if (is(value, "array") && is(value[0], "array")) {
		            value = Snap.path.toString.call(value);
		        }
		        value = Str(value);
		        if (value.match(/[ruo]/i)) {
		            value = Snap.path.toAbsolute(value);
		        }
		        $(this.node, {d: value});
		    })(-1);
		    eve.on("snap.util.attr.#text", function (value) {
		        eve.stop();
		        value = Str(value);
		        var txt = glob.doc.createTextNode(value);
		        while (this.node.firstChild) {
		            this.node.removeChild(this.node.firstChild);
		        }
		        this.node.appendChild(txt);
		    })(-1);
		    eve.on("snap.util.attr.path", function (value) {
		        eve.stop();
		        this.attr({d: value});
		    })(-1);
		    eve.on("snap.util.attr.class", function (value) {
		        eve.stop();
		        this.node.className.baseVal = value;
		    })(-1);
		    eve.on("snap.util.attr.viewBox", function (value) {
		        var vb;
		        if (is(value, "object") && "x" in value) {
		            vb = [value.x, value.y, value.width, value.height].join(" ");
		        } else if (is(value, "array")) {
		            vb = value.join(" ");
		        } else {
		            vb = value;
		        }
		        $(this.node, {
		            viewBox: vb
		        });
		        eve.stop();
		    })(-1);
		    eve.on("snap.util.attr.transform", function (value) {
		        this.transform(value);
		        eve.stop();
		    })(-1);
		    eve.on("snap.util.attr.r", function (value) {
		        if (this.type == "rect") {
		            eve.stop();
		            $(this.node, {
		                rx: value,
		                ry: value
		            });
		        }
		    })(-1);
		    eve.on("snap.util.attr.textpath", function (value) {
		        eve.stop();
		        if (this.type == "text") {
		            var id, tp, node;
		            if (!value && this.textPath) {
		                tp = this.textPath;
		                while (tp.node.firstChild) {
		                    this.node.appendChild(tp.node.firstChild);
		                }
		                tp.remove();
		                delete this.textPath;
		                return;
		            }
		            if (is(value, "string")) {
		                var defs = getSomeDefs(this),
		                    path = wrap(defs.parentNode).path(value);
		                defs.appendChild(path.node);
		                id = path.id;
		                path.attr({id: id});
		            } else {
		                value = wrap(value);
		                if (value instanceof Element) {
		                    id = value.attr("id");
		                    if (!id) {
		                        id = value.id;
		                        value.attr({id: id});
		                    }
		                }
		            }
		            if (id) {
		                tp = this.textPath;
		                node = this.node;
		                if (tp) {
		                    tp.attr({"xlink:href": "#" + id});
		                } else {
		                    tp = $("textPath", {
		                        "xlink:href": "#" + id
		                    });
		                    while (node.firstChild) {
		                        tp.appendChild(node.firstChild);
		                    }
		                    node.appendChild(tp);
		                    this.textPath = wrap(tp);
		                }
		            }
		        }
		    })(-1);
		    eve.on("snap.util.attr.text", function (value) {
		        if (this.type == "text") {
		            var i = 0,
		                node = this.node,
		                tuner = function (chunk) {
		                    var out = $("tspan");
		                    if (is(chunk, "array")) {
		                        for (var i = 0; i < chunk.length; i++) {
		                            out.appendChild(tuner(chunk[i]));
		                        }
		                    } else {
		                        out.appendChild(glob.doc.createTextNode(chunk));
		                    }
		                    out.normalize && out.normalize();
		                    return out;
		                };
		            while (node.firstChild) {
		                node.removeChild(node.firstChild);
		            }
		            var tuned = tuner(value);
		            while (tuned.firstChild) {
		                node.appendChild(tuned.firstChild);
		            }
		        }
		        eve.stop();
		    })(-1);
		    function setFontSize(value) {
		        eve.stop();
		        if (value == +value) {
		            value += "px";
		        }
		        this.node.style.fontSize = value;
		    }
		    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
		    eve.on("snap.util.attr.font-size", setFontSize)(-1);
		
		
		    eve.on("snap.util.getattr.transform", function () {
		        eve.stop();
		        return this.transform();
		    })(-1);
		    eve.on("snap.util.getattr.textpath", function () {
		        eve.stop();
		        return this.textPath;
		    })(-1);
		    // Markers
		    (function () {
		        function getter(end) {
		            return function () {
		                eve.stop();
		                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
		                if (style == "none") {
		                    return style;
		                } else {
		                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
		                }
		            };
		        }
		        function setter(end) {
		            return function (value) {
		                eve.stop();
		                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
		                if (value == "" || !value) {
		                    this.node.style[name] = "none";
		                    return;
		                }
		                if (value.type == "marker") {
		                    var id = value.node.id;
		                    if (!id) {
		                        $(value.node, {id: value.id});
		                    }
		                    this.node.style[name] = URL(id);
		                    return;
		                }
		            };
		        }
		        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
		        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
		        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
		        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
		        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
		        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
		        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
		        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
		        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
		        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
		        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
		        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
		    }());
		    eve.on("snap.util.getattr.r", function () {
		        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
		            eve.stop();
		            return $(this.node, "rx");
		        }
		    })(-1);
		    function textExtract(node) {
		        var out = [];
		        var children = node.childNodes;
		        for (var i = 0, ii = children.length; i < ii; i++) {
		            var chi = children[i];
		            if (chi.nodeType == 3) {
		                out.push(chi.nodeValue);
		            }
		            if (chi.tagName == "tspan") {
		                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
		                    out.push(chi.firstChild.nodeValue);
		                } else {
		                    out.push(textExtract(chi));
		                }
		            }
		        }
		        return out;
		    }
		    eve.on("snap.util.getattr.text", function () {
		        if (this.type == "text" || this.type == "tspan") {
		            eve.stop();
		            var out = textExtract(this.node);
		            return out.length == 1 ? out[0] : out;
		        }
		    })(-1);
		    eve.on("snap.util.getattr.#text", function () {
		        return this.node.textContent;
		    })(-1);
		    eve.on("snap.util.getattr.viewBox", function () {
		        eve.stop();
		        var vb = $(this.node, "viewBox");
		        if (vb) {
		            vb = vb.split(separator);
		            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
		        } else {
		            return;
		        }
		    })(-1);
		    eve.on("snap.util.getattr.points", function () {
		        var p = $(this.node, "points");
		        eve.stop();
		        if (p) {
		            return p.split(separator);
		        } else {
		            return;
		        }
		    })(-1);
		    eve.on("snap.util.getattr.path", function () {
		        var p = $(this.node, "d");
		        eve.stop();
		        return p;
		    })(-1);
		    eve.on("snap.util.getattr.class", function () {
		        return this.node.className.baseVal;
		    })(-1);
		    function getFontSize() {
		        eve.stop();
		        return this.node.style.fontSize;
		    }
		    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
		    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
		});
		
		// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		// http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var rgNotSpace = /\S+/g,
		        rgBadSpace = /[\t\r\n\f]/g,
		        rgTrim = /(^\s+|\s+$)/g,
		        Str = String,
		        elproto = Element.prototype;
		    /*\
		     * Element.addClass
		     [ method ]
		     **
		     * Adds given class name or list of class names to the element.
		     - value (string) class name or space separated list of class names
		     **
		     = (Element) original element.
		    \*/
		    elproto.addClass = function (value) {
		        var classes = Str(value || "").match(rgNotSpace) || [],
		            elem = this.node,
		            className = elem.className.baseVal,
		            curClasses = className.match(rgNotSpace) || [],
		            j,
		            pos,
		            clazz,
		            finalValue;
		
		        if (classes.length) {
		            j = 0;
		            while ((clazz = classes[j++])) {
		                pos = curClasses.indexOf(clazz);
		                if (!~pos) {
		                    curClasses.push(clazz);
		                }
		            }
		
		            finalValue = curClasses.join(" ");
		            if (className != finalValue) {
		                elem.className.baseVal = finalValue;
		            }
		        }
		        return this;
		    };
		    /*\
		     * Element.removeClass
		     [ method ]
		     **
		     * Removes given class name or list of class names from the element.
		     - value (string) class name or space separated list of class names
		     **
		     = (Element) original element.
		    \*/
		    elproto.removeClass = function (value) {
		        var classes = Str(value || "").match(rgNotSpace) || [],
		            elem = this.node,
		            className = elem.className.baseVal,
		            curClasses = className.match(rgNotSpace) || [],
		            j,
		            pos,
		            clazz,
		            finalValue;
		        if (curClasses.length) {
		            j = 0;
		            while ((clazz = classes[j++])) {
		                pos = curClasses.indexOf(clazz);
		                if (~pos) {
		                    curClasses.splice(pos, 1);
		                }
		            }
		
		            finalValue = curClasses.join(" ");
		            if (className != finalValue) {
		                elem.className.baseVal = finalValue;
		            }
		        }
		        return this;
		    };
		    /*\
		     * Element.hasClass
		     [ method ]
		     **
		     * Checks if the element has a given class name in the list of class names applied to it.
		     - value (string) class name
		     **
		     = (boolean) `true` if the element has given class
		    \*/
		    elproto.hasClass = function (value) {
		        var elem = this.node,
		            className = elem.className.baseVal,
		            curClasses = className.match(rgNotSpace) || [];
		        return !!~curClasses.indexOf(value);
		    };
		    /*\
		     * Element.toggleClass
		     [ method ]
		     **
		     * Add or remove one or more classes from the element, depending on either
		     * the class’s presence or the value of the `flag` argument.
		     - value (string) class name or space separated list of class names
		     - flag (boolean) value to determine whether the class should be added or removed
		     **
		     = (Element) original element.
		    \*/
		    elproto.toggleClass = function (value, flag) {
		        if (flag != null) {
		            if (flag) {
		                return this.addClass(value);
		            } else {
		                return this.removeClass(value);
		            }
		        }
		        var classes = (value || "").match(rgNotSpace) || [],
		            elem = this.node,
		            className = elem.className.baseVal,
		            curClasses = className.match(rgNotSpace) || [],
		            j,
		            pos,
		            clazz,
		            finalValue;
		        j = 0;
		        while ((clazz = classes[j++])) {
		            pos = curClasses.indexOf(clazz);
		            if (~pos) {
		                curClasses.splice(pos, 1);
		            } else {
		                curClasses.push(clazz);
		            }
		        }
		
		        finalValue = curClasses.join(" ");
		        if (className != finalValue) {
		            elem.className.baseVal = finalValue;
		        }
		        return this;
		    };
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var operators = {
		            "+": function (x, y) {
		                    return x + y;
		                },
		            "-": function (x, y) {
		                    return x - y;
		                },
		            "/": function (x, y) {
		                    return x / y;
		                },
		            "*": function (x, y) {
		                    return x * y;
		                }
		        },
		        Str = String,
		        reUnit = /[a-z]+$/i,
		        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
		    function getNumber(val) {
		        return val;
		    }
		    function getUnit(unit) {
		        return function (val) {
		            return +val.toFixed(3) + unit;
		        };
		    }
		    eve.on("snap.util.attr", function (val) {
		        var plus = Str(val).match(reAddon);
		        if (plus) {
		            var evnt = eve.nt(),
		                name = evnt.substring(evnt.lastIndexOf(".") + 1),
		                a = this.attr(name),
		                atr = {};
		            eve.stop();
		            var unit = plus[3] || "",
		                aUnit = a.match(reUnit),
		                op = operators[plus[1]];
		            if (aUnit && aUnit == unit) {
		                val = op(parseFloat(a), +plus[2]);
		            } else {
		                a = this.asPX(name);
		                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
		            }
		            if (isNaN(a) || isNaN(val)) {
		                return;
		            }
		            atr[name] = val;
		            this.attr(atr);
		        }
		    })(-10);
		    eve.on("snap.util.equal", function (name, b) {
		        var A, B, a = Str(this.attr(name) || ""),
		            el = this,
		            bplus = Str(b).match(reAddon);
		        if (bplus) {
		            eve.stop();
		            var unit = bplus[3] || "",
		                aUnit = a.match(reUnit),
		                op = operators[bplus[1]];
		            if (aUnit && aUnit == unit) {
		                return {
		                    from: parseFloat(a),
		                    to: op(parseFloat(a), +bplus[2]),
		                    f: getUnit(aUnit)
		                };
		            } else {
		                a = this.asPX(name);
		                return {
		                    from: a,
		                    to: op(a, this.asPX(name, bplus[2] + unit)),
		                    f: getNumber
		                };
		            }
		        }
		    })(-10);
		});
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var proto = Paper.prototype,
		        is = Snap.is;
		    /*\
		     * Paper.rect
		     [ method ]
		     *
		     * Draws a rectangle
		     **
		     - x (number) x coordinate of the top left corner
		     - y (number) y coordinate of the top left corner
		     - width (number) width
		     - height (number) height
		     - rx (number) #optional horizontal radius for rounded corners, default is 0
		     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
		     = (object) the `rect` element
		     **
		     > Usage
		     | // regular rectangle
		     | var c = paper.rect(10, 10, 50, 50);
		     | // rectangle with rounded corners
		     | var c = paper.rect(40, 40, 50, 50, 10);
		    \*/
		    proto.rect = function (x, y, w, h, rx, ry) {
		        var attr;
		        if (ry == null) {
		            ry = rx;
		        }
		        if (is(x, "object") && x == "[object Object]") {
		            attr = x;
		        } else if (x != null) {
		            attr = {
		                x: x,
		                y: y,
		                width: w,
		                height: h
		            };
		            if (rx != null) {
		                attr.rx = rx;
		                attr.ry = ry;
		            }
		        }
		        return this.el("rect", attr);
		    };
		    /*\
		     * Paper.circle
		     [ method ]
		     **
		     * Draws a circle
		     **
		     - x (number) x coordinate of the centre
		     - y (number) y coordinate of the centre
		     - r (number) radius
		     = (object) the `circle` element
		     **
		     > Usage
		     | var c = paper.circle(50, 50, 40);
		    \*/
		    proto.circle = function (cx, cy, r) {
		        var attr;
		        if (is(cx, "object") && cx == "[object Object]") {
		            attr = cx;
		        } else if (cx != null) {
		            attr = {
		                cx: cx,
		                cy: cy,
		                r: r
		            };
		        }
		        return this.el("circle", attr);
		    };
		
		    var preload = (function () {
		        function onerror() {
		            this.parentNode.removeChild(this);
		        }
		        return function (src, f) {
		            var img = glob.doc.createElement("img"),
		                body = glob.doc.body;
		            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
		            img.onload = function () {
		                f.call(img);
		                img.onload = img.onerror = null;
		                body.removeChild(img);
		            };
		            img.onerror = onerror;
		            body.appendChild(img);
		            img.src = src;
		        };
		    }());
		
		    /*\
		     * Paper.image
		     [ method ]
		     **
		     * Places an image on the surface
		     **
		     - src (string) URI of the source image
		     - x (number) x offset position
		     - y (number) y offset position
		     - width (number) width of the image
		     - height (number) height of the image
		     = (object) the `image` element
		     * or
		     = (object) Snap element object with type `image`
		     **
		     > Usage
		     | var c = paper.image("apple.png", 10, 10, 80, 80);
		    \*/
		    proto.image = function (src, x, y, width, height) {
		        var el = this.el("image");
		        if (is(src, "object") && "src" in src) {
		            el.attr(src);
		        } else if (src != null) {
		            var set = {
		                "xlink:href": src,
		                preserveAspectRatio: "none"
		            };
		            if (x != null && y != null) {
		                set.x = x;
		                set.y = y;
		            }
		            if (width != null && height != null) {
		                set.width = width;
		                set.height = height;
		            } else {
		                preload(src, function () {
		                    Snap._.$(el.node, {
		                        width: this.offsetWidth,
		                        height: this.offsetHeight
		                    });
		                });
		            }
		            Snap._.$(el.node, set);
		        }
		        return el;
		    };
		    /*\
		     * Paper.ellipse
		     [ method ]
		     **
		     * Draws an ellipse
		     **
		     - x (number) x coordinate of the centre
		     - y (number) y coordinate of the centre
		     - rx (number) horizontal radius
		     - ry (number) vertical radius
		     = (object) the `ellipse` element
		     **
		     > Usage
		     | var c = paper.ellipse(50, 50, 40, 20);
		    \*/
		    proto.ellipse = function (cx, cy, rx, ry) {
		        var attr;
		        if (is(cx, "object") && cx == "[object Object]") {
		            attr = cx;
		        } else if (cx != null) {
		            attr ={
		                cx: cx,
		                cy: cy,
		                rx: rx,
		                ry: ry
		            };
		        }
		        return this.el("ellipse", attr);
		    };
		    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
		    /*\
		     * Paper.path
		     [ method ]
		     **
		     * Creates a `<path>` element using the given string as the path's definition
		     - pathString (string) #optional path string in SVG format
		     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
		     | "M10,20L30,40"
		     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
		     *
		     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
		     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
		     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
		     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
		     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
		     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
		     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
		     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
		     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
		     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
		     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
		     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
		     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
		     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
		     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
		     > Usage
		     | var c = paper.path("M10 10L90 90");
		     | // draw a diagonal line:
		     | // move to 10,10, line to 90,90
		    \*/
		    proto.path = function (d) {
		        var attr;
		        if (is(d, "object") && !is(d, "array")) {
		            attr = d;
		        } else if (d) {
		            attr = {d: d};
		        }
		        return this.el("path", attr);
		    };
		    /*\
		     * Paper.g
		     [ method ]
		     **
		     * Creates a group element
		     **
		     - varargs (…) #optional elements to nest within the group
		     = (object) the `g` element
		     **
		     > Usage
		     | var c1 = paper.circle(),
		     |     c2 = paper.rect(),
		     |     g = paper.g(c2, c1); // note that the order of elements is different
		     * or
		     | var c1 = paper.circle(),
		     |     c2 = paper.rect(),
		     |     g = paper.g();
		     | g.add(c2, c1);
		    \*/
		    /*\
		     * Paper.group
		     [ method ]
		     **
		     * See @Paper.g
		    \*/
		    proto.group = proto.g = function (first) {
		        var attr,
		            el = this.el("g");
		        if (arguments.length == 1 && first && !first.type) {
		            el.attr(first);
		        } else if (arguments.length) {
		            el.add(Array.prototype.slice.call(arguments, 0));
		        }
		        return el;
		    };
		    /*\
		     * Paper.svg
		     [ method ]
		     **
		     * Creates a nested SVG element.
		     - x (number) @optional X of the element
		     - y (number) @optional Y of the element
		     - width (number) @optional width of the element
		     - height (number) @optional height of the element
		     - vbx (number) @optional viewbox X
		     - vby (number) @optional viewbox Y
		     - vbw (number) @optional viewbox width
		     - vbh (number) @optional viewbox height
		     **
		     = (object) the `svg` element
		     **
		    \*/
		    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
		        var attrs = {};
		        if (is(x, "object") && y == null) {
		            attrs = x;
		        } else {
		            if (x != null) {
		                attrs.x = x;
		            }
		            if (y != null) {
		                attrs.y = y;
		            }
		            if (width != null) {
		                attrs.width = width;
		            }
		            if (height != null) {
		                attrs.height = height;
		            }
		            if (vbx != null && vby != null && vbw != null && vbh != null) {
		                attrs.viewBox = [vbx, vby, vbw, vbh];
		            }
		        }
		        return this.el("svg", attrs);
		    };
		    /*\
		     * Paper.mask
		     [ method ]
		     **
		     * Equivalent in behaviour to @Paper.g, except it’s a mask.
		     **
		     = (object) the `mask` element
		     **
		    \*/
		    proto.mask = function (first) {
		        var attr,
		            el = this.el("mask");
		        if (arguments.length == 1 && first && !first.type) {
		            el.attr(first);
		        } else if (arguments.length) {
		            el.add(Array.prototype.slice.call(arguments, 0));
		        }
		        return el;
		    };
		    /*\
		     * Paper.ptrn
		     [ method ]
		     **
		     * Equivalent in behaviour to @Paper.g, except it’s a pattern.
		     - x (number) @optional X of the element
		     - y (number) @optional Y of the element
		     - width (number) @optional width of the element
		     - height (number) @optional height of the element
		     - vbx (number) @optional viewbox X
		     - vby (number) @optional viewbox Y
		     - vbw (number) @optional viewbox width
		     - vbh (number) @optional viewbox height
		     **
		     = (object) the `pattern` element
		     **
		    \*/
		    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
		        if (is(x, "object")) {
		            var attr = x;
		        } else {
		            attr = {patternUnits: "userSpaceOnUse"};
		            if (x) {
		                attr.x = x;
		            }
		            if (y) {
		                attr.y = y;
		            }
		            if (width != null) {
		                attr.width = width;
		            }
		            if (height != null) {
		                attr.height = height;
		            }
		            if (vx != null && vy != null && vw != null && vh != null) {
		                attr.viewBox = [vx, vy, vw, vh];
		            } else {
		                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
		            }
		        }
		        return this.el("pattern", attr);
		    };
		    /*\
		     * Paper.use
		     [ method ]
		     **
		     * Creates a <use> element.
		     - id (string) @optional id of element to link
		     * or
		     - id (Element) @optional element to link
		     **
		     = (object) the `use` element
		     **
		    \*/
		    proto.use = function (id) {
		        if (id != null) {
		            if (id instanceof Element) {
		                if (!id.attr("id")) {
		                    id.attr({id: Snap._.id(id)});
		                }
		                id = id.attr("id");
		            }
		            if (String(id).charAt() == "#") {
		                id = id.substring(1);
		            }
		            return this.el("use", {"xlink:href": "#" + id});
		        } else {
		            return Element.prototype.use.call(this);
		        }
		    };
		    /*\
		     * Paper.symbol
		     [ method ]
		     **
		     * Creates a <symbol> element.
		     - vbx (number) @optional viewbox X
		     - vby (number) @optional viewbox Y
		     - vbw (number) @optional viewbox width
		     - vbh (number) @optional viewbox height
		     = (object) the `symbol` element
		     **
		    \*/
		    proto.symbol = function (vx, vy, vw, vh) {
		        var attr = {};
		        if (vx != null && vy != null && vw != null && vh != null) {
		            attr.viewBox = [vx, vy, vw, vh];
		        }
		
		        return this.el("symbol", attr);
		    };
		    /*\
		     * Paper.text
		     [ method ]
		     **
		     * Draws a text string
		     **
		     - x (number) x coordinate position
		     - y (number) y coordinate position
		     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
		     = (object) the `text` element
		     **
		     > Usage
		     | var t1 = paper.text(50, 50, "Snap");
		     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
		     | // Text path usage
		     | t1.attr({textpath: "M10,10L100,100"});
		     | // or
		     | var pth = paper.path("M10,10L100,100");
		     | t1.attr({textpath: pth});
		    \*/
		    proto.text = function (x, y, text) {
		        var attr = {};
		        if (is(x, "object")) {
		            attr = x;
		        } else if (x != null) {
		            attr = {
		                x: x,
		                y: y,
		                text: text || ""
		            };
		        }
		        return this.el("text", attr);
		    };
		    /*\
		     * Paper.line
		     [ method ]
		     **
		     * Draws a line
		     **
		     - x1 (number) x coordinate position of the start
		     - y1 (number) y coordinate position of the start
		     - x2 (number) x coordinate position of the end
		     - y2 (number) y coordinate position of the end
		     = (object) the `line` element
		     **
		     > Usage
		     | var t1 = paper.line(50, 50, 100, 100);
		    \*/
		    proto.line = function (x1, y1, x2, y2) {
		        var attr = {};
		        if (is(x1, "object")) {
		            attr = x1;
		        } else if (x1 != null) {
		            attr = {
		                x1: x1,
		                x2: x2,
		                y1: y1,
		                y2: y2
		            };
		        }
		        return this.el("line", attr);
		    };
		    /*\
		     * Paper.polyline
		     [ method ]
		     **
		     * Draws a polyline
		     **
		     - points (array) array of points
		     * or
		     - varargs (…) points
		     = (object) the `polyline` element
		     **
		     > Usage
		     | var p1 = paper.polyline([10, 10, 100, 100]);
		     | var p2 = paper.polyline(10, 10, 100, 100);
		    \*/
		    proto.polyline = function (points) {
		        if (arguments.length > 1) {
		            points = Array.prototype.slice.call(arguments, 0);
		        }
		        var attr = {};
		        if (is(points, "object") && !is(points, "array")) {
		            attr = points;
		        } else if (points != null) {
		            attr = {points: points};
		        }
		        return this.el("polyline", attr);
		    };
		    /*\
		     * Paper.polygon
		     [ method ]
		     **
		     * Draws a polygon. See @Paper.polyline
		    \*/
		    proto.polygon = function (points) {
		        if (arguments.length > 1) {
		            points = Array.prototype.slice.call(arguments, 0);
		        }
		        var attr = {};
		        if (is(points, "object") && !is(points, "array")) {
		            attr = points;
		        } else if (points != null) {
		            attr = {points: points};
		        }
		        return this.el("polygon", attr);
		    };
		    // gradients
		    (function () {
		        var $ = Snap._.$;
		        // gradients' helpers
		        function Gstops() {
		            return this.selectAll("stop");
		        }
		        function GaddStop(color, offset) {
		            var stop = $("stop"),
		                attr = {
		                    offset: +offset + "%"
		                };
		            color = Snap.color(color);
		            attr["stop-color"] = color.hex;
		            if (color.opacity < 1) {
		                attr["stop-opacity"] = color.opacity;
		            }
		            $(stop, attr);
		            this.node.appendChild(stop);
		            return this;
		        }
		        function GgetBBox() {
		            if (this.type == "linearGradient") {
		                var x1 = $(this.node, "x1") || 0,
		                    x2 = $(this.node, "x2") || 1,
		                    y1 = $(this.node, "y1") || 0,
		                    y2 = $(this.node, "y2") || 0;
		                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
		            } else {
		                var cx = this.node.cx || .5,
		                    cy = this.node.cy || .5,
		                    r = this.node.r || 0;
		                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
		            }
		        }
		        function gradient(defs, str) {
		            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
		                el;
		            if (!grad) {
		                return null;
		            }
		            grad.params.unshift(defs);
		            if (grad.type.toLowerCase() == "l") {
		                el = gradientLinear.apply(0, grad.params);
		            } else {
		                el = gradientRadial.apply(0, grad.params);
		            }
		            if (grad.type != grad.type.toLowerCase()) {
		                $(el.node, {
		                    gradientUnits: "userSpaceOnUse"
		                });
		            }
		            var stops = grad.stops,
		                len = stops.length,
		                start = 0,
		                j = 0;
		            function seed(i, end) {
		                var step = (end - start) / (i - j);
		                for (var k = j; k < i; k++) {
		                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);
		                }
		                j = i;
		                start = end;
		            }
		            len--;
		            for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
		                seed(i, stops[i].offset);
		            }
		            stops[len].offset = stops[len].offset || 100;
		            seed(len, stops[len].offset);
		            for (i = 0; i <= len; i++) {
		                var stop = stops[i];
		                el.addStop(stop.color, stop.offset);
		            }
		            return el;
		        }
		        function gradientLinear(defs, x1, y1, x2, y2) {
		            var el = Snap._.make("linearGradient", defs);
		            el.stops = Gstops;
		            el.addStop = GaddStop;
		            el.getBBox = GgetBBox;
		            if (x1 != null) {
		                $(el.node, {
		                    x1: x1,
		                    y1: y1,
		                    x2: x2,
		                    y2: y2
		                });
		            }
		            return el;
		        }
		        function gradientRadial(defs, cx, cy, r, fx, fy) {
		            var el = Snap._.make("radialGradient", defs);
		            el.stops = Gstops;
		            el.addStop = GaddStop;
		            el.getBBox = GgetBBox;
		            if (cx != null) {
		                $(el.node, {
		                    cx: cx,
		                    cy: cy,
		                    r: r
		                });
		            }
		            if (fx != null && fy != null) {
		                $(el.node, {
		                    fx: fx,
		                    fy: fy
		                });
		            }
		            return el;
		        }
		        /*\
		         * Paper.gradient
		         [ method ]
		         **
		         * Creates a gradient element
		         **
		         - gradient (string) gradient descriptor
		         > Gradient Descriptor
		         * The gradient descriptor is an expression formatted as
		         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
		         * either linear or radial.  The uppercase `L` or `R` letters
		         * indicate absolute coordinates offset from the SVG surface.
		         * Lowercase `l` or `r` letters indicate coordinates
		         * calculated relative to the element to which the gradient is
		         * applied.  Coordinates specify a linear gradient vector as
		         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
		         * `r` and optional `fx`, `fy` specifying a focal point away
		         * from the center of the circle. Specify `<colors>` as a list
		         * of dash-separated CSS color values.  Each color may be
		         * followed by a custom offset value, separated with a colon
		         * character.
		         > Examples
		         * Linear gradient, relative from top-left corner to bottom-right
		         * corner, from black through red to white:
		         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
		         * Linear gradient, absolute from (0, 0) to (100, 100), from black
		         * through red at 25% to white:
		         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
		         * Radial gradient, relative from the center of the element with radius
		         * half the width, from black to white:
		         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
		         * To apply the gradient:
		         | paper.circle(50, 50, 40).attr({
		         |     fill: g
		         | });
		         = (object) the `gradient` element
		        \*/
		        proto.gradient = function (str) {
		            return gradient(this.defs, str);
		        };
		        proto.gradientLinear = function (x1, y1, x2, y2) {
		            return gradientLinear(this.defs, x1, y1, x2, y2);
		        };
		        proto.gradientRadial = function (cx, cy, r, fx, fy) {
		            return gradientRadial(this.defs, cx, cy, r, fx, fy);
		        };
		        /*\
		         * Paper.toString
		         [ method ]
		         **
		         * Returns SVG code for the @Paper
		         = (string) SVG code for the @Paper
		        \*/
		        proto.toString = function () {
		            var doc = this.node.ownerDocument,
		                f = doc.createDocumentFragment(),
		                d = doc.createElement("div"),
		                svg = this.node.cloneNode(true),
		                res;
		            f.appendChild(d);
		            d.appendChild(svg);
		            Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
		            res = d.innerHTML;
		            f.removeChild(f.firstChild);
		            return res;
		        };
		        /*\
		         * Paper.toDataURL
		         [ method ]
		         **
		         * Returns SVG code for the @Paper as Data URI string.
		         = (string) Data URI string
		        \*/
		        proto.toDataURL = function () {
		            if (window && window.btoa) {
		                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
		            }
		        };
		        /*\
		         * Paper.clear
		         [ method ]
		         **
		         * Removes all child nodes of the paper, except <defs>.
		        \*/
		        proto.clear = function () {
		            var node = this.node.firstChild,
		                next;
		            while (node) {
		                next = node.nextSibling;
		                if (node.tagName != "defs") {
		                    node.parentNode.removeChild(node);
		                } else {
		                    proto.clear.call({node: node});
		                }
		                node = next;
		            }
		        };
		    }());
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob) {
		    var elproto = Element.prototype,
		        is = Snap.is,
		        clone = Snap._.clone,
		        has = "hasOwnProperty",
		        p2s = /,?([a-z]),?/gi,
		        toFloat = parseFloat,
		        math = Math,
		        PI = math.PI,
		        mmin = math.min,
		        mmax = math.max,
		        pow = math.pow,
		        abs = math.abs;
		    function paths(ps) {
		        var p = paths.ps = paths.ps || {};
		        if (p[ps]) {
		            p[ps].sleep = 100;
		        } else {
		            p[ps] = {
		                sleep: 100
		            };
		        }
		        setTimeout(function () {
		            for (var key in p) if (p[has](key) && key != ps) {
		                p[key].sleep--;
		                !p[key].sleep && delete p[key];
		            }
		        });
		        return p[ps];
		    }
		    function box(x, y, width, height) {
		        if (x == null) {
		            x = y = width = height = 0;
		        }
		        if (y == null) {
		            y = x.y;
		            width = x.width;
		            height = x.height;
		            x = x.x;
		        }
		        return {
		            x: x,
		            y: y,
		            width: width,
		            w: width,
		            height: height,
		            h: height,
		            x2: x + width,
		            y2: y + height,
		            cx: x + width / 2,
		            cy: y + height / 2,
		            r1: math.min(width, height) / 2,
		            r2: math.max(width, height) / 2,
		            r0: math.sqrt(width * width + height * height) / 2,
		            path: rectPath(x, y, width, height),
		            vb: [x, y, width, height].join(" ")
		        };
		    }
		    function toString() {
		        return this.join(",").replace(p2s, "$1");
		    }
		    function pathClone(pathArray) {
		        var res = clone(pathArray);
		        res.toString = toString;
		        return res;
		    }
		    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
		        if (length == null) {
		            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
		        } else {
		            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
		                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
		        }
		    }
		    function getLengthFactory(istotal, subpath) {
		        function O(val) {
		            return +(+val).toFixed(3);
		        }
		        return Snap._.cacher(function (path, length, onlystart) {
		            if (path instanceof Element) {
		                path = path.attr("d");
		            }
		            path = path2curve(path);
		            var x, y, p, l, sp = "", subpaths = {}, point,
		                len = 0;
		            for (var i = 0, ii = path.length; i < ii; i++) {
		                p = path[i];
		                if (p[0] == "M") {
		                    x = +p[1];
		                    y = +p[2];
		                } else {
		                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
		                    if (len + l > length) {
		                        if (subpath && !subpaths.start) {
		                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
		                            sp += [
		                                "C" + O(point.start.x),
		                                O(point.start.y),
		                                O(point.m.x),
		                                O(point.m.y),
		                                O(point.x),
		                                O(point.y)
		                            ];
		                            if (onlystart) {return sp;}
		                            subpaths.start = sp;
		                            sp = [
		                                "M" + O(point.x),
		                                O(point.y) + "C" + O(point.n.x),
		                                O(point.n.y),
		                                O(point.end.x),
		                                O(point.end.y),
		                                O(p[5]),
		                                O(p[6])
		                            ].join();
		                            len += l;
		                            x = +p[5];
		                            y = +p[6];
		                            continue;
		                        }
		                        if (!istotal && !subpath) {
		                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
		                            return point;
		                        }
		                    }
		                    len += l;
		                    x = +p[5];
		                    y = +p[6];
		                }
		                sp += p.shift() + p;
		            }
		            subpaths.end = sp;
		            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
		            return point;
		        }, null, Snap._.clone);
		    }
		    var getTotalLength = getLengthFactory(1),
		        getPointAtLength = getLengthFactory(),
		        getSubpathsAtLength = getLengthFactory(0, 1);
		    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
		        var t1 = 1 - t,
		            t13 = pow(t1, 3),
		            t12 = pow(t1, 2),
		            t2 = t * t,
		            t3 = t2 * t,
		            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
		            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
		            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
		            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
		            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
		            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
		            ax = t1 * p1x + t * c1x,
		            ay = t1 * p1y + t * c1y,
		            cx = t1 * c2x + t * p2x,
		            cy = t1 * c2y + t * p2y,
		            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
		        // (mx > nx || my < ny) && (alpha += 180);
		        return {
		            x: x,
		            y: y,
		            m: {x: mx, y: my},
		            n: {x: nx, y: ny},
		            start: {x: ax, y: ay},
		            end: {x: cx, y: cy},
		            alpha: alpha
		        };
		    }
		    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
		        if (!Snap.is(p1x, "array")) {
		            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
		        }
		        var bbox = curveDim.apply(null, p1x);
		        return box(
		            bbox.min.x,
		            bbox.min.y,
		            bbox.max.x - bbox.min.x,
		            bbox.max.y - bbox.min.y
		        );
		    }
		    function isPointInsideBBox(bbox, x, y) {
		        return  x >= bbox.x &&
		                x <= bbox.x + bbox.width &&
		                y >= bbox.y &&
		                y <= bbox.y + bbox.height;
		    }
		    function isBBoxIntersect(bbox1, bbox2) {
		        bbox1 = box(bbox1);
		        bbox2 = box(bbox2);
		        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
		            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
		            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
		            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
		            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
		            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
		            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
		            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
		            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
		                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
		            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
		                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
		    }
		    function base3(t, p1, p2, p3, p4) {
		        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
		            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
		        return t * t2 - 3 * p1 + 3 * p2;
		    }
		    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
		        if (z == null) {
		            z = 1;
		        }
		        z = z > 1 ? 1 : z < 0 ? 0 : z;
		        var z2 = z / 2,
		            n = 12,
		            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
		            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
		            sum = 0;
		        for (var i = 0; i < n; i++) {
		            var ct = z2 * Tvalues[i] + z2,
		                xbase = base3(ct, x1, x2, x3, x4),
		                ybase = base3(ct, y1, y2, y3, y4),
		                comb = xbase * xbase + ybase * ybase;
		            sum += Cvalues[i] * math.sqrt(comb);
		        }
		        return z2 * sum;
		    }
		    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
		        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
		            return;
		        }
		        var t = 1,
		            step = t / 2,
		            t2 = t - step,
		            l,
		            e = .01;
		        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
		        while (abs(l - ll) > e) {
		            step /= 2;
		            t2 += (l < ll ? 1 : -1) * step;
		            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
		        }
		        return t2;
		    }
		    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
		        if (
		            mmax(x1, x2) < mmin(x3, x4) ||
		            mmin(x1, x2) > mmax(x3, x4) ||
		            mmax(y1, y2) < mmin(y3, y4) ||
		            mmin(y1, y2) > mmax(y3, y4)
		        ) {
		            return;
		        }
		        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
		            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
		            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
		
		        if (!denominator) {
		            return;
		        }
		        var px = nx / denominator,
		            py = ny / denominator,
		            px2 = +px.toFixed(2),
		            py2 = +py.toFixed(2);
		        if (
		            px2 < +mmin(x1, x2).toFixed(2) ||
		            px2 > +mmax(x1, x2).toFixed(2) ||
		            px2 < +mmin(x3, x4).toFixed(2) ||
		            px2 > +mmax(x3, x4).toFixed(2) ||
		            py2 < +mmin(y1, y2).toFixed(2) ||
		            py2 > +mmax(y1, y2).toFixed(2) ||
		            py2 < +mmin(y3, y4).toFixed(2) ||
		            py2 > +mmax(y3, y4).toFixed(2)
		        ) {
		            return;
		        }
		        return {x: px, y: py};
		    }
		    function inter(bez1, bez2) {
		        return interHelper(bez1, bez2);
		    }
		    function interCount(bez1, bez2) {
		        return interHelper(bez1, bez2, 1);
		    }
		    function interHelper(bez1, bez2, justCount) {
		        var bbox1 = bezierBBox(bez1),
		            bbox2 = bezierBBox(bez2);
		        if (!isBBoxIntersect(bbox1, bbox2)) {
		            return justCount ? 0 : [];
		        }
		        var l1 = bezlen.apply(0, bez1),
		            l2 = bezlen.apply(0, bez2),
		            n1 = ~~(l1 / 8),
		            n2 = ~~(l2 / 8),
		            dots1 = [],
		            dots2 = [],
		            xy = {},
		            res = justCount ? 0 : [];
		        for (var i = 0; i < n1 + 1; i++) {
		            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
		            dots1.push({x: p.x, y: p.y, t: i / n1});
		        }
		        for (i = 0; i < n2 + 1; i++) {
		            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
		            dots2.push({x: p.x, y: p.y, t: i / n2});
		        }
		        for (i = 0; i < n1; i++) {
		            for (var j = 0; j < n2; j++) {
		                var di = dots1[i],
		                    di1 = dots1[i + 1],
		                    dj = dots2[j],
		                    dj1 = dots2[j + 1],
		                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
		                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
		                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
		                if (is) {
		                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
		                        continue;
		                    }
		                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
		                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
		                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
		                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
		                        if (justCount) {
		                            res++;
		                        } else {
		                            res.push({
		                                x: is.x,
		                                y: is.y,
		                                t1: t1,
		                                t2: t2
		                            });
		                        }
		                    }
		                }
		            }
		        }
		        return res;
		    }
		    function pathIntersection(path1, path2) {
		        return interPathHelper(path1, path2);
		    }
		    function pathIntersectionNumber(path1, path2) {
		        return interPathHelper(path1, path2, 1);
		    }
		    function interPathHelper(path1, path2, justCount) {
		        path1 = path2curve(path1);
		        path2 = path2curve(path2);
		        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
		            res = justCount ? 0 : [];
		        for (var i = 0, ii = path1.length; i < ii; i++) {
		            var pi = path1[i];
		            if (pi[0] == "M") {
		                x1 = x1m = pi[1];
		                y1 = y1m = pi[2];
		            } else {
		                if (pi[0] == "C") {
		                    bez1 = [x1, y1].concat(pi.slice(1));
		                    x1 = bez1[6];
		                    y1 = bez1[7];
		                } else {
		                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
		                    x1 = x1m;
		                    y1 = y1m;
		                }
		                for (var j = 0, jj = path2.length; j < jj; j++) {
		                    var pj = path2[j];
		                    if (pj[0] == "M") {
		                        x2 = x2m = pj[1];
		                        y2 = y2m = pj[2];
		                    } else {
		                        if (pj[0] == "C") {
		                            bez2 = [x2, y2].concat(pj.slice(1));
		                            x2 = bez2[6];
		                            y2 = bez2[7];
		                        } else {
		                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
		                            x2 = x2m;
		                            y2 = y2m;
		                        }
		                        var intr = interHelper(bez1, bez2, justCount);
		                        if (justCount) {
		                            res += intr;
		                        } else {
		                            for (var k = 0, kk = intr.length; k < kk; k++) {
		                                intr[k].segment1 = i;
		                                intr[k].segment2 = j;
		                                intr[k].bez1 = bez1;
		                                intr[k].bez2 = bez2;
		                            }
		                            res = res.concat(intr);
		                        }
		                    }
		                }
		            }
		        }
		        return res;
		    }
		    function isPointInsidePath(path, x, y) {
		        var bbox = pathBBox(path);
		        return isPointInsideBBox(bbox, x, y) &&
		               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
		    }
		    function pathBBox(path) {
		        var pth = paths(path);
		        if (pth.bbox) {
		            return clone(pth.bbox);
		        }
		        if (!path) {
		            return box();
		        }
		        path = path2curve(path);
		        var x = 0, 
		            y = 0,
		            X = [],
		            Y = [],
		            p;
		        for (var i = 0, ii = path.length; i < ii; i++) {
		            p = path[i];
		            if (p[0] == "M") {
		                x = p[1];
		                y = p[2];
		                X.push(x);
		                Y.push(y);
		            } else {
		                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
		                X = X.concat(dim.min.x, dim.max.x);
		                Y = Y.concat(dim.min.y, dim.max.y);
		                x = p[5];
		                y = p[6];
		            }
		        }
		        var xmin = mmin.apply(0, X),
		            ymin = mmin.apply(0, Y),
		            xmax = mmax.apply(0, X),
		            ymax = mmax.apply(0, Y),
		            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
		        pth.bbox = clone(bb);
		        return bb;
		    }
		    function rectPath(x, y, w, h, r) {
		        if (r) {
		            return [
		                ["M", +x + (+r), y],
		                ["l", w - r * 2, 0],
		                ["a", r, r, 0, 0, 1, r, r],
		                ["l", 0, h - r * 2],
		                ["a", r, r, 0, 0, 1, -r, r],
		                ["l", r * 2 - w, 0],
		                ["a", r, r, 0, 0, 1, -r, -r],
		                ["l", 0, r * 2 - h],
		                ["a", r, r, 0, 0, 1, r, -r],
		                ["z"]
		            ];
		        }
		        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
		        res.toString = toString;
		        return res;
		    }
		    function ellipsePath(x, y, rx, ry, a) {
		        if (a == null && ry == null) {
		            ry = rx;
		        }
		        x = +x;
		        y = +y;
		        rx = +rx;
		        ry = +ry;
		        if (a != null) {
		            var rad = Math.PI / 180,
		                x1 = x + rx * Math.cos(-ry * rad),
		                x2 = x + rx * Math.cos(-a * rad),
		                y1 = y + rx * Math.sin(-ry * rad),
		                y2 = y + rx * Math.sin(-a * rad),
		                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
		        } else {
		            res = [
		                ["M", x, y],
		                ["m", 0, -ry],
		                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
		                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
		                ["z"]
		            ];
		        }
		        res.toString = toString;
		        return res;
		    }
		    var unit2px = Snap._unit2px,
		        getPath = {
		        path: function (el) {
		            return el.attr("path");
		        },
		        circle: function (el) {
		            var attr = unit2px(el);
		            return ellipsePath(attr.cx, attr.cy, attr.r);
		        },
		        ellipse: function (el) {
		            var attr = unit2px(el);
		            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
		        },
		        rect: function (el) {
		            var attr = unit2px(el);
		            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
		        },
		        image: function (el) {
		            var attr = unit2px(el);
		            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
		        },
		        line: function (el) {
		            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
		        },
		        polyline: function (el) {
		            return "M" + el.attr("points");
		        },
		        polygon: function (el) {
		            return "M" + el.attr("points") + "z";
		        },
		        deflt: function (el) {
		            var bbox = el.node.getBBox();
		            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
		        }
		    };
		    function pathToRelative(pathArray) {
		        var pth = paths(pathArray),
		            lowerCase = String.prototype.toLowerCase;
		        if (pth.rel) {
		            return pathClone(pth.rel);
		        }
		        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
		            pathArray = Snap.parsePathString(pathArray);
		        }
		        var res = [],
		            x = 0,
		            y = 0,
		            mx = 0,
		            my = 0,
		            start = 0;
		        if (pathArray[0][0] == "M") {
		            x = pathArray[0][1];
		            y = pathArray[0][2];
		            mx = x;
		            my = y;
		            start++;
		            res.push(["M", x, y]);
		        }
		        for (var i = start, ii = pathArray.length; i < ii; i++) {
		            var r = res[i] = [],
		                pa = pathArray[i];
		            if (pa[0] != lowerCase.call(pa[0])) {
		                r[0] = lowerCase.call(pa[0]);
		                switch (r[0]) {
		                    case "a":
		                        r[1] = pa[1];
		                        r[2] = pa[2];
		                        r[3] = pa[3];
		                        r[4] = pa[4];
		                        r[5] = pa[5];
		                        r[6] = +(pa[6] - x).toFixed(3);
		                        r[7] = +(pa[7] - y).toFixed(3);
		                        break;
		                    case "v":
		                        r[1] = +(pa[1] - y).toFixed(3);
		                        break;
		                    case "m":
		                        mx = pa[1];
		                        my = pa[2];
		                    default:
		                        for (var j = 1, jj = pa.length; j < jj; j++) {
		                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
		                        }
		                }
		            } else {
		                r = res[i] = [];
		                if (pa[0] == "m") {
		                    mx = pa[1] + x;
		                    my = pa[2] + y;
		                }
		                for (var k = 0, kk = pa.length; k < kk; k++) {
		                    res[i][k] = pa[k];
		                }
		            }
		            var len = res[i].length;
		            switch (res[i][0]) {
		                case "z":
		                    x = mx;
		                    y = my;
		                    break;
		                case "h":
		                    x += +res[i][len - 1];
		                    break;
		                case "v":
		                    y += +res[i][len - 1];
		                    break;
		                default:
		                    x += +res[i][len - 2];
		                    y += +res[i][len - 1];
		            }
		        }
		        res.toString = toString;
		        pth.rel = pathClone(res);
		        return res;
		    }
		    function pathToAbsolute(pathArray) {
		        var pth = paths(pathArray);
		        if (pth.abs) {
		            return pathClone(pth.abs);
		        }
		        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
		            pathArray = Snap.parsePathString(pathArray);
		        }
		        if (!pathArray || !pathArray.length) {
		            return [["M", 0, 0]];
		        }
		        var res = [],
		            x = 0,
		            y = 0,
		            mx = 0,
		            my = 0,
		            start = 0,
		            pa0;
		        if (pathArray[0][0] == "M") {
		            x = +pathArray[0][1];
		            y = +pathArray[0][2];
		            mx = x;
		            my = y;
		            start++;
		            res[0] = ["M", x, y];
		        }
		        var crz = pathArray.length == 3 &&
		            pathArray[0][0] == "M" &&
		            pathArray[1][0].toUpperCase() == "R" &&
		            pathArray[2][0].toUpperCase() == "Z";
		        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
		            res.push(r = []);
		            pa = pathArray[i];
		            pa0 = pa[0];
		            if (pa0 != pa0.toUpperCase()) {
		                r[0] = pa0.toUpperCase();
		                switch (r[0]) {
		                    case "A":
		                        r[1] = pa[1];
		                        r[2] = pa[2];
		                        r[3] = pa[3];
		                        r[4] = pa[4];
		                        r[5] = pa[5];
		                        r[6] = +pa[6] + x;
		                        r[7] = +pa[7] + y;
		                        break;
		                    case "V":
		                        r[1] = +pa[1] + y;
		                        break;
		                    case "H":
		                        r[1] = +pa[1] + x;
		                        break;
		                    case "R":
		                        var dots = [x, y].concat(pa.slice(1));
		                        for (var j = 2, jj = dots.length; j < jj; j++) {
		                            dots[j] = +dots[j] + x;
		                            dots[++j] = +dots[j] + y;
		                        }
		                        res.pop();
		                        res = res.concat(catmullRom2bezier(dots, crz));
		                        break;
		                    case "O":
		                        res.pop();
		                        dots = ellipsePath(x, y, pa[1], pa[2]);
		                        dots.push(dots[0]);
		                        res = res.concat(dots);
		                        break;
		                    case "U":
		                        res.pop();
		                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
		                        r = ["U"].concat(res[res.length - 1].slice(-2));
		                        break;
		                    case "M":
		                        mx = +pa[1] + x;
		                        my = +pa[2] + y;
		                    default:
		                        for (j = 1, jj = pa.length; j < jj; j++) {
		                            r[j] = +pa[j] + ((j % 2) ? x : y);
		                        }
		                }
		            } else if (pa0 == "R") {
		                dots = [x, y].concat(pa.slice(1));
		                res.pop();
		                res = res.concat(catmullRom2bezier(dots, crz));
		                r = ["R"].concat(pa.slice(-2));
		            } else if (pa0 == "O") {
		                res.pop();
		                dots = ellipsePath(x, y, pa[1], pa[2]);
		                dots.push(dots[0]);
		                res = res.concat(dots);
		            } else if (pa0 == "U") {
		                res.pop();
		                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
		                r = ["U"].concat(res[res.length - 1].slice(-2));
		            } else {
		                for (var k = 0, kk = pa.length; k < kk; k++) {
		                    r[k] = pa[k];
		                }
		            }
		            pa0 = pa0.toUpperCase();
		            if (pa0 != "O") {
		                switch (r[0]) {
		                    case "Z":
		                        x = +mx;
		                        y = +my;
		                        break;
		                    case "H":
		                        x = r[1];
		                        break;
		                    case "V":
		                        y = r[1];
		                        break;
		                    case "M":
		                        mx = r[r.length - 2];
		                        my = r[r.length - 1];
		                    default:
		                        x = r[r.length - 2];
		                        y = r[r.length - 1];
		                }
		            }
		        }
		        res.toString = toString;
		        pth.abs = pathClone(res);
		        return res;
		    }
		    function l2c(x1, y1, x2, y2) {
		        return [x1, y1, x2, y2, x2, y2];
		    }
		    function q2c(x1, y1, ax, ay, x2, y2) {
		        var _13 = 1 / 3,
		            _23 = 2 / 3;
		        return [
		                _13 * x1 + _23 * ax,
		                _13 * y1 + _23 * ay,
		                _13 * x2 + _23 * ax,
		                _13 * y2 + _23 * ay,
		                x2,
		                y2
		            ];
		    }
		    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
		        // for more information of where this math came from visit:
		        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
		        var _120 = PI * 120 / 180,
		            rad = PI / 180 * (+angle || 0),
		            res = [],
		            xy,
		            rotate = Snap._.cacher(function (x, y, rad) {
		                var X = x * math.cos(rad) - y * math.sin(rad),
		                    Y = x * math.sin(rad) + y * math.cos(rad);
		                return {x: X, y: Y};
		            });
		        if (!recursive) {
		            xy = rotate(x1, y1, -rad);
		            x1 = xy.x;
		            y1 = xy.y;
		            xy = rotate(x2, y2, -rad);
		            x2 = xy.x;
		            y2 = xy.y;
		            var cos = math.cos(PI / 180 * angle),
		                sin = math.sin(PI / 180 * angle),
		                x = (x1 - x2) / 2,
		                y = (y1 - y2) / 2;
		            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
		            if (h > 1) {
		                h = math.sqrt(h);
		                rx = h * rx;
		                ry = h * ry;
		            }
		            var rx2 = rx * rx,
		                ry2 = ry * ry,
		                k = (large_arc_flag == sweep_flag ? -1 : 1) *
		                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
		                cx = k * rx * y / ry + (x1 + x2) / 2,
		                cy = k * -ry * x / rx + (y1 + y2) / 2,
		                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
		                f2 = math.asin(((y2 - cy) / ry).toFixed(9));
		
		            f1 = x1 < cx ? PI - f1 : f1;
		            f2 = x2 < cx ? PI - f2 : f2;
		            f1 < 0 && (f1 = PI * 2 + f1);
		            f2 < 0 && (f2 = PI * 2 + f2);
		            if (sweep_flag && f1 > f2) {
		                f1 = f1 - PI * 2;
		            }
		            if (!sweep_flag && f2 > f1) {
		                f2 = f2 - PI * 2;
		            }
		        } else {
		            f1 = recursive[0];
		            f2 = recursive[1];
		            cx = recursive[2];
		            cy = recursive[3];
		        }
		        var df = f2 - f1;
		        if (abs(df) > _120) {
		            var f2old = f2,
		                x2old = x2,
		                y2old = y2;
		            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
		            x2 = cx + rx * math.cos(f2);
		            y2 = cy + ry * math.sin(f2);
		            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
		        }
		        df = f2 - f1;
		        var c1 = math.cos(f1),
		            s1 = math.sin(f1),
		            c2 = math.cos(f2),
		            s2 = math.sin(f2),
		            t = math.tan(df / 4),
		            hx = 4 / 3 * rx * t,
		            hy = 4 / 3 * ry * t,
		            m1 = [x1, y1],
		            m2 = [x1 + hx * s1, y1 - hy * c1],
		            m3 = [x2 + hx * s2, y2 - hy * c2],
		            m4 = [x2, y2];
		        m2[0] = 2 * m1[0] - m2[0];
		        m2[1] = 2 * m1[1] - m2[1];
		        if (recursive) {
		            return [m2, m3, m4].concat(res);
		        } else {
		            res = [m2, m3, m4].concat(res).join().split(",");
		            var newres = [];
		            for (var i = 0, ii = res.length; i < ii; i++) {
		                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
		            }
		            return newres;
		        }
		    }
		    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
		        var t1 = 1 - t;
		        return {
		            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
		            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
		        };
		    }
		    
		    // Returns bounding box of cubic bezier curve.
		    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
		    // Original version: NISHIO Hirokazu
		    // Modifications: https://github.com/timo22345
		    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
		        var tvalues = [],
		            bounds = [[], []],
		            a, b, c, t, t1, t2, b2ac, sqrtb2ac;
		        for (var i = 0; i < 2; ++i) {
		            if (i == 0) {
		                b = 6 * x0 - 12 * x1 + 6 * x2;
		                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
		                c = 3 * x1 - 3 * x0;
		            } else {
		                b = 6 * y0 - 12 * y1 + 6 * y2;
		                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
		                c = 3 * y1 - 3 * y0;
		            }
		            if (abs(a) < 1e-12) {
		                if (abs(b) < 1e-12) {
		                    continue;
		                }
		                t = -c / b;
		                if (0 < t && t < 1) {
		                    tvalues.push(t);
		                }
		                continue;
		            }
		            b2ac = b * b - 4 * c * a;
		            sqrtb2ac = math.sqrt(b2ac);
		            if (b2ac < 0) {
		                continue;
		            }
		            t1 = (-b + sqrtb2ac) / (2 * a);
		            if (0 < t1 && t1 < 1) {
		                tvalues.push(t1);
		            }
		            t2 = (-b - sqrtb2ac) / (2 * a);
		            if (0 < t2 && t2 < 1) {
		                tvalues.push(t2);
		            }
		        }
		
		        var x, y, j = tvalues.length,
		            jlen = j,
		            mt;
		        while (j--) {
		            t = tvalues[j];
		            mt = 1 - t;
		            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
		            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
		        }
		
		        bounds[0][jlen] = x0;
		        bounds[1][jlen] = y0;
		        bounds[0][jlen + 1] = x3;
		        bounds[1][jlen + 1] = y3;
		        bounds[0].length = bounds[1].length = jlen + 2;
		
		
		        return {
		          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
		          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
		        };
		    }
		
		    function path2curve(path, path2) {
		        var pth = !path2 && paths(path);
		        if (!path2 && pth.curve) {
		            return pathClone(pth.curve);
		        }
		        var p = pathToAbsolute(path),
		            p2 = path2 && pathToAbsolute(path2),
		            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
		            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
		            processPath = function (path, d, pcom) {
		                var nx, ny;
		                if (!path) {
		                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
		                }
		                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
		                switch (path[0]) {
		                    case "M":
		                        d.X = path[1];
		                        d.Y = path[2];
		                        break;
		                    case "A":
		                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
		                        break;
		                    case "S":
		                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
		                            nx = d.x * 2 - d.bx;          // And reflect the previous
		                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
		                        }
		                        else {                            // or some else or nothing
		                            nx = d.x;
		                            ny = d.y;
		                        }
		                        path = ["C", nx, ny].concat(path.slice(1));
		                        break;
		                    case "T":
		                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
		                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
		                            d.qy = d.y * 2 - d.qy;        // to case "S".
		                        }
		                        else {                            // or something else or nothing
		                            d.qx = d.x;
		                            d.qy = d.y;
		                        }
		                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
		                        break;
		                    case "Q":
		                        d.qx = path[1];
		                        d.qy = path[2];
		                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
		                        break;
		                    case "L":
		                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
		                        break;
		                    case "H":
		                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
		                        break;
		                    case "V":
		                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
		                        break;
		                    case "Z":
		                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
		                        break;
		                }
		                return path;
		            },
		            fixArc = function (pp, i) {
		                if (pp[i].length > 7) {
		                    pp[i].shift();
		                    var pi = pp[i];
		                    while (pi.length) {
		                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
		                        p2 && (pcoms2[i] = "A"); // the same as above
		                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
		                    }
		                    pp.splice(i, 1);
		                    ii = mmax(p.length, p2 && p2.length || 0);
		                }
		            },
		            fixM = function (path1, path2, a1, a2, i) {
		                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
		                    path2.splice(i, 0, ["M", a2.x, a2.y]);
		                    a1.bx = 0;
		                    a1.by = 0;
		                    a1.x = path1[i][1];
		                    a1.y = path1[i][2];
		                    ii = mmax(p.length, p2 && p2.length || 0);
		                }
		            },
		            pcoms1 = [], // path commands of original path p
		            pcoms2 = [], // path commands of original path p2
		            pfirst = "", // temporary holder for original path command
		            pcom = ""; // holder for previous path command of original path
		        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
		            p[i] && (pfirst = p[i][0]); // save current path command
		
		            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
		            {
		                pcoms1[i] = pfirst; // Save current path command
		                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
		            }
		            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath
		
		            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
		            // which may produce multiple C:s
		            // so we have to make sure that C is also C in original path
		
		            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1
		
		            if (p2) { // the same procedures is done to p2
		                p2[i] && (pfirst = p2[i][0]);
		                if (pfirst != "C") {
		                    pcoms2[i] = pfirst;
		                    i && (pcom = pcoms2[i - 1]);
		                }
		                p2[i] = processPath(p2[i], attrs2, pcom);
		
		                if (pcoms2[i] != "A" && pfirst == "C") {
		                    pcoms2[i] = "C";
		                }
		
		                fixArc(p2, i);
		            }
		            fixM(p, p2, attrs, attrs2, i);
		            fixM(p2, p, attrs2, attrs, i);
		            var seg = p[i],
		                seg2 = p2 && p2[i],
		                seglen = seg.length,
		                seg2len = p2 && seg2.length;
		            attrs.x = seg[seglen - 2];
		            attrs.y = seg[seglen - 1];
		            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
		            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
		            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
		            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
		            attrs2.x = p2 && seg2[seg2len - 2];
		            attrs2.y = p2 && seg2[seg2len - 1];
		        }
		        if (!p2) {
		            pth.curve = pathClone(p);
		        }
		        return p2 ? [p, p2] : p;
		    }
		    function mapPath(path, matrix) {
		        if (!matrix) {
		            return path;
		        }
		        var x, y, i, j, ii, jj, pathi;
		        path = path2curve(path);
		        for (i = 0, ii = path.length; i < ii; i++) {
		            pathi = path[i];
		            for (j = 1, jj = pathi.length; j < jj; j += 2) {
		                x = matrix.x(pathi[j], pathi[j + 1]);
		                y = matrix.y(pathi[j], pathi[j + 1]);
		                pathi[j] = x;
		                pathi[j + 1] = y;
		            }
		        }
		        return path;
		    }
		
		    // http://schepers.cc/getting-to-the-point
		    function catmullRom2bezier(crp, z) {
		        var d = [];
		        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
		            var p = [
		                        {x: +crp[i - 2], y: +crp[i - 1]},
		                        {x: +crp[i],     y: +crp[i + 1]},
		                        {x: +crp[i + 2], y: +crp[i + 3]},
		                        {x: +crp[i + 4], y: +crp[i + 5]}
		                    ];
		            if (z) {
		                if (!i) {
		                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
		                } else if (iLen - 4 == i) {
		                    p[3] = {x: +crp[0], y: +crp[1]};
		                } else if (iLen - 2 == i) {
		                    p[2] = {x: +crp[0], y: +crp[1]};
		                    p[3] = {x: +crp[2], y: +crp[3]};
		                }
		            } else {
		                if (iLen - 4 == i) {
		                    p[3] = p[2];
		                } else if (!i) {
		                    p[0] = {x: +crp[i], y: +crp[i + 1]};
		                }
		            }
		            d.push(["C",
		                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
		                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
		                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
		                  (p[1].y + 6*p[2].y - p[3].y) / 6,
		                  p[2].x,
		                  p[2].y
		            ]);
		        }
		
		        return d;
		    }
		
		    // export
		    Snap.path = paths;
		
		    /*\
		     * Snap.path.getTotalLength
		     [ method ]
		     **
		     * Returns the length of the given path in pixels
		     **
		     - path (string) SVG path string
		     **
		     = (number) length
		    \*/
		    Snap.path.getTotalLength = getTotalLength;
		    /*\
		     * Snap.path.getPointAtLength
		     [ method ]
		     **
		     * Returns the coordinates of the point located at the given length along the given path
		     **
		     - path (string) SVG path string
		     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
		     **
		     = (object) representation of the point:
		     o {
		     o     x: (number) x coordinate,
		     o     y: (number) y coordinate,
		     o     alpha: (number) angle of derivative
		     o }
		    \*/
		    Snap.path.getPointAtLength = getPointAtLength;
		    /*\
		     * Snap.path.getSubpath
		     [ method ]
		     **
		     * Returns the subpath of a given path between given start and end lengths
		     **
		     - path (string) SVG path string
		     - from (number) length, in pixels, from the start of the path to the start of the segment
		     - to (number) length, in pixels, from the start of the path to the end of the segment
		     **
		     = (string) path string definition for the segment
		    \*/
		    Snap.path.getSubpath = function (path, from, to) {
		        if (this.getTotalLength(path) - to < 1e-6) {
		            return getSubpathsAtLength(path, from).end;
		        }
		        var a = getSubpathsAtLength(path, to, 1);
		        return from ? getSubpathsAtLength(a, from).end : a;
		    };
		    /*\
		     * Element.getTotalLength
		     [ method ]
		     **
		     * Returns the length of the path in pixels (only works for `path` elements)
		     = (number) length
		    \*/
		    elproto.getTotalLength = function () {
		        if (this.node.getTotalLength) {
		            return this.node.getTotalLength();
		        }
		    };
		    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
		    /*\
		     * Element.getPointAtLength
		     [ method ]
		     **
		     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
		     **
		     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
		     **
		     = (object) representation of the point:
		     o {
		     o     x: (number) x coordinate,
		     o     y: (number) y coordinate,
		     o     alpha: (number) angle of derivative
		     o }
		    \*/
		    elproto.getPointAtLength = function (length) {
		        return getPointAtLength(this.attr("d"), length);
		    };
		    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
		    /*\
		     * Element.getSubpath
		     [ method ]
		     **
		     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
		     **
		     - from (number) length, in pixels, from the start of the path to the start of the segment
		     - to (number) length, in pixels, from the start of the path to the end of the segment
		     **
		     = (string) path string definition for the segment
		    \*/
		    elproto.getSubpath = function (from, to) {
		        return Snap.path.getSubpath(this.attr("d"), from, to);
		    };
		    Snap._.box = box;
		    /*\
		     * Snap.path.findDotsAtSegment
		     [ method ]
		     **
		     * Utility method
		     **
		     * Finds dot coordinates on the given cubic beziér curve at the given t
		     - p1x (number) x of the first point of the curve
		     - p1y (number) y of the first point of the curve
		     - c1x (number) x of the first anchor of the curve
		     - c1y (number) y of the first anchor of the curve
		     - c2x (number) x of the second anchor of the curve
		     - c2y (number) y of the second anchor of the curve
		     - p2x (number) x of the second point of the curve
		     - p2y (number) y of the second point of the curve
		     - t (number) position on the curve (0..1)
		     = (object) point information in format:
		     o {
		     o     x: (number) x coordinate of the point,
		     o     y: (number) y coordinate of the point,
		     o     m: {
		     o         x: (number) x coordinate of the left anchor,
		     o         y: (number) y coordinate of the left anchor
		     o     },
		     o     n: {
		     o         x: (number) x coordinate of the right anchor,
		     o         y: (number) y coordinate of the right anchor
		     o     },
		     o     start: {
		     o         x: (number) x coordinate of the start of the curve,
		     o         y: (number) y coordinate of the start of the curve
		     o     },
		     o     end: {
		     o         x: (number) x coordinate of the end of the curve,
		     o         y: (number) y coordinate of the end of the curve
		     o     },
		     o     alpha: (number) angle of the curve derivative at the point
		     o }
		    \*/
		    Snap.path.findDotsAtSegment = findDotsAtSegment;
		    /*\
		     * Snap.path.bezierBBox
		     [ method ]
		     **
		     * Utility method
		     **
		     * Returns the bounding box of a given cubic beziér curve
		     - p1x (number) x of the first point of the curve
		     - p1y (number) y of the first point of the curve
		     - c1x (number) x of the first anchor of the curve
		     - c1y (number) y of the first anchor of the curve
		     - c2x (number) x of the second anchor of the curve
		     - c2y (number) y of the second anchor of the curve
		     - p2x (number) x of the second point of the curve
		     - p2y (number) y of the second point of the curve
		     * or
		     - bez (array) array of six points for beziér curve
		     = (object) bounding box
		     o {
		     o     x: (number) x coordinate of the left top point of the box,
		     o     y: (number) y coordinate of the left top point of the box,
		     o     x2: (number) x coordinate of the right bottom point of the box,
		     o     y2: (number) y coordinate of the right bottom point of the box,
		     o     width: (number) width of the box,
		     o     height: (number) height of the box
		     o }
		    \*/
		    Snap.path.bezierBBox = bezierBBox;
		    /*\
		     * Snap.path.isPointInsideBBox
		     [ method ]
		     **
		     * Utility method
		     **
		     * Returns `true` if given point is inside bounding box
		     - bbox (string) bounding box
		     - x (string) x coordinate of the point
		     - y (string) y coordinate of the point
		     = (boolean) `true` if point is inside
		    \*/
		    Snap.path.isPointInsideBBox = isPointInsideBBox;
		    Snap.closest = function (x, y, X, Y) {
		        var r = 100,
		            b = box(x - r / 2, y - r / 2, r, r),
		            inside = [],
		            getter = X[0].hasOwnProperty("x") ? function (i) {
		                return {
		                    x: X[i].x,
		                    y: X[i].y
		                };
		            } : function (i) {
		                return {
		                    x: X[i],
		                    y: Y[i]
		                };
		            },
		            found = 0;
		        while (r <= 1e6 && !found) {
		            for (var i = 0, ii = X.length; i < ii; i++) {
		                var xy = getter(i);
		                if (isPointInsideBBox(b, xy.x, xy.y)) {
		                    found++;
		                    inside.push(xy);
		                    break;
		                }
		            }
		            if (!found) {
		                r *= 2;
		                b = box(x - r / 2, y - r / 2, r, r)
		            }
		        }
		        if (r == 1e6) {
		            return;
		        }
		        var len = Infinity,
		            res;
		        for (i = 0, ii = inside.length; i < ii; i++) {
		            var l = Snap.len(x, y, inside[i].x, inside[i].y);
		            if (len > l) {
		                len = l;
		                inside[i].len = l;
		                res = inside[i];
		            }
		        }
		        return res;
		    };
		    /*\
		     * Snap.path.isBBoxIntersect
		     [ method ]
		     **
		     * Utility method
		     **
		     * Returns `true` if two bounding boxes intersect
		     - bbox1 (string) first bounding box
		     - bbox2 (string) second bounding box
		     = (boolean) `true` if bounding boxes intersect
		    \*/
		    Snap.path.isBBoxIntersect = isBBoxIntersect;
		    /*\
		     * Snap.path.intersection
		     [ method ]
		     **
		     * Utility method
		     **
		     * Finds intersections of two paths
		     - path1 (string) path string
		     - path2 (string) path string
		     = (array) dots of intersection
		     o [
		     o     {
		     o         x: (number) x coordinate of the point,
		     o         y: (number) y coordinate of the point,
		     o         t1: (number) t value for segment of path1,
		     o         t2: (number) t value for segment of path2,
		     o         segment1: (number) order number for segment of path1,
		     o         segment2: (number) order number for segment of path2,
		     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
		     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
		     o     }
		     o ]
		    \*/
		    Snap.path.intersection = pathIntersection;
		    Snap.path.intersectionNumber = pathIntersectionNumber;
		    /*\
		     * Snap.path.isPointInside
		     [ method ]
		     **
		     * Utility method
		     **
		     * Returns `true` if given point is inside a given closed path.
		     *
		     * Note: fill mode doesn’t affect the result of this method.
		     - path (string) path string
		     - x (number) x of the point
		     - y (number) y of the point
		     = (boolean) `true` if point is inside the path
		    \*/
		    Snap.path.isPointInside = isPointInsidePath;
		    /*\
		     * Snap.path.getBBox
		     [ method ]
		     **
		     * Utility method
		     **
		     * Returns the bounding box of a given path
		     - path (string) path string
		     = (object) bounding box
		     o {
		     o     x: (number) x coordinate of the left top point of the box,
		     o     y: (number) y coordinate of the left top point of the box,
		     o     x2: (number) x coordinate of the right bottom point of the box,
		     o     y2: (number) y coordinate of the right bottom point of the box,
		     o     width: (number) width of the box,
		     o     height: (number) height of the box
		     o }
		    \*/
		    Snap.path.getBBox = pathBBox;
		    Snap.path.get = getPath;
		    /*\
		     * Snap.path.toRelative
		     [ method ]
		     **
		     * Utility method
		     **
		     * Converts path coordinates into relative values
		     - path (string) path string
		     = (array) path string
		    \*/
		    Snap.path.toRelative = pathToRelative;
		    /*\
		     * Snap.path.toAbsolute
		     [ method ]
		     **
		     * Utility method
		     **
		     * Converts path coordinates into absolute values
		     - path (string) path string
		     = (array) path string
		    \*/
		    Snap.path.toAbsolute = pathToAbsolute;
		    /*\
		     * Snap.path.toCubic
		     [ method ]
		     **
		     * Utility method
		     **
		     * Converts path to a new path where all segments are cubic beziér curves
		     - pathString (string|array) path string or array of segments
		     = (array) array of segments
		    \*/
		    Snap.path.toCubic = path2curve;
		    /*\
		     * Snap.path.map
		     [ method ]
		     **
		     * Transform the path string with the given matrix
		     - path (string) path string
		     - matrix (object) see @Matrix
		     = (string) transformed path string
		    \*/
		    Snap.path.map = mapPath;
		    Snap.path.toString = toString;
		    Snap.path.clone = pathClone;
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob) {
		    var mmax = Math.max,
		        mmin = Math.min;
		
		    // Set
		    var Set = function (items) {
		        this.items = [];
			this.bindings = {};
		        this.length = 0;
		        this.type = "set";
		        if (items) {
		            for (var i = 0, ii = items.length; i < ii; i++) {
		                if (items[i]) {
		                    this[this.items.length] = this.items[this.items.length] = items[i];
		                    this.length++;
		                }
		            }
		        }
		    },
		    setproto = Set.prototype;
		    /*\
		     * Set.push
		     [ method ]
		     **
		     * Adds each argument to the current set
		     = (object) original element
		    \*/
		    setproto.push = function () {
		        var item,
		            len;
		        for (var i = 0, ii = arguments.length; i < ii; i++) {
		            item = arguments[i];
		            if (item) {
		                len = this.items.length;
		                this[len] = this.items[len] = item;
		                this.length++;
		            }
		        }
		        return this;
		    };
		    /*\
		     * Set.pop
		     [ method ]
		     **
		     * Removes last element and returns it
		     = (object) element
		    \*/
		    setproto.pop = function () {
		        this.length && delete this[this.length--];
		        return this.items.pop();
		    };
		    /*\
		     * Set.forEach
		     [ method ]
		     **
		     * Executes given function for each element in the set
		     *
		     * If the function returns `false`, the loop stops running.
		     **
		     - callback (function) function to run
		     - thisArg (object) context object for the callback
		     = (object) Set object
		    \*/
		    setproto.forEach = function (callback, thisArg) {
		        for (var i = 0, ii = this.items.length; i < ii; i++) {
		            if (callback.call(thisArg, this.items[i], i) === false) {
		                return this;
		            }
		        }
		        return this;
		    };
		    /*\
		     * Set.animate
		     [ method ]
		     **
		     * Animates each element in set in sync.
		     *
		     **
		     - attrs (object) key-value pairs of destination attributes
		     - duration (number) duration of the animation in milliseconds
		     - easing (function) #optional easing function from @mina or custom
		     - callback (function) #optional callback function that executes when the animation ends
		     * or
		     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
		     > Usage
		     | // animate all elements in set to radius 10
		     | set.animate({r: 10}, 500, mina.easein);
		     | // or
		     | // animate first element to radius 10, but second to radius 20 and in different time
		     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
		     = (Element) the current element
		    \*/
		    setproto.animate = function (attrs, ms, easing, callback) {
		        if (typeof easing == "function" && !easing.length) {
		            callback = easing;
		            easing = mina.linear;
		        }
		        if (attrs instanceof Snap._.Animation) {
		            callback = attrs.callback;
		            easing = attrs.easing;
		            ms = easing.dur;
		            attrs = attrs.attr;
		        }
		        var args = arguments;
		        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
		            var each = true;
		        }
		        var begin,
		            handler = function () {
		                if (begin) {
		                    this.b = begin;
		                } else {
		                    begin = this.b;
		                }
		            },
		            cb = 0,
		            set = this,
		            callbacker = callback && function () {
		                if (++cb == set.length) {
		                    callback.call(this);
		                }
		            };
		        return this.forEach(function (el, i) {
		            eve.once("snap.animcreated." + el.id, handler);
		            if (each) {
		                args[i] && el.animate.apply(el, args[i]);
		            } else {
		                el.animate(attrs, ms, easing, callbacker);
		            }
		        });
		    };
		    setproto.remove = function () {
		        while (this.length) {
		            this.pop().remove();
		        }
		        return this;
		    };
		    /*\
		     * Set.bind
		     [ method ]
		     **
		     * Specifies how to handle a specific attribute when applied
		     * to a set.
		     *
		     **
		     - attr (string) attribute name
		     - callback (function) function to run
		     * or
		     - attr (string) attribute name
		     - element (Element) specific element in the set to apply the attribute to
		     * or
		     - attr (string) attribute name
		     - element (Element) specific element in the set to apply the attribute to
		     - eattr (string) attribute on the element to bind the attribute to
		     = (object) Set object
		    \*/
		    setproto.bind = function (attr, a, b) {
		        var data = {};
		        if (typeof a == "function") {
		            this.bindings[attr] = a;
		        } else {
		            var aname = b || attr;
		            this.bindings[attr] = function (v) {
		                data[aname] = v;
		                a.attr(data);
		            };
		        }
		        return this;
		    };
		    setproto.attr = function (value) {
		        var unbound = {};
		        for (var k in value) {
		            if (this.bindings[k]) {
		                this.bindings[k](value[k]);
		            } else {
		                unbound[k] = value[k];
		            }
		        }
		        for (var i = 0, ii = this.items.length; i < ii; i++) {
		            this.items[i].attr(unbound);
		        }
		        return this;
		    };
		    /*\
		     * Set.clear
		     [ method ]
		     **
		     * Removes all elements from the set
		    \*/
		    setproto.clear = function () {
		        while (this.length) {
		            this.pop();
		        }
		    };
		    /*\
		     * Set.splice
		     [ method ]
		     **
		     * Removes range of elements from the set
		     **
		     - index (number) position of the deletion
		     - count (number) number of element to remove
		     - insertion… (object) #optional elements to insert
		     = (object) set elements that were deleted
		    \*/
		    setproto.splice = function (index, count, insertion) {
		        index = index < 0 ? mmax(this.length + index, 0) : index;
		        count = mmax(0, mmin(this.length - index, count));
		        var tail = [],
		            todel = [],
		            args = [],
		            i;
		        for (i = 2; i < arguments.length; i++) {
		            args.push(arguments[i]);
		        }
		        for (i = 0; i < count; i++) {
		            todel.push(this[index + i]);
		        }
		        for (; i < this.length - index; i++) {
		            tail.push(this[index + i]);
		        }
		        var arglen = args.length;
		        for (i = 0; i < arglen + tail.length; i++) {
		            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
		        }
		        i = this.items.length = this.length -= count - arglen;
		        while (this[i]) {
		            delete this[i++];
		        }
		        return new Set(todel);
		    };
		    /*\
		     * Set.exclude
		     [ method ]
		     **
		     * Removes given element from the set
		     **
		     - element (object) element to remove
		     = (boolean) `true` if object was found and removed from the set
		    \*/
		    setproto.exclude = function (el) {
		        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
		            this.splice(i, 1);
		            return true;
		        }
		        return false;
		    };
		    setproto.insertAfter = function (el) {
		        var i = this.items.length;
		        while (i--) {
		            this.items[i].insertAfter(el);
		        }
		        return this;
		    };
		    setproto.getBBox = function () {
		        var x = [],
		            y = [],
		            x2 = [],
		            y2 = [];
		        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
		            var box = this.items[i].getBBox();
		            x.push(box.x);
		            y.push(box.y);
		            x2.push(box.x + box.width);
		            y2.push(box.y + box.height);
		        }
		        x = mmin.apply(0, x);
		        y = mmin.apply(0, y);
		        x2 = mmax.apply(0, x2);
		        y2 = mmax.apply(0, y2);
		        return {
		            x: x,
		            y: y,
		            x2: x2,
		            y2: y2,
		            width: x2 - x,
		            height: y2 - y,
		            cx: x + (x2 - x) / 2,
		            cy: y + (y2 - y) / 2
		        };
		    };
		    setproto.clone = function (s) {
		        s = new Set;
		        for (var i = 0, ii = this.items.length; i < ii; i++) {
		            s.push(this.items[i].clone());
		        }
		        return s;
		    };
		    setproto.toString = function () {
		        return "Snap\u2018s set";
		    };
		    setproto.type = "set";
		    // export
		    Snap.Set = Set;
		    Snap.set = function () {
		        var set = new Set;
		        if (arguments.length) {
		            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
		        }
		        return set;
		    };
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob) {
		    var names = {},
		        reUnit = /[a-z]+$/i,
		        Str = String;
		    names.stroke = names.fill = "colour";
		    function getEmpty(item) {
		        var l = item[0];
		        switch (l.toLowerCase()) {
		            case "t": return [l, 0, 0];
		            case "m": return [l, 1, 0, 0, 1, 0, 0];
		            case "r": if (item.length == 4) {
		                return [l, 0, item[2], item[3]];
		            } else {
		                return [l, 0];
		            }
		            case "s": if (item.length == 5) {
		                return [l, 1, 1, item[3], item[4]];
		            } else if (item.length == 3) {
		                return [l, 1, 1];
		            } else {
		                return [l, 1];
		            }
		        }
		    }
		    function equaliseTransform(t1, t2, getBBox) {
		        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
		        t1 = Snap.parseTransformString(t1) || [];
		        t2 = Snap.parseTransformString(t2) || [];
		        var maxlength = Math.max(t1.length, t2.length),
		            from = [],
		            to = [],
		            i = 0, j, jj,
		            tt1, tt2;
		        for (; i < maxlength; i++) {
		            tt1 = t1[i] || getEmpty(t2[i]);
		            tt2 = t2[i] || getEmpty(tt1);
		            if ((tt1[0] != tt2[0]) ||
		                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
		                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
		                ) {
		                    t1 = Snap._.transform2matrix(t1, getBBox());
		                    t2 = Snap._.transform2matrix(t2, getBBox());
		                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
		                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
		                    break;
		            }
		            from[i] = [];
		            to[i] = [];
		            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
		                j in tt1 && (from[i][j] = tt1[j]);
		                j in tt2 && (to[i][j] = tt2[j]);
		            }
		        }
		        return {
		            from: path2array(from),
		            to: path2array(to),
		            f: getPath(from)
		        };
		    }
		    function getNumber(val) {
		        return val;
		    }
		    function getUnit(unit) {
		        return function (val) {
		            return +val.toFixed(3) + unit;
		        };
		    }
		    function getViewBox(val) {
		        return val.join(" ");
		    }
		    function getColour(clr) {
		        return Snap.rgb(clr[0], clr[1], clr[2]);
		    }
		    function getPath(path) {
		        var k = 0, i, ii, j, jj, out, a, b = [];
		        for (i = 0, ii = path.length; i < ii; i++) {
		            out = "[";
		            a = ['"' + path[i][0] + '"'];
		            for (j = 1, jj = path[i].length; j < jj; j++) {
		                a[j] = "val[" + (k++) + "]";
		            }
		            out += a + "]";
		            b[i] = out;
		        }
		        return Function("val", "return Snap.path.toString.call([" + b + "])");
		    }
		    function path2array(path) {
		        var out = [];
		        for (var i = 0, ii = path.length; i < ii; i++) {
		            for (var j = 1, jj = path[i].length; j < jj; j++) {
		                out.push(path[i][j]);
		            }
		        }
		        return out;
		    }
		    function isNumeric(obj) {
		        return isFinite(parseFloat(obj));
		    }
		    function arrayEqual(arr1, arr2) {
		        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
		            return false;
		        }
		        return arr1.toString() == arr2.toString();
		    }
		    Element.prototype.equal = function (name, b) {
		        return eve("snap.util.equal", this, name, b).firstDefined();
		    };
		    eve.on("snap.util.equal", function (name, b) {
		        var A, B, a = Str(this.attr(name) || ""),
		            el = this;
		        if (isNumeric(a) && isNumeric(b)) {
		            return {
		                from: parseFloat(a),
		                to: parseFloat(b),
		                f: getNumber
		            };
		        }
		        if (names[name] == "colour") {
		            A = Snap.color(a);
		            B = Snap.color(b);
		            return {
		                from: [A.r, A.g, A.b, A.opacity],
		                to: [B.r, B.g, B.b, B.opacity],
		                f: getColour
		            };
		        }
		        if (name == "viewBox") {
		            A = this.attr(name).vb.split(" ").map(Number);
		            B = b.split(" ").map(Number);
		            return {
		                from: A,
		                to: B,
		                f: getViewBox
		            };
		        }
		        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
		            if (b instanceof Snap.Matrix) {
		                b = b.toTransformString();
		            }
		            if (!Snap._.rgTransform.test(b)) {
		                b = Snap._.svgTransform2string(b);
		            }
		            return equaliseTransform(a, b, function () {
		                return el.getBBox(1);
		            });
		        }
		        if (name == "d" || name == "path") {
		            A = Snap.path.toCubic(a, b);
		            return {
		                from: path2array(A[0]),
		                to: path2array(A[1]),
		                f: getPath(A[0])
		            };
		        }
		        if (name == "points") {
		            A = Str(a).split(Snap._.separator);
		            B = Str(b).split(Snap._.separator);
		            return {
		                from: A,
		                to: B,
		                f: function (val) { return val; }
		            };
		        }
		        var aUnit = a.match(reUnit),
		            bUnit = Str(b).match(reUnit);
		        if (aUnit && arrayEqual(aUnit, bUnit)) {
		            return {
		                from: parseFloat(a),
		                to: parseFloat(b),
		                f: getUnit(aUnit)
		            };
		        } else {
		            return {
		                from: this.asPX(name),
		                to: this.asPX(name, b),
		                f: getNumber
		            };
		        }
		    });
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob) {
		    var elproto = Element.prototype,
		    has = "hasOwnProperty",
		    supportsTouch = "createTouch" in glob.doc,
		    events = [
		        "click", "dblclick", "mousedown", "mousemove", "mouseout",
		        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
		        "touchcancel"
		    ],
		    touchMap = {
		        mousedown: "touchstart",
		        mousemove: "touchmove",
		        mouseup: "touchend"
		    },
		    getScroll = function (xy, el) {
		        var name = xy == "y" ? "scrollTop" : "scrollLeft",
		            doc = el && el.node ? el.node.ownerDocument : glob.doc;
		        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
		    },
		    preventDefault = function () {
		        this.returnValue = false;
		    },
		    preventTouch = function () {
		        return this.originalEvent.preventDefault();
		    },
		    stopPropagation = function () {
		        this.cancelBubble = true;
		    },
		    stopTouch = function () {
		        return this.originalEvent.stopPropagation();
		    },
		    addEvent = function (obj, type, fn, element) {
		        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
		            f = function (e) {
		                var scrollY = getScroll("y", element),
		                    scrollX = getScroll("x", element);
		                if (supportsTouch && touchMap[has](type)) {
		                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
		                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
		                            var olde = e;
		                            e = e.targetTouches[i];
		                            e.originalEvent = olde;
		                            e.preventDefault = preventTouch;
		                            e.stopPropagation = stopTouch;
		                            break;
		                        }
		                    }
		                }
		                var x = e.clientX + scrollX,
		                    y = e.clientY + scrollY;
		                return fn.call(element, e, x, y);
		            };
		
		        if (type !== realName) {
		            obj.addEventListener(type, f, false);
		        }
		
		        obj.addEventListener(realName, f, false);
		
		        return function () {
		            if (type !== realName) {
		                obj.removeEventListener(type, f, false);
		            }
		
		            obj.removeEventListener(realName, f, false);
		            return true;
		        };
		    },
		    drag = [],
		    dragMove = function (e) {
		        var x = e.clientX,
		            y = e.clientY,
		            scrollY = getScroll("y"),
		            scrollX = getScroll("x"),
		            dragi,
		            j = drag.length;
		        while (j--) {
		            dragi = drag[j];
		            if (supportsTouch) {
		                var i = e.touches && e.touches.length,
		                    touch;
		                while (i--) {
		                    touch = e.touches[i];
		                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
		                        x = touch.clientX;
		                        y = touch.clientY;
		                        (e.originalEvent ? e.originalEvent : e).preventDefault();
		                        break;
		                    }
		                }
		            } else {
		                e.preventDefault();
		            }
		            var node = dragi.el.node,
		                o,
		                next = node.nextSibling,
		                parent = node.parentNode,
		                display = node.style.display;
		            // glob.win.opera && parent.removeChild(node);
		            // node.style.display = "none";
		            // o = dragi.el.paper.getElementByPoint(x, y);
		            // node.style.display = display;
		            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
		            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
		            x += scrollX;
		            y += scrollY;
		            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
		        }
		    },
		    dragUp = function (e) {
		        Snap.unmousemove(dragMove).unmouseup(dragUp);
		        var i = drag.length,
		            dragi;
		        while (i--) {
		            dragi = drag[i];
		            dragi.el._drag = {};
		            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
		            eve.off("snap.drag.*." + dragi.el.id);
		        }
		        drag = [];
		    };
		    /*\
		     * Element.click
		     [ method ]
		     **
		     * Adds a click event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.unclick
		     [ method ]
		     **
		     * Removes a click event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.dblclick
		     [ method ]
		     **
		     * Adds a double click event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.undblclick
		     [ method ]
		     **
		     * Removes a double click event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.mousedown
		     [ method ]
		     **
		     * Adds a mousedown event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.unmousedown
		     [ method ]
		     **
		     * Removes a mousedown event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.mousemove
		     [ method ]
		     **
		     * Adds a mousemove event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.unmousemove
		     [ method ]
		     **
		     * Removes a mousemove event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.mouseout
		     [ method ]
		     **
		     * Adds a mouseout event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.unmouseout
		     [ method ]
		     **
		     * Removes a mouseout event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.mouseover
		     [ method ]
		     **
		     * Adds a mouseover event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.unmouseover
		     [ method ]
		     **
		     * Removes a mouseover event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.mouseup
		     [ method ]
		     **
		     * Adds a mouseup event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.unmouseup
		     [ method ]
		     **
		     * Removes a mouseup event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.touchstart
		     [ method ]
		     **
		     * Adds a touchstart event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.untouchstart
		     [ method ]
		     **
		     * Removes a touchstart event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.touchmove
		     [ method ]
		     **
		     * Adds a touchmove event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.untouchmove
		     [ method ]
		     **
		     * Removes a touchmove event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.touchend
		     [ method ]
		     **
		     * Adds a touchend event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.untouchend
		     [ method ]
		     **
		     * Removes a touchend event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    
		    /*\
		     * Element.touchcancel
		     [ method ]
		     **
		     * Adds a touchcancel event handler to the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    /*\
		     * Element.untouchcancel
		     [ method ]
		     **
		     * Removes a touchcancel event handler from the element
		     - handler (function) handler for the event
		     = (object) @Element
		    \*/
		    for (var i = events.length; i--;) {
		        (function (eventName) {
		            Snap[eventName] = elproto[eventName] = function (fn, scope) {
		                if (Snap.is(fn, "function")) {
		                    this.events = this.events || [];
		                    this.events.push({
		                        name: eventName,
		                        f: fn,
		                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
		                    });
		                } else {
		                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {
		                        try {
		                            this.events[i].f.call(this);
		                        } catch (e) {}
		                    }
		                }
		                return this;
		            };
		            Snap["un" + eventName] =
		            elproto["un" + eventName] = function (fn) {
		                var events = this.events || [],
		                    l = events.length;
		                while (l--) if (events[l].name == eventName &&
		                               (events[l].f == fn || !fn)) {
		                    events[l].unbind();
		                    events.splice(l, 1);
		                    !events.length && delete this.events;
		                    return this;
		                }
		                return this;
		            };
		        })(events[i]);
		    }
		    /*\
		     * Element.hover
		     [ method ]
		     **
		     * Adds hover event handlers to the element
		     - f_in (function) handler for hover in
		     - f_out (function) handler for hover out
		     - icontext (object) #optional context for hover in handler
		     - ocontext (object) #optional context for hover out handler
		     = (object) @Element
		    \*/
		    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
		        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
		    };
		    /*\
		     * Element.unhover
		     [ method ]
		     **
		     * Removes hover event handlers from the element
		     - f_in (function) handler for hover in
		     - f_out (function) handler for hover out
		     = (object) @Element
		    \*/
		    elproto.unhover = function (f_in, f_out) {
		        return this.unmouseover(f_in).unmouseout(f_out);
		    };
		    var draggable = [];
		    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
		    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
		    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
		    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
		    /*\
		     * Element.drag
		     [ method ]
		     **
		     * Adds event handlers for an element's drag gesture
		     **
		     - onmove (function) handler for moving
		     - onstart (function) handler for drag start
		     - onend (function) handler for drag end
		     - mcontext (object) #optional context for moving handler
		     - scontext (object) #optional context for drag start handler
		     - econtext (object) #optional context for drag end handler
		     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
		     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
		     * `drag.over.<id>` fires as well.
		     *
		     * Start event and start handler are called in specified context or in context of the element with following parameters:
		     o x (number) x position of the mouse
		     o y (number) y position of the mouse
		     o event (object) DOM event object
		     * Move event and move handler are called in specified context or in context of the element with following parameters:
		     o dx (number) shift by x from the start point
		     o dy (number) shift by y from the start point
		     o x (number) x position of the mouse
		     o y (number) y position of the mouse
		     o event (object) DOM event object
		     * End event and end handler are called in specified context or in context of the element with following parameters:
		     o event (object) DOM event object
		     = (object) @Element
		    \*/
		    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
		        var el = this;
		        if (!arguments.length) {
		            var origTransform;
		            return el.drag(function (dx, dy) {
		                this.attr({
		                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
		                });
		            }, function () {
		                origTransform = this.transform().local;
		            });
		        }
		        function start(e, x, y) {
		            (e.originalEvent || e).preventDefault();
		            el._drag.x = x;
		            el._drag.y = y;
		            el._drag.id = e.identifier;
		            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
		            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
		            onstart && eve.on("snap.drag.start." + el.id, onstart);
		            onmove && eve.on("snap.drag.move." + el.id, onmove);
		            onend && eve.on("snap.drag.end." + el.id, onend);
		            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
		        }
		        function init(e, x, y) {
		            eve("snap.draginit." + el.id, el, e, x, y);
		        }
		        eve.on("snap.draginit." + el.id, start);
		        el._drag = {};
		        draggable.push({el: el, start: start, init: init});
		        el.mousedown(init);
		        return el;
		    };
		    /*
		     * Element.onDragOver
		     [ method ]
		     **
		     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
		     - f (function) handler for event, first argument would be the element you are dragging over
		    \*/
		    // elproto.onDragOver = function (f) {
		    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
		    // };
		    /*\
		     * Element.undrag
		     [ method ]
		     **
		     * Removes all drag event handlers from the given element
		    \*/
		    elproto.undrag = function () {
		        var i = draggable.length;
		        while (i--) if (draggable[i].el == this) {
		            this.unmousedown(draggable[i].init);
		            draggable.splice(i, 1);
		            eve.unbind("snap.drag.*." + this.id);
		            eve.unbind("snap.draginit." + this.id);
		        }
		        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
		        return this;
		    };
		});
		
		// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
		// 
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		// 
		// http://www.apache.org/licenses/LICENSE-2.0
		// 
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob) {
		    var elproto = Element.prototype,
		        pproto = Paper.prototype,
		        rgurl = /^\s*url\((.+)\)/,
		        Str = String,
		        $ = Snap._.$;
		    Snap.filter = {};
		    /*\
		     * Paper.filter
		     [ method ]
		     **
		     * Creates a `<filter>` element
		     **
		     - filstr (string) SVG fragment of filter provided as a string
		     = (object) @Element
		     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
		     > Usage
		     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
		     |     c = paper.circle(10, 10, 10).attr({
		     |         filter: f
		     |     });
		    \*/
		    pproto.filter = function (filstr) {
		        var paper = this;
		        if (paper.type != "svg") {
		            paper = paper.paper;
		        }
		        var f = Snap.parse(Str(filstr)),
		            id = Snap._.id(),
		            width = paper.node.offsetWidth,
		            height = paper.node.offsetHeight,
		            filter = $("filter");
		        $(filter, {
		            id: id,
		            filterUnits: "userSpaceOnUse"
		        });
		        filter.appendChild(f.node);
		        paper.defs.appendChild(filter);
		        return new Element(filter);
		    };
		    
		    eve.on("snap.util.getattr.filter", function () {
		        eve.stop();
		        var p = $(this.node, "filter");
		        if (p) {
		            var match = Str(p).match(rgurl);
		            return match && Snap.select(match[1]);
		        }
		    });
		    eve.on("snap.util.attr.filter", function (value) {
		        if (value instanceof Element && value.type == "filter") {
		            eve.stop();
		            var id = value.node.id;
		            if (!id) {
		                $(value.node, {id: value.id});
		                id = value.id;
		            }
		            $(this.node, {
		                filter: Snap.url(id)
		            });
		        }
		        if (!value || value == "none") {
		            eve.stop();
		            this.node.removeAttribute("filter");
		        }
		    });
		    /*\
		     * Snap.filter.blur
		     [ method ]
		     **
		     * Returns an SVG markup string for the blur filter
		     **
		     - x (number) amount of horizontal blur, in pixels
		     - y (number) #optional amount of vertical blur, in pixels
		     = (string) filter representation
		     > Usage
		     | var f = paper.filter(Snap.filter.blur(5, 10)),
		     |     c = paper.circle(10, 10, 10).attr({
		     |         filter: f
		     |     });
		    \*/
		    Snap.filter.blur = function (x, y) {
		        if (x == null) {
		            x = 2;
		        }
		        var def = y == null ? x : [x, y];
		        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
		            def: def
		        });
		    };
		    Snap.filter.blur.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.shadow
		     [ method ]
		     **
		     * Returns an SVG markup string for the shadow filter
		     **
		     - dx (number) #optional horizontal shift of the shadow, in pixels
		     - dy (number) #optional vertical shift of the shadow, in pixels
		     - blur (number) #optional amount of blur
		     - color (string) #optional color of the shadow
		     - opacity (number) #optional `0..1` opacity of the shadow
		     * or
		     - dx (number) #optional horizontal shift of the shadow, in pixels
		     - dy (number) #optional vertical shift of the shadow, in pixels
		     - color (string) #optional color of the shadow
		     - opacity (number) #optional `0..1` opacity of the shadow
		     * which makes blur default to `4`. Or
		     - dx (number) #optional horizontal shift of the shadow, in pixels
		     - dy (number) #optional vertical shift of the shadow, in pixels
		     - opacity (number) #optional `0..1` opacity of the shadow
		     = (string) filter representation
		     > Usage
		     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
		     |     c = paper.circle(10, 10, 10).attr({
		     |         filter: f
		     |     });
		    \*/
		    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
		        if (typeof blur == "string") {
		            color = blur;
		            opacity = color;
		            blur = 4;
		        }
		        if (typeof color != "string") {
		            opacity = color;
		            color = "#000";
		        }
		        color = color || "#000";
		        if (blur == null) {
		            blur = 4;
		        }
		        if (opacity == null) {
		            opacity = 1;
		        }
		        if (dx == null) {
		            dx = 0;
		            dy = 2;
		        }
		        if (dy == null) {
		            dy = dx;
		        }
		        color = Snap.color(color);
		        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
		            color: color,
		            dx: dx,
		            dy: dy,
		            blur: blur,
		            opacity: opacity
		        });
		    };
		    Snap.filter.shadow.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.grayscale
		     [ method ]
		     **
		     * Returns an SVG markup string for the grayscale filter
		     **
		     - amount (number) amount of filter (`0..1`)
		     = (string) filter representation
		    \*/
		    Snap.filter.grayscale = function (amount) {
		        if (amount == null) {
		            amount = 1;
		        }
		        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
		            a: 0.2126 + 0.7874 * (1 - amount),
		            b: 0.7152 - 0.7152 * (1 - amount),
		            c: 0.0722 - 0.0722 * (1 - amount),
		            d: 0.2126 - 0.2126 * (1 - amount),
		            e: 0.7152 + 0.2848 * (1 - amount),
		            f: 0.0722 - 0.0722 * (1 - amount),
		            g: 0.2126 - 0.2126 * (1 - amount),
		            h: 0.0722 + 0.9278 * (1 - amount)
		        });
		    };
		    Snap.filter.grayscale.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.sepia
		     [ method ]
		     **
		     * Returns an SVG markup string for the sepia filter
		     **
		     - amount (number) amount of filter (`0..1`)
		     = (string) filter representation
		    \*/
		    Snap.filter.sepia = function (amount) {
		        if (amount == null) {
		            amount = 1;
		        }
		        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
		            a: 0.393 + 0.607 * (1 - amount),
		            b: 0.769 - 0.769 * (1 - amount),
		            c: 0.189 - 0.189 * (1 - amount),
		            d: 0.349 - 0.349 * (1 - amount),
		            e: 0.686 + 0.314 * (1 - amount),
		            f: 0.168 - 0.168 * (1 - amount),
		            g: 0.272 - 0.272 * (1 - amount),
		            h: 0.534 - 0.534 * (1 - amount),
		            i: 0.131 + 0.869 * (1 - amount)
		        });
		    };
		    Snap.filter.sepia.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.saturate
		     [ method ]
		     **
		     * Returns an SVG markup string for the saturate filter
		     **
		     - amount (number) amount of filter (`0..1`)
		     = (string) filter representation
		    \*/
		    Snap.filter.saturate = function (amount) {
		        if (amount == null) {
		            amount = 1;
		        }
		        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
		            amount: 1 - amount
		        });
		    };
		    Snap.filter.saturate.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.hueRotate
		     [ method ]
		     **
		     * Returns an SVG markup string for the hue-rotate filter
		     **
		     - angle (number) angle of rotation
		     = (string) filter representation
		    \*/
		    Snap.filter.hueRotate = function (angle) {
		        angle = angle || 0;
		        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
		            angle: angle
		        });
		    };
		    Snap.filter.hueRotate.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.invert
		     [ method ]
		     **
		     * Returns an SVG markup string for the invert filter
		     **
		     - amount (number) amount of filter (`0..1`)
		     = (string) filter representation
		    \*/
		    Snap.filter.invert = function (amount) {
		        if (amount == null) {
		            amount = 1;
		        }
		//        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
		        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
		            amount: amount,
		            amount2: 1 - amount
		        });
		    };
		    Snap.filter.invert.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.brightness
		     [ method ]
		     **
		     * Returns an SVG markup string for the brightness filter
		     **
		     - amount (number) amount of filter (`0..1`)
		     = (string) filter representation
		    \*/
		    Snap.filter.brightness = function (amount) {
		        if (amount == null) {
		            amount = 1;
		        }
		        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
		            amount: amount
		        });
		    };
		    Snap.filter.brightness.toString = function () {
		        return this();
		    };
		    /*\
		     * Snap.filter.contrast
		     [ method ]
		     **
		     * Returns an SVG markup string for the contrast filter
		     **
		     - amount (number) amount of filter (`0..1`)
		     = (string) filter representation
		    \*/
		    Snap.filter.contrast = function (amount) {
		        if (amount == null) {
		            amount = 1;
		        }
		        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
		            amount: amount,
		            amount2: .5 - amount / 2
		        });
		    };
		    Snap.filter.contrast.toString = function () {
		        return this();
		    };
		});
		
		// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		// http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.
		Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
		    var box = Snap._.box,
		        is = Snap.is,
		        firstLetter = /^[^a-z]*([tbmlrc])/i,
		        toString = function () {
		            return "T" + this.dx + "," + this.dy;
		        };
		    /*\
		     * Element.getAlign
		     [ method ]
		     **
		     * Returns shift needed to align the element relatively to given element.
		     * If no elements specified, parent `<svg>` container will be used.
		     - el (object) @optional alignment element
		     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
		     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
		     > Usage
		     | el.transform(el.getAlign(el2, "top"));
		     * or
		     | var dy = el.getAlign(el2, "top").dy;
		    \*/
		    Element.prototype.getAlign = function (el, way) {
		        if (way == null && is(el, "string")) {
		            way = el;
		            el = null;
		        }
		        el = el || this.paper;
		        var bx = el.getBBox ? el.getBBox() : box(el),
		            bb = this.getBBox(),
		            out = {};
		        way = way && way.match(firstLetter);
		        way = way ? way[1].toLowerCase() : "c";
		        switch (way) {
		            case "t":
		                out.dx = 0;
		                out.dy = bx.y - bb.y;
		            break;
		            case "b":
		                out.dx = 0;
		                out.dy = bx.y2 - bb.y2;
		            break;
		            case "m":
		                out.dx = 0;
		                out.dy = bx.cy - bb.cy;
		            break;
		            case "l":
		                out.dx = bx.x - bb.x;
		                out.dy = 0;
		            break;
		            case "r":
		                out.dx = bx.x2 - bb.x2;
		                out.dy = 0;
		            break;
		            default:
		                out.dx = bx.cx - bb.cx;
		                out.dy = 0;
		            break;
		        }
		        out.toString = toString;
		        return out;
		    };
		    /*\
		     * Element.align
		     [ method ]
		     **
		     * Aligns the element relatively to given one via transformation.
		     * If no elements specified, parent `<svg>` container will be used.
		     - el (object) @optional alignment element
		     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
		     = (object) this element
		     > Usage
		     | el.align(el2, "top");
		     * or
		     | el.align("middle");
		    \*/
		    Element.prototype.align = function (el, way) {
		        return this.transform("..." + this.getAlign(el, way));
		    };
		});
		
		return Snap;
		}));
	
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'spill', { speedIn : 400, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'tilted', { speedIn : 400, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'tunnel-vision', { speedIn : 300, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'wave', { speedIn : 400, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function(wrapper, params) {
		    return __webpack_require__(9)(wrapper, 'widescreen-wiper', { speedIn : 400, easingIn : mina.easeinout });
		};
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		var map = {
			"./brightcove.js": 42,
			"./dailymotion.js": 43,
			"./youtube.js": 44
		};
		function webpackContext(req) {
			return __webpack_require__(webpackContextResolve(req));
		};
		function webpackContextResolve(req) {
			return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
		};
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = 41;
	
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Created by alex on 5/7/2016.
		 */
		/**
		 * Created by alex on 2/15/2016.
		 */
		module.exports = (function() {
		
		    var Q = __webpack_require__(2);
		
		    var dfd = Q.defer(),
		        api_loaded = false;
		
		
		    function fetchPlayer(account_id, player_id, url) {
		        if (api_loaded)
		            return false;
		
		        api_loaded = true;
		
		        // 2. This code loads the IFrame Player API code asynchronously.
		        var tag = document.createElement('script');
		        var firstScriptTag = document.getElementsByTagName('script')[0];
		        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
		
		        tag.onload = function() {
		            dfd.resolve();
		        };
		
		        tag.src = url || "https://players.brightcove.net/" + account_id + "/" + player_id + "_default/index.min.js";
		    }
		
		
		    function isAPIReady() {
		        return dfd.promise;
		    }
		
		    var map_events = {
		        end: 0,
		        playing: 1,
		        pause: 2
		    };
		
		    var events = [];
		
		    function execEvent(events, event_name) {
		        var by_types = _.groupBy(events, 'type');
		        (by_types[event_name] || []).forEach(function(event) {
		            if ('function' == typeof event.listener)
		                event.listener({
		                    data: map_events[event_name]
		                });
		        });
		    }
		
		    function bufferVideoById(id) {
		        var dfd = Q.defer();
		        this._videoElem.display = 'none';
		        this._videoElem.mute();
		        this._videoElem.setAttribute('data-video-id', id);
		        bc(this._videoElem);
		
		        //bc is async!
		        setTimeout(function() {
		            this.player = videojs(this._videoElem).ready(function(){
		                dfd.resolve();
		            });
		        }, 2000);
		
		        return dfd.promise;
		    }
		
		    function playVideoById(id) {
		        this._videoElem.style.display = 'block';
		        this._videoElem.setAttribute('data-video-id', id);
		
		        bc(this._videoElem);
		
		        this.player = videojs(this._videoElem).ready(function(){
		            this.play();
		        });
		    }
		
		
		    function continuePlay() {
		        //this.unMute();
		        this.player.play();
		        this.style.display = 'block';
		    }
		
		    function whenVideoEnd() {
		        return this.play_stop_dfd.promise;
		    }
		
		    function whenStartPlaying() {
		        if (this.play_back_dfd)
		            this.play_back_dfd.reject();
		
		        this.play_back_dfd = Q.defer();
		
		        return this.play_back_dfd.promise;
		    }
		
		    function isPlaying() {
		        return this.getPlayerState() == 1;
		    }
		
		    function isPaused() {
		        return this.getPlayerState() == 2;
		    }
		
		    function emulateEvent(event) {
		        if (event == 0)
		            try {
		                this.play_stop_dfd.resolve();
		            } catch (e) {}
		    }
		
		    return {
		        createPlayer: function(elem, params) {
		            console.debug('Player params', params);
		
		            fetchPlayer(params.Brightcove.accountId, params.Brightcove.playerId, params.Brightcove.url);
		
		            return isAPIReady().then(function() {
		                var player_dfd = Q.defer();
		
		                var video_elem = document.createElement('video');
		                video_elem.setAttribute('data-account', params.Brightcove.accountId);
		                video_elem.setAttribute('data-player', params.Brightcove.playerId);
		                video_elem.setAttribute('data-embed', 'default');
		                video_elem.width = '100%';
		                video_elem.height = '100%';
		                if (params.playerVars.autoplay)
		                    video_elem.setAttribute('autoplay', 'autoplay');
		
		                elem.appendChild(video_elem);
		
		                var player = {
		                    _videoElem: video_elem
		                };
		
		                player.destroy = function() {
		                    try {
		                        player.player.dispose();
		                    } catch (e) {
		                    }
		
		                    try {
		                        elem.removeChild(player._videoElem);
		                    } catch (e) {
		
		                    }
		                };
		
		                player.bufferVideoById = bufferVideoById.bind(player);
		                player.playVideoById = playVideoById.bind(player);
		                player.continuePlay = continuePlay.bind(player);
		                player.whenVideoEnd = whenVideoEnd.bind(player);
		                player.whenStartPlaying = whenStartPlaying.bind(player);
		                player.isPlaying = isPlaying.bind(player);
		                player.isPaused = isPaused.bind(player);
		
		                player.emulateEvent = emulateEvent.bind(player);
		
		
		                player._videoElem.addEventListener('ended', function() {
		                    player.play_stop_dfd.resolve();
		                });
		
		                player_dfd.resolve(player);
		
		
		                return player_dfd.promise;
		            });
		        }
		    };
		})();
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Created by alex on 2/15/2016.
		 */
		module.exports = (function() {
		
		    var Q = __webpack_require__(2);
		
		    var dfd = Q.defer();
		
		    // 2. This code loads the IFrame Player API code asynchronously.
		    var tag = document.createElement('script');
		
		    tag.src = "https://api.dmcdn.net/all.js";
		    var firstScriptTag = document.getElementsByTagName('script')[0];
		    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
		
		
		    if ('function' == typeof window.dmAsyncInit) {
		        var old_handler = window.dmAsyncInit;
		
		        window.dmAsyncInit = function() {
		            old_handler();
		            dfd.resolve();
		        }
		    } else
		        window.dmAsyncInit = function() {
		            dfd.resolve();
		        };
		
		    function isAPIReady() {
		        return dfd.promise;
		    }
		
		    var map_events = {
		        end: 0,
		        playing: 1,
		        pause: 2
		    };
		
		    var events = [],
		        error_events = [];
		
		    function execEvent(events, event_name) {
		        var by_types = _.groupBy(events, 'type');
		        (by_types[event_name] || []).forEach(function(event) {
		            if ('function' == typeof event.listener)
		                event.listener({
		                    data: map_events[event_name]
		                });
		        });
		    }
		
		    function bufferVideoById(id) {
		        var dfd = Q.defer();
		        this.style.display = 'none';
		        this.mute();
		        //this.setQuality('1080');
		        this.loadVideoById(id);
		        setTimeout(function() {
		            this.pauseVideo();
		            dfd.resolve();
		        }.bind(this), 0.5);
		
		        return dfd.promise;
		    }
		
		    function playVideoById(id) {
		        this.style.display = 'block';
		        //this.setQuality('1080');
		        this.loadVideoById(id);
		    }
		
		
		    function continuePlay() {
		        //this.unMute();
		        this.playVideo();
		        this.style.display = 'block';
		    }
		
		    function whenVideoEnd() {
		        return this.play_stop_dfd.promise;
		    }
		
		    function whenStartPlaying() {
		        if (this.play_back_dfd)
		            this.play_back_dfd.reject();
		
		        this.play_back_dfd = Q.defer();
		
		        return this.play_back_dfd.promise;
		    }
		
		    function isPlaying() {
		        return this.getPlayerState() == 1;
		    }
		
		    function isPaused() {
		        return this.getPlayerState() == 2;
		    }
		
		    function emulateEvent(event) {
		        if (event == 0)
		            try {
		                this.play_stop_dfd.resolve();
		            } catch (e) {}
		    }
		
		    return {
		        createPlayer: function(elem, params) {
		            console.debug('Player params', params);
		            return isAPIReady().then(function() {
		                var player_dfd = Q.defer();
		
		                //elem.style.display = 'none';
		
		                var dm_player_params = {
		                    params: {
		                        'api': '1',
		                        'sharing-enable': false,
		                    }
		                };
		                dm_player_params.width = params.width;
		                dm_player_params.height = params.height;
		                if (params.playerVars && 'object' == typeof params.playerVars) {
		
		                    if ('undefined' != typeof params.playerVars.autoplay)
		                        dm_player_params.params.autoplay = !!params.playerVars.autoplay;
		
		                    if ('undefined' != typeof params.playerVars.controls)
		                        dm_player_params.params.controls = !!params.playerVars.controls;
		
		                    if ('undefined' != typeof params.playerVars.rel)
		                        dm_player_params.params['endscreen-enable'] = !!params.playerVars.rel;
		
		                    if ('undefined' != typeof params.playerVars.modestbranding)
		                        dm_player_params.params['ui-logo'] = !!params.playerVars.modestbranding;
		
		                    if ('undefined' != typeof params.playerVars.showinfo)
		                        dm_player_params.params['ui-start_screen_info'] = !!params.playerVars.showinfo;
		                }
		
		                console.debug('Dailymotion player params', dm_player_params);
		                //return false;
		                var player = window.DM.player(elem, dm_player_params);
		
		                var oldEventListener = player.addEventListener;
		
		                oldEventListener('error', function() {
		                    var code = 0;
		                    if (player.error.code == 'PLAYER_ERR_VIDEO_NOT_SUPPORTED')
		                        code = 5;
		
		                    error_events.forEach(function(listener) {
		                        listener({
		                            data: code
		                        });
		                    });
		                    console.debug('Dailymotion error', player.error);
		                });
		
		                var api_ready = false;
		                oldEventListener('apiready', function() {
		                    if (api_ready)
		                        return;
		
		                    api_ready = true;
		
		                    console.debug('api ready');
		
		                    player.play_stop_dfd = Q.defer();
		
		                    player.loadVideoById = function(id) {
		                        player.load(id, {
		                            autoplay: true
		                        });
		                    };
		                    player.playVideo = player.play;
		                    player.pauseVideo = player.pause;
		                    player.seekTo = player.seek;
		                    player.mute = function() {
		                        player.setMuted(true);
		                    };
		                    var oldSetVolume = player.setVolume;
		                    player.unMute = function() {
		                        player.setMuted(false);
		                    };
		                    player.setVolume = function(volume) {
		                        oldSetVolume(~~volume/100);
		                    };
		                    player.getDuration = function() {
		                        return player.duration;
		                    };
		                    player.getDuration = function() {
		                        return player.duration;
		                    };
		                    player.getCurrentTime = function() {
		                        return player.currentTime;
		                    };
		                    player.getPlayerState = function() {
		                        if (player.paused)
		                            return 2;
		                        if (player.ended)
		                            return 0;
		
		                        return 1;
		                    };
		                    player.destroy = function() {
		                        player.parentNode.removeChild(player);
		                        player = null;
		                    };
		
		
		                    player.bufferVideoById = bufferVideoById.bind(player);
		                    player.playVideoById = playVideoById.bind(player);
		                    player.continuePlay = continuePlay.bind(player);
		                    player.whenVideoEnd = whenVideoEnd.bind(player);
		                    player.whenStartPlaying = whenStartPlaying.bind(player);
		                    player.isPlaying = isPlaying.bind(player);
		                    player.isPaused = isPaused.bind(player);
		
		                    player.emulateEvent = emulateEvent.bind(player);
		
		                    //temprorary solution for api not ready!
		                    setTimeout(function() {
		                        player_dfd.resolve(player/*new Player(player, params)*/);
		                    }, 2000);
		                });
		
		
		                events = [];
		                error_events = [];
		
		                oldEventListener('end', function() {
		                    execEvent(events, 'end');
		                    if (this.play_stop_dfd)
		                        this.play_stop_dfd.resolve();
		                }.bind(player));
		                oldEventListener('pause', function() {
		                    execEvent(events, 'pause');
		                });
		                oldEventListener('playing', function() {
		                    execEvent(events, 'playing');
		                    if (this.play_back_dfd)
		                        this.play_back_dfd.resolve();
		                }.bind(player));
		
		                player.addEventListener = function(event, listener) {
		                    if (event == 'onStateChange') {
		                        events = events.concat([{
		                            type: 'end',
		                            listener: listener
		                        },{
		                            type: 'pause',
		                            listener: listener
		                        },{
		                            type: 'playing',
		                            listener: listener
		                        }]);
		                    } else if (event == 'onError')
		                        error_events.push(listener);
		                };
		
		                return player_dfd.promise;
		            });
		        }
		    };
		})();
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Created by alex on 2/15/2016.
		 */
		
		var Q = __webpack_require__(2);
		var _ = __webpack_require__(5);
		
		module.exports = (function() {
		
		    var dfd = Q.defer();
		
		    // 2. This code loads the IFrame Player API code asynchronously.
		    var tag = document.createElement('script');
		
		    tag.src = "https://www.youtube.com/iframe_api";
		    var firstScriptTag = document.getElementsByTagName('script')[0];
		    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
		
		
		    if ('function' == typeof window.onYouTubeIframeAPIReady) {
		        var old_handler = window.onYouTubeIframeAPIReady;
		
		        window.onYouTubeIframeAPIReady = function() {
		            old_handler();
		            dfd.resolve();
		        }
		    } else
		        window.onYouTubeIframeAPIReady = function() {
		            dfd.resolve();
		        };
		
		
		    function isAPIReady() {
		        return dfd.promise;
		    }
		
		
		
		/*    function Player(player, params) {
		
		    }*/
		
		
		    function bufferVideoById(id, seconds) {
		        var dfd = Q.defer();
		
		        this.is_buffering = true;
		
		        this.curr_video = {
		            api: 'youtube',
		            id: id
		        };
		
		        this.getIframe().style.display = 'none';
		        this.mute();
		        this.loadVideoById(id);
		        //this.setPlaybackQuality('highres');
		        setTimeout(function() {
		            this.is_buffering = false;
		            this.pauseVideo();
		            dfd.resolve();
		        }.bind(this), seconds || 0.3);
		
		        return dfd.promise;
		    }
		
		    function playVideoById(id) {
		        this.getIframe().style.display = 'block';
		        //this.setPlaybackQuality('highres');
		        this.loadVideoById(id);
		    }
		
		
		    function continuePlay() {
		        //this.unMute();
		        this.playVideo();
		        this.getIframe().style.display = 'block';
		    }
		
		    function whenVideoEnd() {
		        return this.play_stop_dfd.promise;
		    }
		
		    function whenStartPlaying() {
		        if (this.play_back_dfd)
		            this.play_back_dfd.reject();
		
		        this.play_back_dfd = Q.defer();
		
		        return this.play_back_dfd.promise;
		    }
		
		    function isPlaying() {
		        return this.getPlayerState() == window.YT.PlayerState.PLAYING;
		    }
		
		    function isPaused() {
		        return this.getPlayerState() == window.YT.PlayerState.PAUSED;
		    }
		
		    function emulateEvent(event) {
		        if (event == window.YT.PlayerState.ENDED)
		            try {
		                this.play_stop_dfd.resolve();
		            } catch (e) {}
		    }
		
		    return {
		        createPlayer: function(elem, params) {
		            return isAPIReady().then(function() {
		                var player_dfd = Q.defer();
		
		                //elem.style.display = 'none';
		
		                var player = new window.YT.Player(elem, params);
		
		                player.addEventListener('onReady', function() {
		                    player.play_stop_dfd = Q.defer();
		                    player.bufferVideoById = bufferVideoById.bind(player);
		                    player.playVideoById = playVideoById.bind(player);
		                    player.continuePlay = continuePlay.bind(player);
		                    player.whenVideoEnd = whenVideoEnd.bind(player);
		                    player.whenStartPlaying = whenStartPlaying.bind(player);
		                    player.isPlaying = isPlaying.bind(player);
		                    player.isPaused = isPaused.bind(player);
		
		                    player.emulateEvent = emulateEvent.bind(player);
		
		                    player_dfd.resolve(player/*new Player(player, params)*/);
		                });
		
		                player.addEventListener('onStateChange', function(e) {
		                    if (window.YT.PlayerState.ENDED == e.data)
		                        this.play_stop_dfd.resolve();
		                    else if (window.YT.PlayerState.PLAYING == e.data) {
		                        //TODO don't fire while buffering by bufferVideoById func
		                        if (this.play_back_dfd && !this.is_buffering)
		                            this.play_back_dfd.resolve(this.curr_video);
		                    }
		                }.bind(player));
		
		                return player_dfd.promise;
		            });
		        }
		    };
		})();
	
	/***/ }
	/******/ ]);
	//# sourceMappingURL=player.js.map

/***/ }

/******/ });
//# sourceMappingURL=test_youtube.js.map